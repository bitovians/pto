/*[system-bundles-config]*/
System.bundles = {"bundles/bitovians-pto/app.css!":["styles.less!steal-less@1.3.4#less"],"bundles/bitovians-pto/components/dashboard/dashboard":["lodash@4.17.20#lodash","bitovians-pto@1.0.0#components/dashboard/dashboard.stache!steal-stache@4.1.5#steal-stache","bitovians-pto@1.0.0#components/dashboard/dashboard"],"bundles/bitovians-pto/components/authenticate/authenticate":["bitovians-pto@1.0.0#components/authenticate/authenticate.stache!steal-stache@4.1.5#steal-stache","bitovians-pto@1.0.0#components/authenticate/authenticate"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global, require, exports, module) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            flow: function (fns) {
                return function () {
                    var res = fns[0].apply(this, arguments);
                    for (var i = 1; i < fns.length; i++) {
                        res = fns[i].call(this, res);
                    }
                    return res;
                };
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        var version = descriptor.version;
                        if (version && version[0] !== '^') {
                            version = encodeURIComponent(decodeURIComponent(version));
                        }
                        return descriptor.packageName + (version ? '@' + version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                },
                isBareIdentifier: function (identifier) {
                    return identifier && identifier[0] !== '.' && identifier[0] !== '@';
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        if (utils.path.endsWithSlash(pkg.main)) {
                            main = pkg.main + 'index';
                        } else {
                            main = pkg.main;
                        }
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg && pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.m?js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/]*(?::[^:@\/]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-extension*/
define('npm-extension', [
    'require',
    'exports',
    'module',
    '@steal',
    './npm-utils'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isElectron = isNode && !!process.versions.electron;
        var isBrowser = typeof window !== 'undefined' && (!isNode || isElectron) && !isWorker;
        exports.addExtension = function addNpmExtension(System) {
            if (System._extensions) {
                System._extensions.push(addNpmExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var nameIsNpmModule = utils.moduleName.isNpm(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (nameIsNpmModule && parentModuleName) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parsedParentModuleName = utils.moduleName.parse(parentName);
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(utils.path.removeDotSlash(refPkg.main));
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        var steal = utils.pkg.config(refPkg);
                        if (steal && steal.map && typeof steal.map[name] === 'string') {
                            var mappedName = steal.map[name];
                            var envConfig = steal.envs && steal.envs[loader.env];
                            if (envConfig && envConfig.map && typeof envConfig.map[name] === 'string') {
                                mappedName = envConfig.map[name];
                            }
                            return loader.normalize(mappedName, parentName, parentAddress, pluginNormalize);
                        } else {
                            return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                        }
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var p = oldNormalize.call(loader, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                var pmn = load.metadata.parsedModuleName = parsedModuleName;
                load.metadata.npmPackage = utils.pkg.findByNameAndVersion(this, pmn.packageName, pmn.version);
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        var statusCode = err.statusCode;
                        if (statusCode !== 404 && statusCode !== 0) {
                            return Promise.reject(err);
                        }
                        if (!loader.npmContext) {
                            loader.npmContext = { forwardSlashMap: {} };
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err).then(null, function (e) {
                            return Promise.reject(err);
                        });
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise.catch(function (error) {
                    var statusCode = error.statusCode;
                    if ((statusCode === 404 || statusCode === 0) && utils.moduleName.isBareIdentifier(load.name) && !utils.pkg.isRoot(loader, load.metadata.npmPackage)) {
                        var newError = new Error([
                            'Could not load \'' + load.name + '\'',
                            'Is this an npm module not saved in your package.json?'
                        ].join('\n'));
                        newError.statusCode = error.statusCode;
                        newError.stack = newError.stack + error.stack;
                        throw newError;
                    } else {
                        throw error;
                    }
                });
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    var conv = context.convert.steal(context, pkg, cfg, true);
                    context.convert.updateConfigOnPackageLoad(conv, false, true, context.applyBuildConfig);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            var newLoader = System._newLoader || Function.prototype;
            System._newLoader = function (loader) {
                loader.npmContext = this.npmContext;
                loader.npmParentMap = this.npmParentMap;
                return newLoader.apply(this, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'bitovians-pto@1.0.0#app';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler',
            'treeShaking'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'bitovians-pto',
            'version': '1.0.0',
            'fileUrl': './package.json',
            'main': 'app.js',
            'steal': {
                'map': { 'xml-js@1.6.11#lib/index': 'xml-js@1.6.11#dist/xml-js' },
                'meta': { 'xml-js@1.6.11#dist/xml-js': { 'format': 'global' } },
                'plugins': [
                    'can',
                    'steal-less'
                ],
                'npmAlgorithm': 'flat'
            },
            'resolutions': {
                'bitovians-pto': '1.0.0',
                'can': '5.33.3',
                'steal-stache': '4.1.5',
                'steal-less': '1.3.4',
                'moment': '2.27.0',
                'xml-js': '1.6.11',
                'can-assign': '1.3.3',
                'can-stache': '4.17.21',
                'lodash': '4.17.20'
            }
        },
        {
            'name': 'steal-less',
            'version': '1.3.4',
            'fileUrl': './node_modules/steal-less/package.json',
            'main': 'less.js',
            'steal': {
                'plugins': ['steal-css'],
                'envs': {
                    'build': { 'map': { 'steal-less/less-engine': 'steal-less/less-engine-node' } },
                    'server-development': { 'map': { 'steal-less/less-engine': 'steal-less/less-engine-node' } },
                    'server-production': { 'map': { 'steal-less/less-engine': 'steal-less/less-engine-node' } },
                    'bundle-build': {
                        'map': { 'steal-less/less-engine': 'steal-less/less-engine-node' },
                        'meta': { 'steal-less/less': { 'useLocalDeps': true } }
                    }
                },
                'ext': { 'less': 'steal-less' },
                'meta': {}
            },
            'resolutions': {}
        },
        {
            'name': 'can',
            'version': '5.33.3',
            'fileUrl': './node_modules/can/package.json',
            'main': 'can.js',
            'steal': {
                'npmAlgorithm': 'flat',
                'main': 'can',
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'async': true,
                    'saucelabs': true,
                    'test-saucelabs': true,
                    'wd': true,
                    'http-server': true
                },
                'meta': { 'socket.io-client/dist/socket.io': { 'format': 'cjs' } },
                'configDependencies': ['./node_modules/steal-conditional/conditional.js'],
                'plugins': ['steal-stache']
            },
            'resolutions': {
                'can': '5.33.3',
                'can-component': '4.6.2',
                'can-define': '2.8.0',
                'can-debug': '2.0.7'
            }
        },
        {
            'name': 'steal',
            'version': '2.2.4',
            'fileUrl': './node_modules/steal/package.json',
            'main': 'main',
            'steal': {
                'npmDependencies': {
                    'console-browserify': true,
                    'constants-browserify': true,
                    'crypto-browserify': true,
                    'http-browserify': true,
                    'buffer': true,
                    'os-browserify': true,
                    'vm-browserify': true,
                    'zlib-browserify': true,
                    'assert': true,
                    'domain-browser': true,
                    'events': true,
                    'https-browserify': true,
                    'path-browserify': true,
                    'string_decoder': true,
                    'tty-browserify': true,
                    'process': true,
                    'punycode': true
                }
            },
            'globalBrowser': {
                'console': 'console-browserify',
                'constants': 'constants-browserify',
                'crypto': 'crypto-browserify',
                'http': 'http-browserify',
                'buffer': 'buffer',
                'os': 'os-browserify',
                'vm': 'vm-browserify',
                'zlib': 'zlib-browserify',
                'assert': 'assert',
                'child_process': 'steal#ext/builtin/child_process',
                'cluster': 'steal#ext/builtin/cluster',
                'dgram': 'steal#ext/builtin/dgram',
                'dns': 'steal#ext/builtin/dns',
                'domain': 'domain-browser',
                'events': 'events',
                'fs': 'steal#ext/builtin/fs',
                'https': 'https-browserify',
                'module': 'steal#ext/builtin/module',
                'net': 'steal#ext/builtin/net',
                'path': 'path-browserify',
                'process': 'process',
                'querystring': 'steal#ext/builtin/querystring',
                'readline': 'steal#ext/builtin/readline',
                'repl': 'steal#ext/builtin/repl',
                'stream': 'steal#ext/builtin/stream',
                'string_decoder': 'string_decoder',
                'sys': 'steal#ext/builtin/sys',
                'timers': 'steal#ext/builtin/timers',
                'tls': 'steal#ext/builtin/tls',
                'tty': 'tty-browserify',
                'url': 'steal#ext/builtin/url',
                'util': 'steal#ext/builtin/util',
                '_stream_readable': 'steal#ext/builtin/_stream_readable',
                '_stream_writable': 'steal#ext/builtin/_stream_writable',
                '_stream_duplex': 'steal#ext/builtin/_stream_duplex',
                '_stream_transform': 'steal#ext/builtin/_stream_transform',
                '_stream_passthrough': 'steal#ext/builtin/_stream_passthrough'
            },
            'resolutions': {}
        },
        {
            'name': 'steal-css',
            'version': '1.3.2',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.3.2#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'steal-stache',
            'version': '4.1.5',
            'fileUrl': './node_modules/steal-stache/package.json',
            'main': 'steal-stache.js',
            'steal': {
                'main': 'steal-stache',
                'configDependencies': ['live-reload'],
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmAlgorithm': 'flat',
                'ext': { 'stache': 'steal-stache' }
            },
            'resolutions': {
                'can-stache-bindings': '4.10.9',
                'can-view-import': '4.2.2'
            }
        },
        {
            'name': 'buffer',
            'version': '5.0.8',
            'fileUrl': './node_modules/buffer/package.json',
            'main': 'index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'assert',
            'version': '1.4.1',
            'fileUrl': './node_modules/assert/package.json',
            'main': './assert.js',
            'resolutions': {}
        },
        {
            'name': 'console-browserify',
            'version': '1.1.0',
            'fileUrl': './node_modules/console-browserify/package.json',
            'main': 'index',
            'resolutions': {}
        },
        {
            'name': 'events',
            'version': '1.1.1',
            'fileUrl': './node_modules/events/package.json',
            'main': './events.js',
            'resolutions': {}
        },
        {
            'name': 'crypto-browserify',
            'version': '3.11.1',
            'fileUrl': './node_modules/crypto-browserify/package.json',
            'browser': { 'crypto': '@empty' },
            'resolutions': {}
        },
        {
            'name': 'domain-browser',
            'version': '1.1.7',
            'fileUrl': './node_modules/domain-browser/package.json',
            'main': './index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'constants-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/constants-browserify/package.json',
            'main': 'constants.json',
            'resolutions': {}
        },
        {
            'name': 'os-browserify',
            'version': '0.3.0',
            'fileUrl': './node_modules/os-browserify/package.json',
            'main': 'main.js',
            'browser': 'browser.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'path-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/path-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'http-browserify',
            'version': '1.7.0',
            'fileUrl': './node_modules/http-browserify/package.json',
            'main': 'index.js',
            'browser': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'https-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/https-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'punycode',
            'version': '2.0.1',
            'fileUrl': './node_modules/punycode/package.json',
            'main': 'punycode.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '1.1.1',
            'fileUrl': './node_modules/string_decoder/package.json',
            'main': 'lib/string_decoder.js',
            'resolutions': {}
        },
        {
            'name': 'tty-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/tty-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'process',
            'version': '0.11.10',
            'fileUrl': './node_modules/process/package.json',
            'main': './index.js',
            'browser': './browser.js',
            'resolutions': {}
        },
        {
            'name': 'vm-browserify',
            'version': '0.0.4',
            'fileUrl': './node_modules/vm-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'zlib-browserify',
            'version': '0.0.3',
            'fileUrl': './node_modules/zlib-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '1.0.3',
            'fileUrl': './node_modules/steal/node_modules/string_decoder/package.json',
            'main': 'lib/string_decoder.js',
            'resolutions': {}
        },
        {
            'name': 'moment',
            'version': '2.27.0',
            'fileUrl': './node_modules/moment/package.json',
            'main': './moment.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'xml-js',
            'version': '1.6.11',
            'fileUrl': './node_modules/xml-js/package.json',
            'main': 'lib/index.js',
            'resolutions': {}
        },
        {
            'name': 'can-stache-ast',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-stache-ast/package.json',
            'main': 'can-stache-ast.js',
            'resolutions': {
                'can-stache-ast': '1.1.0',
                'can-view-parser': '4.1.3'
            }
        },
        {
            'name': 'steal-config-utils',
            'version': '1.0.0',
            'fileUrl': './node_modules/steal-config-utils/package.json',
            'main': 'main.js',
            'resolutions': {}
        },
        {
            'name': 'can-component',
            'version': '4.6.2',
            'fileUrl': './node_modules/can-component/package.json',
            'main': 'can-component',
            'steal': {},
            'resolutions': {
                'can-define': '2.8.0',
                'can-component': '4.6.2',
                'can-construct': '3.5.6',
                'can-namespace': '1.0.0',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-observation-recorder': '1.3.1',
                'can-bind': '1.5.1',
                'can-stache': '4.17.21',
                'can-stache-bindings': '4.10.9',
                'can-view-scope': '4.13.6',
                'can-view-nodelist': '4.3.4',
                'can-simple-observable': '2.5.0',
                'can-simple-map': '4.3.2',
                'can-assign': '1.3.3',
                'can-child-nodes': '1.2.1',
                'can-string': '1.1.0',
                'can-dom-mutate': '1.3.11',
                'can-dom-events': '1.3.11',
                'can-view-callbacks': '4.4.1',
                'can-view-model': '4.0.3',
                'can-dom-data': '1.0.3',
                'can-globals': '1.2.2',
                'can-log': '1.0.2',
                'can-queues': '1.3.1',
                'can-control': '4.4.3'
            }
        },
        {
            'name': 'can-define',
            'version': '2.8.0',
            'fileUrl': './node_modules/can-define/package.json',
            'main': 'can-define.js',
            'resolutions': {
                'can-define': '2.8.0',
                'can-construct': '3.5.6',
                'can-namespace': '1.0.0',
                'can-log': '1.0.2',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-event-queue': '1.1.7',
                'can-queues': '1.3.1',
                'can-observation-recorder': '1.3.1',
                'can-observation': '4.2.0',
                'can-simple-observable': '2.5.0',
                'can-assign': '1.3.3',
                'can-diff': '1.5.0',
                'can-define-lazy-value': '1.1.1',
                'can-string-to-any': '1.2.1',
                'can-data-types': '1.2.1',
                'can-single-reference': '1.3.0'
            }
        },
        {
            'name': 'can-view-parser',
            'version': '4.1.3',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-log': '1.0.2',
                'can-attribute-encoder': '1.1.4'
            }
        },
        {
            'name': 'can-debug',
            'version': '2.0.7',
            'fileUrl': './node_modules/can-debug/package.json',
            'main': 'can-debug',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-debug'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-debug': '2.0.7',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-queues': '1.3.1',
                'can-observation': '4.2.0',
                'can-diff': '1.5.0',
                'can-globals': '1.2.2',
                'can-assign': '1.3.3',
                'can-reflect-dependencies': '1.1.2'
            }
        },
        {
            'name': 'can-construct',
            'version': '3.5.6',
            'fileUrl': './node_modules/can-construct/package.json',
            'main': 'can-construct',
            'steal': {},
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-log': '1.0.2',
                'can-namespace': '1.0.0',
                'can-symbol': '1.6.5',
                'can-string': '1.1.0'
            }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'can-log',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-log/package.json',
            'main': 'can-log',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-log'
            },
            'resolutions': { 'can-log': '1.0.2' }
        },
        {
            'name': 'can-symbol',
            'version': '1.6.5',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-symbol'
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-reflect',
            'version': '1.18.0',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-namespace': '1.0.0',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-event-queue',
            'version': '1.1.7',
            'fileUrl': './node_modules/can-event-queue/package.json',
            'main': './can-event-queue.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ]
            },
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-symbol': '1.6.5',
                'can-queues': '1.3.1',
                'can-key-tree': '1.2.2',
                'can-event-queue': '1.1.7',
                'can-define-lazy-value': '1.1.1',
                'can-log': '1.0.2',
                'can-dom-events': '1.3.11'
            }
        },
        {
            'name': 'can-queues',
            'version': '1.3.1',
            'fileUrl': './node_modules/can-queues/package.json',
            'main': './can-queues.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-queues'
            },
            'resolutions': {
                'can-log': '1.0.2',
                'can-queues': '1.3.1',
                'can-namespace': '1.0.0',
                'can-assign': '1.3.3',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-observation-recorder',
            'version': '1.3.1',
            'fileUrl': './node_modules/can-observation-recorder/package.json',
            'main': './can-observation-recorder.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-bind',
            'version': '1.5.1',
            'fileUrl': './node_modules/can-bind/package.json',
            'main': 'can-bind',
            'steal': {
                'npmIgnore': {
                    'steal-tools': true,
                    'testee': true
                },
                'main': 'can-bind'
            },
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-symbol': '1.6.5',
                'can-namespace': '1.0.0',
                'can-queues': '1.3.1',
                'can-assign': '1.3.3',
                'can-log': '1.0.2',
                'can-reflect-dependencies': '1.1.2'
            }
        },
        {
            'name': 'can-stache',
            'version': '4.17.21',
            'fileUrl': './node_modules/can-stache/package.json',
            'main': 'can-stache',
            'resolutions': {
                'can-view-callbacks': '4.4.1',
                'can-stache': '4.17.21',
                'can-log': '1.0.2',
                'can-namespace': '1.0.0',
                'can-globals': '1.2.2',
                'can-assign': '1.3.3',
                'can-reflect': '1.18.0',
                'can-view-scope': '4.13.6',
                'can-observation-recorder': '1.3.1',
                'can-symbol': '1.6.5',
                'can-view-nodelist': '4.3.4',
                'can-view-parser': '4.1.3',
                'can-attribute-encoder': '1.1.4',
                'can-import-module': '1.2.0',
                'can-stache-ast': '1.1.0',
                'can-view-target': '4.1.6',
                'can-dom-mutate': '1.3.11',
                'can-observation': '4.2.0',
                'can-stache-key': '1.4.3',
                'can-stache-helpers': '1.2.0',
                'can-dom-data': '1.0.3',
                'can-fragment': '1.3.1',
                'can-define-lazy-value': '1.1.1',
                'can-simple-observable': '2.5.0',
                'can-view-live': '4.2.8',
                'can-join-uris': '1.2.0'
            }
        },
        {
            'name': 'can-stache-bindings',
            'version': '4.10.9',
            'fileUrl': './node_modules/can-stache-bindings/package.json',
            'main': 'can-stache-bindings',
            'steal': { 'main': 'can-stache-bindings' },
            'resolutions': {
                'can-bind': '1.5.1',
                'can-stache': '4.17.21',
                'can-view-callbacks': '4.4.1',
                'can-view-model': '4.0.3',
                'can-observation-recorder': '1.3.1',
                'can-simple-observable': '2.5.0',
                'can-view-scope': '4.13.6',
                'can-assign': '1.3.3',
                'can-log': '1.0.2',
                'can-dom-mutate': '1.3.11',
                'can-dom-data': '1.0.3',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-queues': '1.3.1',
                'can-view-nodelist': '4.3.4',
                'can-event-queue': '1.1.7',
                'can-attribute-encoder': '1.1.4',
                'can-reflect-dependencies': '1.1.2',
                'can-stache-key': '1.4.3',
                'can-attribute-observable': '1.2.7'
            }
        },
        {
            'name': 'can-view-scope',
            'version': '4.13.6',
            'fileUrl': './node_modules/can-view-scope/package.json',
            'main': 'can-view-scope',
            'resolutions': {
                'can-observation-recorder': '1.3.1',
                'can-view-scope': '4.13.6',
                'can-assign': '1.3.3',
                'can-namespace': '1.0.0',
                'can-reflect': '1.18.0',
                'can-log': '1.0.2',
                'can-stache-key': '1.4.3',
                'can-stache-helpers': '1.2.0',
                'can-define-lazy-value': '1.1.1',
                'can-simple-map': '4.3.2',
                'can-single-reference': '1.3.0',
                'can-observation': '4.2.0',
                'can-symbol': '1.6.5',
                'can-reflect-dependencies': '1.1.2',
                'can-event-queue': '1.1.7',
                'can-simple-observable': '2.5.0'
            }
        },
        {
            'name': 'can-view-nodelist',
            'version': '4.3.4',
            'fileUrl': './node_modules/can-view-nodelist/package.json',
            'main': 'can-view-nodelist',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-dom-mutate': '1.3.11'
            }
        },
        {
            'name': 'can-simple-observable',
            'version': '2.5.0',
            'fileUrl': './node_modules/can-simple-observable/package.json',
            'main': 'can-simple-observable',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-simple-observable': '2.5.0',
                'can-namespace': '1.0.0',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-observation-recorder': '1.3.1',
                'can-event-queue': '1.1.7',
                'can-log': '1.0.2',
                'can-observation': '4.2.0',
                'can-queues': '1.3.1'
            }
        },
        {
            'name': 'can-simple-map',
            'version': '4.3.2',
            'fileUrl': './node_modules/can-simple-map/package.json',
            'main': 'can-simple-map',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-simple-map'
            },
            'resolutions': {
                'can-construct': '3.5.6',
                'can-event-queue': '1.1.7',
                'can-queues': '1.3.1',
                'can-observation-recorder': '1.3.1',
                'can-reflect': '1.18.0',
                'can-log': '1.0.2',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-assign',
            'version': '1.3.3',
            'fileUrl': './node_modules/can-assign/package.json',
            'main': 'can-assign',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-child-nodes',
            'version': '1.2.1',
            'fileUrl': './node_modules/can-child-nodes/package.json',
            'main': 'can-child-nodes',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-string',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-string/package.json',
            'main': 'can-string',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ]
            },
            'resolutions': {}
        },
        {
            'name': 'can-dom-mutate',
            'version': '1.3.11',
            'fileUrl': './node_modules/can-dom-mutate/package.json',
            'main': 'can-dom-mutate',
            'steal': { 'main': 'can-dom-mutate' },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-dom-mutate': '1.3.11',
                'can-globals': '1.2.2',
                'can-reflect': '1.18.0'
            }
        },
        {
            'name': 'can-dom-events',
            'version': '1.3.11',
            'fileUrl': './node_modules/can-dom-events/package.json',
            'main': 'can-dom-events',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-dom-events': '1.3.11',
                'can-globals': '1.2.2',
                'can-key-tree': '1.2.2',
                'can-reflect': '1.18.0'
            }
        },
        {
            'name': 'can-view-callbacks',
            'version': '4.4.1',
            'fileUrl': './node_modules/can-view-callbacks/package.json',
            'main': 'can-view-callbacks',
            'resolutions': {
                'can-observation-recorder': '1.3.1',
                'can-log': '1.0.2',
                'can-globals': '1.2.2',
                'can-dom-mutate': '1.3.11',
                'can-namespace': '1.0.0',
                'can-view-nodelist': '4.3.4',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-fragment': '1.3.1'
            }
        },
        {
            'name': 'can-view-model',
            'version': '4.0.3',
            'fileUrl': './node_modules/can-view-model/package.json',
            'main': 'can-view-model',
            'resolutions': {
                'can-simple-map': '4.3.2',
                'can-namespace': '1.0.0',
                'can-globals': '1.2.2',
                'can-reflect': '1.18.0',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-dom-data',
            'version': '1.0.3',
            'fileUrl': './node_modules/can-dom-data/package.json',
            'main': 'can-dom-data.js',
            'steal': {
                'npmIgnore': {
                    'steal-tools': true,
                    'testee': true
                },
                'main': 'can-dom-data'
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-globals',
            'version': '1.2.2',
            'fileUrl': './node_modules/can-globals/package.json',
            'main': 'can-globals.js',
            'resolutions': {
                'can-globals': '1.2.2',
                'can-namespace': '1.0.0',
                'can-reflect': '1.18.0'
            }
        },
        {
            'name': 'can-attribute-encoder',
            'version': '1.1.4',
            'fileUrl': './node_modules/can-attribute-encoder/package.json',
            'main': 'can-attribute-encoder',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-attribute-encoder'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-log': '1.0.2'
            }
        },
        {
            'name': 'can-observation',
            'version': '4.2.0',
            'fileUrl': './node_modules/can-observation/package.json',
            'main': 'can-observation',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-reflect': '1.18.0',
                'can-queues': '1.3.1',
                'can-observation-recorder': '1.3.1',
                'can-symbol': '1.6.5',
                'can-log': '1.0.2',
                'can-event-queue': '1.1.7',
                'can-observation': '4.2.0'
            }
        },
        {
            'name': 'can-diff',
            'version': '1.5.0',
            'fileUrl': './node_modules/can-diff/package.json',
            'main': 'can-diff',
            'steal': { 'main': 'can-diff' },
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-diff': '1.5.0',
                'can-key-tree': '1.2.2',
                'can-symbol': '1.6.5',
                'can-queues': '1.3.1'
            }
        },
        {
            'name': 'can-key-tree',
            'version': '1.2.2',
            'fileUrl': './node_modules/can-key-tree/package.json',
            'main': 'can-key-tree',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-key-tree'
            },
            'resolutions': { 'can-reflect': '1.18.0' }
        },
        {
            'name': 'can-control',
            'version': '4.4.3',
            'fileUrl': './node_modules/can-control/package.json',
            'main': 'can-control',
            'resolutions': {
                'can-construct': '3.5.6',
                'can-namespace': '1.0.0',
                'can-assign': '1.3.3',
                'can-stache-key': '1.4.3',
                'can-reflect': '1.18.0',
                'can-observation': '4.2.0',
                'can-event-queue': '1.1.7',
                'can-log': '1.0.2',
                'can-string': '1.1.0',
                'can-dom-mutate': '1.3.11',
                'can-symbol': '1.6.5',
                'can-key': '1.2.1'
            }
        },
        {
            'name': 'can-fragment',
            'version': '1.3.1',
            'fileUrl': './node_modules/can-fragment/package.json',
            'main': 'can-fragment',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-globals': '1.2.2',
                'can-namespace': '1.0.0',
                'can-reflect': '1.18.0',
                'can-child-nodes': '1.2.1',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-define-lazy-value',
            'version': '1.1.1',
            'fileUrl': './node_modules/can-define-lazy-value/package.json',
            'main': 'define-lazy-value',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {}
        },
        {
            'name': 'can-string-to-any',
            'version': '1.2.1',
            'fileUrl': './node_modules/can-string-to-any/package.json',
            'main': 'can-string-to-any',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-string-to-any'
            },
            'resolutions': {}
        },
        {
            'name': 'can-data-types',
            'version': '1.2.1',
            'fileUrl': './node_modules/can-data-types/package.json',
            'main': 'can-data-types',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-data-types'
            },
            'resolutions': { 'can-reflect': '1.18.0' }
        },
        {
            'name': 'can-import-module',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-import-module/package.json',
            'main': 'can-import-module.js',
            'resolutions': {
                'can-globals': '1.2.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-target',
            'version': '4.1.6',
            'fileUrl': './node_modules/can-view-target/package.json',
            'main': 'can-view-target',
            'resolutions': {
                'can-globals': '1.2.2',
                'can-dom-mutate': '1.3.11',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-reflect-dependencies',
            'version': '1.1.2',
            'fileUrl': './node_modules/can-reflect-dependencies/package.json',
            'main': 'can-reflect-dependencies.js',
            'resolutions': {
                'can-reflect-dependencies': '1.1.2',
                'can-reflect': '1.18.0',
                'can-symbol': '1.6.5',
                'can-assign': '1.3.3'
            }
        },
        {
            'name': 'can-single-reference',
            'version': '1.3.0',
            'fileUrl': './node_modules/can-single-reference/package.json',
            'main': 'can-single-reference',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-cid': '1.3.1' }
        },
        {
            'name': 'can-stache-key',
            'version': '1.4.3',
            'fileUrl': './node_modules/can-stache-key/package.json',
            'main': 'can-stache-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-stache-key'
            },
            'resolutions': {
                'can-observation-recorder': '1.3.1',
                'can-log': '1.0.2',
                'can-symbol': '1.6.5',
                'can-reflect': '1.18.0',
                'can-reflect-promise': '2.2.1'
            }
        },
        {
            'name': 'can-stache-helpers',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-stache-helpers/package.json',
            'main': 'can-stache-helpers',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-attribute-observable',
            'version': '1.2.7',
            'fileUrl': './node_modules/can-attribute-observable/package.json',
            'main': 'can-attribute-observable',
            'resolutions': {
                'can-queues': '1.3.1',
                'can-attribute-observable': '1.2.7',
                'can-reflect': '1.18.0',
                'can-observation': '4.2.0',
                'can-reflect-dependencies': '1.1.2',
                'can-observation-recorder': '1.3.1',
                'can-simple-observable': '2.5.0',
                'can-assign': '1.3.3',
                'can-symbol': '1.6.5',
                'can-dom-events': '1.3.11',
                'can-event-dom-radiochange': '2.2.1',
                'can-globals': '1.2.2',
                'can-dom-data': '1.0.3',
                'can-dom-mutate': '1.3.11',
                'can-diff': '1.5.0'
            }
        },
        {
            'name': 'can-view-import',
            'version': '4.2.2',
            'fileUrl': './node_modules/can-view-import/package.json',
            'main': 'can-view-import',
            'resolutions': {
                'can-assign': '1.3.3',
                'can-dom-data': '1.0.3',
                'can-symbol': '1.6.5',
                'can-globals': '1.2.2',
                'can-child-nodes': '1.2.1',
                'can-import-module': '1.2.0',
                'can-dom-mutate': '1.3.11',
                'can-view-nodelist': '4.3.4',
                'can-view-callbacks': '4.4.1',
                'can-log': '1.0.2'
            }
        },
        {
            'name': 'can-key',
            'version': '1.2.1',
            'fileUrl': './node_modules/can-key/package.json',
            'main': 'can-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-key'
            },
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-key': '1.2.1'
            }
        },
        {
            'name': 'can-cid',
            'version': '1.3.1',
            'fileUrl': './node_modules/can-cid/package.json',
            'main': 'can-cid',
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-view-live',
            'version': '4.2.8',
            'fileUrl': './node_modules/can-view-live/package.json',
            'main': 'can-view-live',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-live'
            },
            'resolutions': {
                'can-view-live': '4.2.8',
                'can-view-parser': '4.1.3',
                'can-dom-mutate': '1.3.11',
                'can-view-nodelist': '4.3.4',
                'can-fragment': '1.3.1',
                'can-child-nodes': '1.2.1',
                'can-reflect': '1.18.0',
                'can-reflect-dependencies': '1.1.2',
                'can-symbol': '1.6.5',
                'can-queues': '1.3.1',
                'can-attribute-observable': '1.2.7',
                'can-view-callbacks': '4.4.1',
                'can-simple-observable': '2.5.0',
                'can-diff': '1.5.0'
            }
        },
        {
            'name': 'can-join-uris',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-join-uris/package.json',
            'main': 'can-join-uris',
            'steal': {},
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-parse-uri': '1.2.2'
            }
        },
        {
            'name': 'can-reflect-promise',
            'version': '2.2.1',
            'fileUrl': './node_modules/can-reflect-promise/package.json',
            'main': 'can-reflect-promise',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-reflect': '1.18.0',
                'can-symbol': '1.6.5',
                'can-observation-recorder': '1.3.1',
                'can-queues': '1.3.1',
                'can-key-tree': '1.2.2',
                'can-log': '1.0.2'
            }
        },
        {
            'name': 'can-event-dom-radiochange',
            'version': '2.2.1',
            'fileUrl': './node_modules/can-event-dom-radiochange/package.json',
            'main': 'can-event-dom-radiochange',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-radiochange'
            },
            'resolutions': {
                'can-globals': '1.2.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-parse-uri',
            'version': '1.2.2',
            'fileUrl': './node_modules/can-parse-uri/package.json',
            'main': 'can-parse-uri',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-parse-uri'
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'lodash',
            'version': '4.17.20',
            'fileUrl': './node_modules/lodash/package.json',
            'main': 'lodash.js',
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.6.5#can-symbol*/
define('can-symbol@1.6.5#can-symbol', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var supportsNativeSymbols = function () {
            var symbolExists = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
            if (!symbolExists) {
                return false;
            }
            var symbol = Symbol('a symbol for testing symbols');
            return typeof symbol === 'symbol';
        }();
        var CanSymbol;
        if (supportsNativeSymbols) {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol('Symbol.' + name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'hasKey',
            'size',
            'getName',
            'getIdentity',
            'assignDeep',
            'updateDeep',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'updateValues',
            'addValue',
            'removeValues',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved',
            'onPatches'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect@1.18.0#reflections/helpers*/
define('can-reflect@1.18.0#reflections/helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        },
        hasLength: function (list) {
            var type = typeof list;
            if (type === 'string' || Array.isArray(list)) {
                return true;
            }
            var length = list && (type !== 'boolean' && type !== 'number' && 'length' in list) && list.length;
            return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
        }
    };
});
/*can-reflect@1.18.0#reflections/type/type*/
define('can-reflect@1.18.0#reflections/type/type', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = !!obj && obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    function isBuiltIn(obj) {
        if (isPrimitive(obj) || Array.isArray(obj) || isPlainObject(obj) || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1) {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), onPatchesSymbol = canSymbol.for('can.onPatches');
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        return helpers.hasLength(list);
    }
    var supportsNativeSymbols = function () {
        var symbolExists = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
        if (!symbolExists) {
            return false;
        }
        var symbol = Symbol('a symbol for testing symbols');
        return typeof symbol === 'symbol';
    }();
    var isSymbolLike;
    if (supportsNativeSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isPrimitive: isPrimitive,
        isBuiltIn: isBuiltIn,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            if (obj instanceof Array) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.18.0#reflections/call/call*/
define('can-reflect@1.18.0#reflections/call/call', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.18.0#reflections/get-set/get-set*/
define('can-reflect@1.18.0#reflections/get-set/get-set', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, removing, adding) {
            var howMany;
            if (typeof removing !== 'number') {
                var updateValues = obj[canSymbol.for('can.updateValues')];
                if (updateValues) {
                    return updateValues.call(obj, index, removing, adding);
                }
                howMany = removing.length;
            } else {
                howMany = removing;
            }
            if (arguments.length <= 3) {
                adding = [];
            }
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, adding);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(adding));
        },
        addValues: function (obj, adding, index) {
            var add = obj[canSymbol.for('can.addValues')];
            if (add) {
                return add.call(obj, adding, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                return obj.push.apply(obj, adding);
            }
            return reflections.splice(obj, index, [], adding);
        },
        removeValues: function (obj, removing, index) {
            var removeValues = obj[canSymbol.for('can.removeValues')];
            if (removeValues) {
                return removeValues.call(obj, removing, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                removing.forEach(function (item) {
                    var index = obj.indexOf(item);
                    if (index >= 0) {
                        obj.splice(index, 1);
                    }
                });
                return;
            }
            return reflections.splice(obj, index, removing, []);
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.18.0#reflections/observe/observe*/
define('can-reflect@1.18.0#reflections/observe/observe', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler, queueName) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler, queueName);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                var args = slice.call(arguments, 1);
                return method.apply(obj, args);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        getWhatIChange: makeErrorIfMissing('can.getWhatIChange', 'can-reflect: can not determine dependencies'),
        getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
            var fn = handler[canSymbol.for('can.getChangesDependencyRecord')];
            if (typeof fn === 'function') {
                return fn();
            }
        },
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onPatches: makeErrorIfMissing('can.onPatches', 'can-reflect: can not observe patches on object'),
        offPatches: makeErrorIfMissing('can.offPatches', 'can-reflect: can not unobserve patches on object'),
        onInstancePatches: makeErrorIfMissing('can.onInstancePatches', 'can-reflect: can not observe onInstancePatches on Type'),
        offInstancePatches: makeErrorIfMissing('can.offInstancePatches', 'can-reflect: can not unobserve onInstancePatches on Type'),
        onInstanceBoundChange: makeErrorIfMissing('can.onInstanceBoundChange', 'can-reflect: can not observe bound state change in instances.'),
        offInstanceBoundChange: makeErrorIfMissing('can.offInstanceBoundChange', 'can-reflect: can not unobserve bound state change'),
        isBound: makeErrorIfMissing('can.isBound', 'can-reflect: cannot determine if object is bound'),
        onEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback, queue);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback, queue);
                }
            }
        },
        offEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback, queue);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback, queue);
                }
            }
        },
        setPriority: function (obj, priority) {
            if (obj) {
                var setPriority = obj[canSymbol.for('can.setPriority')];
                if (setPriority !== undefined) {
                    setPriority.call(obj, priority);
                    return true;
                }
            }
            return false;
        },
        getPriority: function (obj) {
            if (obj) {
                var getPriority = obj[canSymbol.for('can.getPriority')];
                if (getPriority !== undefined) {
                    return getPriority.call(obj);
                }
            }
            return undefined;
        }
    };
});
/*can-reflect@1.18.0#reflections/shape/shape*/
define('can-reflect@1.18.0#reflections/shape/shape', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../get-set/get-set',
    '../type/type',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var getPrototypeOfWorksWithPrimitives = true;
    try {
        Object.getPrototypeOf(1);
    } catch (e) {
        getPrototypeOfWorksWithPrimitives = false;
    }
    var ArrayMap;
    if (typeof Map === 'function') {
        ArrayMap = Map;
    } else {
        var isEven = function isEven(num) {
            return num % 2 === 0;
        };
        ArrayMap = function () {
            this.contents = [];
        };
        ArrayMap.prototype = {
            _getIndex: function (key) {
                var idx;
                do {
                    idx = this.contents.indexOf(key, idx);
                } while (idx !== -1 && !isEven(idx));
                return idx;
            },
            has: function (key) {
                return this._getIndex(key) !== -1;
            },
            get: function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    return this.contents[idx + 1];
                }
            },
            set: function (key, value) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents[idx + 1] = value;
                } else {
                    this.contents.push(key);
                    this.contents.push(value);
                }
            },
            'delete': function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents.splice(idx, 2);
                }
            }
        };
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var shapeReflections;
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var sizeSymbol = canSymbol.for('can.size');
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    function isSerializedHelper(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return true;
        }
        if (hasUpdateSymbol(obj)) {
            return false;
        }
        return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj) && !typeReflections.isObservableLike(obj);
    }
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function createSerializeMap(Type) {
        var MapType = Type || ArrayMap;
        return {
            unwrap: new MapType(),
            serialize: new MapType(),
            isSerializing: {
                unwrap: new MapType(),
                serialize: new MapType()
            },
            circularReferenceIsSerializing: {
                unwrap: new MapType(),
                serialize: new MapType()
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        var serializeMap = null;
        function SerializeOperation(MapType) {
            this.first = !serializeMap;
            if (this.first) {
                serializeMap = createSerializeMap(MapType);
            }
            this.map = serializeMap;
            this.result = null;
        }
        SerializeOperation.prototype.end = function () {
            if (this.first) {
                serializeMap = null;
            }
            return this.result;
        };
        return function serializer(value, MapType) {
            if (isSerializedHelper(value)) {
                return value;
            }
            var operation = new SerializeOperation(MapType);
            if (typeReflections.isValueLike(value)) {
                operation.result = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                operation.result = isListLike ? [] : {};
                if (operation.map[methodName].has(value)) {
                    if (operation.map.isSerializing[methodName].has(value)) {
                        operation.map.circularReferenceIsSerializing[methodName].set(value, true);
                    }
                    return operation.map[methodName].get(value);
                } else {
                    operation.map[methodName].set(value, operation.result);
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        operation.map.isSerializing[methodName].set(value, true);
                        var oldResult = operation.result;
                        operation.result = serializer.call(value, oldResult);
                        operation.map.isSerializing[methodName].delete(value);
                        if (operation.result !== oldResult) {
                            if (operation.map.circularReferenceIsSerializing[methodName].has(value)) {
                                operation.end();
                                throw new Error('Cannot serialize cirular reference!');
                            }
                            operation.map[methodName].set(value, operation.result);
                        }
                        return operation.end();
                    }
                }
                if (typeof obj === 'function') {
                    operation.map[methodName].set(value, value);
                    operation.result = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        operation.result[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        operation.result[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            return operation.end();
        };
    }
    var makeMap;
    if (typeof Map !== 'undefined') {
        makeMap = function (keys) {
            var map = new Map();
            shapeReflections.eachIndex(keys, function (key) {
                map.set(key, true);
            });
            return map;
        };
    } else {
        makeMap = function (keys) {
            var map = {};
            keys.forEach(function (key) {
                map[key] = true;
            });
            return {
                get: function (key) {
                    return map[key];
                },
                set: function (key, value) {
                    map[key] = value;
                },
                keys: function () {
                    return keys;
                }
            };
        };
    }
    var fastHasOwnKey = function (obj) {
        var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
        if (hasOwnKey) {
            return hasOwnKey.bind(obj);
        } else {
            var map = makeMap(shapeReflections.getOwnEnumerableKeys(obj));
            return function (key) {
                return map.get(key);
            };
        }
    };
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: target.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                if (isAssign === true) {
                    this.assignDeep(curVal, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return shapeReflections.eachIndex(obj, callback, context);
            } else {
                return shapeReflections.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return shapeReflections.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    shapeReflections.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            if (length === undefined) {
                var size = list[sizeSymbol];
                if (size) {
                    length = size.call(list);
                } else {
                    throw new Error('can-reflect: unable to iterate.');
                }
            }
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            shapeReflections.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return shapeReflections.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                shapeReflections.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return hasOwnProperty.call(obj, key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                shapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function (key) {
                    var descriptor = shapeReflections.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (value, key) {
                if (!hasOwnKey(key) || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, inserting, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignList(target, source);
            } else {
                shapeReflections.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (newVal, key) {
                if (!hasOwnKey(key)) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        shapeReflections.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignDeepList(target, source);
            } else {
                shapeReflections.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, target, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateList(target, source);
            } else {
                shapeReflections.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    shapeReflections.updateDeep(curVal, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateDeepList(target, source);
            } else {
                shapeReflections.updateDeepMap(target, source);
            }
            return target;
        },
        hasKey: function (obj, key) {
            if (obj == null) {
                return false;
            }
            if (typeReflections.isPrimitive(obj)) {
                if (hasOwnProperty.call(obj, key)) {
                    return true;
                } else {
                    var proto;
                    if (getPrototypeOfWorksWithPrimitives) {
                        proto = Object.getPrototypeOf(obj);
                    } else {
                        proto = obj.__proto__;
                    }
                    if (proto !== undefined) {
                        return key in proto;
                    } else {
                        return obj[key] !== undefined;
                    }
                }
            }
            var hasKey = obj[canSymbol.for('can.hasKey')];
            if (hasKey) {
                return hasKey.call(obj, key);
            }
            var found = shapeReflections.hasOwnKey(obj, key);
            return found || key in obj;
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            shapeReflections.eachKey(source, function (value, key) {
                var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
                getSetReflections.setKeyValue(target, symbol, value);
            });
            return target;
        },
        isSerialized: isSerializedHelper,
        size: function (obj) {
            if (obj == null) {
                return 0;
            }
            var size = obj[sizeSymbol];
            var count = 0;
            if (size) {
                return size.call(obj);
            } else if (helpers.hasLength(obj)) {
                return obj.length;
            } else if (typeReflections.isListLike(obj)) {
                shapeReflections.eachIndex(obj, function () {
                    count++;
                });
                return count;
            } else if (obj) {
                return shapeReflections.getOwnEnumerableKeys(obj).length;
            } else {
                return undefined;
            }
        },
        defineInstanceKey: function (cls, key, properties) {
            var defineInstanceKey = cls[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                return defineInstanceKey.call(cls, key, properties);
            }
            var proto = cls.prototype;
            defineInstanceKey = proto[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                defineInstanceKey.call(proto, key, properties);
            } else {
                Object.defineProperty(proto, key, shapeReflections.assign({
                    configurable: true,
                    enumerable: !typeReflections.isSymbolLike(key),
                    writable: true
                }, properties));
            }
        }
    };
    shapeReflections.isSerializable = shapeReflections.isSerialized;
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.18.0#reflections/shape/schema/schema*/
define('can-reflect@1.18.0#reflections/shape/schema/schema', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../../type/type',
    '../../get-set/get-set',
    '../shape'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../../type/type');
    var getSetReflections = require('../../get-set/get-set');
    var shapeReflections = require('../shape');
    var getSchemaSymbol = canSymbol.for('can.getSchema'), isMemberSymbol = canSymbol.for('can.isMember'), newSymbol = canSymbol.for('can.new');
    function comparator(a, b) {
        return a.localeCompare(b);
    }
    function sort(obj) {
        if (typeReflections.isPrimitive(obj) || obj instanceof Date) {
            return obj;
        }
        var out;
        if (typeReflections.isListLike(obj)) {
            out = [];
            shapeReflections.eachKey(obj, function (item) {
                out.push(sort(item));
            });
            return out;
        }
        if (typeReflections.isMapLike(obj)) {
            out = {};
            shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {
                out[key] = sort(getSetReflections.getKeyValue(obj, key));
            });
            return out;
        }
        return obj;
    }
    function isPrimitiveConverter(Type) {
        return Type === Number || Type === String || Type === Boolean;
    }
    var schemaReflections = {
        getSchema: function (type) {
            if (type === undefined) {
                return undefined;
            }
            var getSchema = type[getSchemaSymbol];
            if (getSchema === undefined) {
                type = type.constructor;
                getSchema = type && type[getSchemaSymbol];
            }
            return getSchema !== undefined ? getSchema.call(type) : undefined;
        },
        getIdentity: function (value, schema) {
            schema = schema || schemaReflections.getSchema(value);
            if (schema === undefined) {
                throw new Error('can-reflect.getIdentity - Unable to find a schema for the given value.');
            }
            var identity = schema.identity;
            if (!identity || identity.length === 0) {
                throw new Error('can-reflect.getIdentity - Provided schema lacks an identity property.');
            } else if (identity.length === 1) {
                return getSetReflections.getKeyValue(value, identity[0]);
            } else {
                var id = {};
                identity.forEach(function (key) {
                    id[key] = getSetReflections.getKeyValue(value, key);
                });
                return JSON.stringify(schemaReflections.cloneKeySort(id));
            }
        },
        cloneKeySort: function (obj) {
            return sort(obj);
        },
        convert: function (value, Type) {
            if (isPrimitiveConverter(Type)) {
                return Type(value);
            }
            var isMemberTest = Type[isMemberSymbol], isMember = false, type = typeof Type, createNew = Type[newSymbol];
            if (isMemberTest !== undefined) {
                isMember = isMemberTest.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    isMember = value instanceof Type;
                }
            }
            if (isMember) {
                return value;
            }
            if (createNew !== undefined) {
                return createNew.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    return new Type(value);
                } else {
                    return Type(value);
                }
            } else {
                throw new Error('can-reflect: Can not convert values into type. Type must provide `can.new` symbol.');
            }
        }
    };
    module.exports = schemaReflections;
});
/*can-reflect@1.18.0#reflections/get-name/get-name*/
define('can-reflect@1.18.0#reflections/get-name/get-name', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var getNameSymbol = canSymbol.for('can.getName');
    function setName(obj, nameGetter) {
        if (typeof nameGetter !== 'function') {
            var value = nameGetter;
            nameGetter = function () {
                return value;
            };
        }
        Object.defineProperty(obj, getNameSymbol, { value: nameGetter });
    }
    var anonymousID = 0;
    function getName(obj) {
        var type = typeof obj;
        if (obj === null || type !== 'object' && type !== 'function') {
            return '' + obj;
        }
        var nameGetter = obj[getNameSymbol];
        if (nameGetter) {
            return nameGetter.call(obj);
        }
        if (type === 'function') {
            if (!('name' in obj)) {
                obj.name = 'functionIE' + anonymousID++;
            }
            return obj.name;
        }
        if (obj.constructor && obj !== obj.constructor) {
            var parent = getName(obj.constructor);
            if (parent) {
                if (typeReflections.isValueLike(obj)) {
                    return parent + '<>';
                }
                if (typeReflections.isMoreListLikeThanMapLike(obj)) {
                    return parent + '[]';
                }
                if (typeReflections.isMapLike(obj)) {
                    return parent + '{}';
                }
            }
        }
        return undefined;
    }
    module.exports = {
        setName: setName,
        getName: getName
    };
});
/*can-reflect@1.18.0#types/map*/
define('can-reflect@1.18.0#types/map', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    function keysPolyfill() {
        var keys = [];
        var currentIndex = 0;
        this.forEach(function (val, key) {
            keys.push(key);
        });
        return {
            next: function () {
                return {
                    value: keys[currentIndex],
                    done: currentIndex++ === keys.length
                };
            }
        };
    }
    if (typeof Map !== 'undefined') {
        shape.assignSymbols(Map.prototype, {
            'can.getOwnEnumerableKeys': Map.prototype.keys,
            'can.setKeyValue': Map.prototype.set,
            'can.getKeyValue': Map.prototype.get,
            'can.deleteKeyValue': Map.prototype['delete'],
            'can.hasOwnKey': Map.prototype.has
        });
        if (typeof Map.prototype.keys !== 'function') {
            Map.prototype.keys = Map.prototype[CanSymbol.for('can.getOwnEnumerableKeys')] = keysPolyfill;
        }
    }
    if (typeof WeakMap !== 'undefined') {
        shape.assignSymbols(WeakMap.prototype, {
            'can.getOwnEnumerableKeys': function () {
                throw new Error('can-reflect: WeakMaps do not have enumerable keys.');
            },
            'can.setKeyValue': WeakMap.prototype.set,
            'can.getKeyValue': WeakMap.prototype.get,
            'can.deleteKeyValue': WeakMap.prototype['delete'],
            'can.hasOwnKey': WeakMap.prototype.has
        });
    }
});
/*can-reflect@1.18.0#types/set*/
define('can-reflect@1.18.0#types/set', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    if (typeof Set !== 'undefined') {
        shape.assignSymbols(Set.prototype, {
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                return this.size;
            }
        });
        if (typeof Set.prototype[CanSymbol.iterator] !== 'function') {
            Set.prototype[CanSymbol.iterator] = function () {
                var arr = [];
                var currentIndex = 0;
                this.forEach(function (val) {
                    arr.push(val);
                });
                return {
                    next: function () {
                        return {
                            value: arr[currentIndex],
                            done: currentIndex++ === arr.length
                        };
                    }
                };
            };
        }
    }
    if (typeof WeakSet !== 'undefined') {
        shape.assignSymbols(WeakSet.prototype, {
            'can.isListLike': true,
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                throw new Error('can-reflect: WeakSets do not have enumerable keys.');
            }
        });
    }
});
/*can-reflect@1.18.0#can-reflect*/
define('can-reflect@1.18.0#can-reflect', [
    'require',
    'exports',
    'module',
    './reflections/call/call',
    './reflections/get-set/get-set',
    './reflections/observe/observe',
    './reflections/shape/shape',
    './reflections/shape/schema/schema',
    './reflections/type/type',
    './reflections/get-name/get-name',
    'can-namespace',
    './types/map',
    './types/set'
], function (require, exports, module) {
    'use strict';
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var schema = require('./reflections/shape/schema/schema');
    var type = require('./reflections/type/type');
    var getName = require('./reflections/get-name/get-name');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type,
        getName,
        schema
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    require('./types/map');
    require('./types/set');
    module.exports = namespace.Reflect = reflect;
});
/*can-log@1.0.2#can-log*/
define('can-log@1.0.2#can-log', function (require, exports, module) {
    'use strict';
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function () {
        var ll = this.logLevel;
        if (ll < 2) {
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.log = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.error = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                this._logger('error', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-log@1.0.2#dev/dev*/
define('can-log@1.0.2#dev/dev', [
    'require',
    'exports',
    'module',
    '../can-log'
], function (require, exports, module) {
    'use strict';
    var canLog = require('../can-log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        stringify: function (value) {
            var flagUndefined = function flagUndefined(key, value) {
                return value === undefined ? '/* void(undefined) */' : value;
            };
            return JSON.stringify(value, flagUndefined, '  ').replace(/"\/\* void\(undefined\) \*\/"/g, 'undefined');
        },
        warn: function () {
        },
        log: function () {
        },
        error: function () {
        },
        _logger: canLog._logger
    };
});
/*can-string@1.1.0#can-string*/
define('can-string@1.1.0#can-string', function (require, exports, module) {
    'use strict';
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        capitalize: function (s) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        pascalize: function (str) {
            return string.capitalize(string.camelize(str));
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        undHash: strUndHash
    };
    module.exports = string;
});
/*can-construct@3.5.6#can-construct*/
define('can-construct@3.5.6#can-construct', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-log/dev/dev',
    'can-namespace',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var namespace = require('can-namespace');
    var canSymbol = require('can-symbol');
    var inSetupSymbol = canSymbol.for('can.initializing');
    var initializing = 0;
    var Construct = function () {
        if (arguments.length) {
            return Construct.extend.apply(Construct, arguments);
        }
    };
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        }, defineNonEnumerable = function (obj, prop, value) {
            Object.defineProperty(obj, prop, {
                configurable: true,
                writable: true,
                enumerable: false,
                value: value
            });
        };
    canReflect.assignMap(Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                Object.defineProperty(inst, '__inSetup', {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                Object.defineProperty(inst, inSetupSymbol, {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                args = inst.setup.apply(inst, arguments);
                if (args instanceof Construct.ReturnValue) {
                    return args.value;
                }
                inst.__inSetup = false;
                inst[inSetupSymbol] = false;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            Object.defineProperty(what, propName, {
                value: val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        },
        setup: function (base) {
            var defaults = base.defaults ? canReflect.serialize(base.defaults) : {};
            this.defaults = canReflect.assignDeepMap(defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var shortName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof shortName !== 'string') {
                proto = klass;
                klass = shortName;
                shortName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, prototype;
            prototype = this.instance();
            Construct._inherit(proto, _super, prototype);
            if (shortName) {
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            function init() {
                if (!initializing) {
                    return (!this || this.constructor !== Constructor) && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            Constructor = typeof namedCtor === 'function' ? namedCtor(constructorName, init) : function () {
                return init.apply(this, arguments);
            };
            for (var propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            Construct._inherit(klass, _super_class, Constructor);
            canReflect.assignMap(Constructor, {
                constructor: Constructor,
                prototype: prototype
            });
            if (shortName !== undefined) {
                if (Object.getOwnPropertyDescriptor) {
                    var desc = Object.getOwnPropertyDescriptor(Constructor, 'name');
                    if (!desc || desc.configurable) {
                        Object.defineProperty(Constructor, 'name', {
                            writable: true,
                            value: shortName,
                            configurable: true
                        });
                    }
                }
                Constructor.shortName = shortName;
            }
            defineNonEnumerable(Constructor.prototype, 'constructor', Constructor);
            var t = [_super_class].concat(Array.prototype.slice.call(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        },
        ReturnValue: function (value) {
            this.value = value;
        }
    });
    defineNonEnumerable(Construct.prototype, 'setup', function () {
    });
    defineNonEnumerable(Construct.prototype, 'init', function () {
    });
    module.exports = namespace.Construct = Construct;
});
/*can-queues@1.3.1#queue-state*/
define('can-queues@1.3.1#queue-state', function (require, exports, module) {
    'use strict';
    module.exports = { lastTask: null };
});
/*can-assign@1.3.3#can-assign*/
define('can-assign@1.3.3#can-assign', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    module.exports = namespace.assign = function (d, s) {
        for (var prop in s) {
            var desc = Object.getOwnPropertyDescriptor(d, prop);
            if (!desc || desc.writable !== false) {
                d[prop] = s[prop];
            }
        }
        return d;
    };
});
/*can-queues@1.3.1#queue*/
define('can-queues@1.3.1#queue', [
    'require',
    'exports',
    'module',
    './queue-state',
    'can-log/dev/dev',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var queueState = require('./queue-state');
    var canDev = require('can-log/dev/dev');
    var assign = require('can-assign');
    function noOperation() {
    }
    var Queue = function (name, callbacks) {
        this.callbacks = assign({
            onFirstTask: noOperation,
            onComplete: function () {
                queueState.lastTask = null;
            }
        }, callbacks || {});
        this.name = name;
        this.index = 0;
        this.tasks = [];
        this._log = false;
    };
    Queue.prototype.constructor = Queue;
    Queue.noop = noOperation;
    Queue.prototype.enqueue = function (fn, context, args, meta) {
        var len = this.tasks.push({
            fn: fn,
            context: context,
            args: args,
            meta: meta || {}
        });
        if (len === 1) {
            this.callbacks.onFirstTask(this);
        }
    };
    Queue.prototype.flush = function () {
        while (this.index < this.tasks.length) {
            var task = this.tasks[this.index++];
            task.fn.apply(task.context, task.args);
        }
        this.index = 0;
        this.tasks = [];
        this.callbacks.onComplete(this);
    };
    Queue.prototype.log = function () {
        this._log = arguments.length ? arguments[0] : true;
    };
    module.exports = Queue;
});
/*can-queues@1.3.1#priority-queue*/
define('can-queues@1.3.1#priority-queue', [
    'require',
    'exports',
    'module',
    './queue'
], function (require, exports, module) {
    'use strict';
    var Queue = require('./queue');
    var PriorityQueue = function () {
        Queue.apply(this, arguments);
        this.taskMap = new Map();
        this.taskContainersByPriority = [];
        this.curPriorityIndex = Infinity;
        this.curPriorityMax = 0;
        this.isFlushing = false;
        this.tasksRemaining = 0;
    };
    PriorityQueue.prototype = Object.create(Queue.prototype);
    PriorityQueue.prototype.constructor = PriorityQueue;
    PriorityQueue.prototype.enqueue = function (fn, context, args, meta) {
        if (!this.taskMap.has(fn)) {
            this.tasksRemaining++;
            var isFirst = this.taskContainersByPriority.length === 0;
            var task = {
                fn: fn,
                context: context,
                args: args,
                meta: meta || {}
            };
            var taskContainer = this.getTaskContainerAndUpdateRange(task);
            taskContainer.tasks.push(task);
            this.taskMap.set(fn, task);
            if (isFirst) {
                this.callbacks.onFirstTask(this);
            }
        }
    };
    PriorityQueue.prototype.getTaskContainerAndUpdateRange = function (task) {
        var priority = task.meta.priority || 0;
        if (priority < this.curPriorityIndex) {
            this.curPriorityIndex = priority;
        }
        if (priority > this.curPriorityMax) {
            this.curPriorityMax = priority;
        }
        var tcByPriority = this.taskContainersByPriority;
        var taskContainer = tcByPriority[priority];
        if (!taskContainer) {
            taskContainer = tcByPriority[priority] = {
                tasks: [],
                index: 0
            };
        }
        return taskContainer;
    };
    PriorityQueue.prototype.flush = function () {
        if (this.isFlushing) {
            return;
        }
        this.isFlushing = true;
        while (true) {
            if (this.curPriorityIndex <= this.curPriorityMax) {
                var taskContainer = this.taskContainersByPriority[this.curPriorityIndex];
                if (taskContainer && taskContainer.tasks.length > taskContainer.index) {
                    var task = taskContainer.tasks[taskContainer.index++];
                    this.tasksRemaining--;
                    this.taskMap['delete'](task.fn);
                    task.fn.apply(task.context, task.args);
                } else {
                    this.curPriorityIndex++;
                }
            } else {
                this.taskMap = new Map();
                this.curPriorityIndex = Infinity;
                this.curPriorityMax = 0;
                this.taskContainersByPriority = [];
                this.isFlushing = false;
                this.callbacks.onComplete(this);
                return;
            }
        }
    };
    PriorityQueue.prototype.isEnqueued = function (fn) {
        return this.taskMap.has(fn);
    };
    PriorityQueue.prototype.flushQueuedTask = function (fn) {
        var task = this.dequeue(fn);
        if (task) {
            task.fn.apply(task.context, task.args);
        }
    };
    PriorityQueue.prototype.dequeue = function (fn) {
        var task = this.taskMap.get(fn);
        if (task) {
            var priority = task.meta.priority || 0;
            var taskContainer = this.taskContainersByPriority[priority];
            var index = taskContainer.tasks.indexOf(task, taskContainer.index);
            if (index >= 0) {
                taskContainer.tasks.splice(index, 1);
                this.tasksRemaining--;
                this.taskMap['delete'](task.fn);
                return task;
            } else {
                console.warn('Task', fn, 'has already run');
            }
        }
    };
    PriorityQueue.prototype.tasksRemainingCount = function () {
        return this.tasksRemaining;
    };
    module.exports = PriorityQueue;
});
/*can-queues@1.3.1#completion-queue*/
define('can-queues@1.3.1#completion-queue', [
    'require',
    'exports',
    'module',
    './queue'
], function (require, exports, module) {
    'use strict';
    var Queue = require('./queue');
    var CompletionQueue = function () {
        Queue.apply(this, arguments);
        this.flushCount = 0;
    };
    CompletionQueue.prototype = Object.create(Queue.prototype);
    CompletionQueue.prototype.constructor = CompletionQueue;
    CompletionQueue.prototype.flush = function () {
        if (this.flushCount === 0) {
            this.flushCount++;
            while (this.index < this.tasks.length) {
                var task = this.tasks[this.index++];
                task.fn.apply(task.context, task.args);
            }
            this.index = 0;
            this.tasks = [];
            this.flushCount--;
            this.callbacks.onComplete(this);
        }
    };
    module.exports = CompletionQueue;
});
/*can-queues@1.3.1#sorted-index-by*/
define('can-queues@1.3.1#sorted-index-by', function (require, exports, module) {
    module.exports = function (compare, array, value) {
        if (!array || !array.length) {
            return undefined;
        }
        if (compare(value, array[0]) === -1) {
            return 0;
        } else if (compare(value, array[array.length - 1]) === 1) {
            return array.length;
        }
        var low = 0, high = array.length;
        while (low < high) {
            var mid = low + high >>> 1, item = array[mid], computed = compare(value, item);
            if (computed === -1) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high;
    };
});
/*can-queues@1.3.1#element-sort*/
define('can-queues@1.3.1#element-sort', function (require, exports, module) {
    var hasDuplicate, sortInput, sortStable = true, indexOf = Array.prototype.indexOf;
    function sortOrder(a, b) {
        if (a === b) {
            hasDuplicate = true;
            return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
            return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1) {
            if (a === document || a.ownerDocument === document && document.documentElement.contains(a)) {
                return -1;
            }
            if (b === document || b.ownerDocument === document && document.documentElement.contains(b)) {
                return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
    }
    function uniqueSort(results) {
        var elem, duplicates = [], j = 0, i = 0;
        hasDuplicate = false;
        sortInput = !sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
            while (elem = results[i++]) {
                if (elem === results[i]) {
                    j = duplicates.push(i);
                }
            }
            while (j--) {
                results.splice(duplicates[j], 1);
            }
        }
        sortInput = null;
        return results;
    }
    module.exports = {
        uniqueSort: uniqueSort,
        sortOrder: sortOrder
    };
});
/*can-queues@1.3.1#dom-order-queue*/
define('can-queues@1.3.1#dom-order-queue', [
    'require',
    'exports',
    'module',
    './queue',
    './sorted-index-by',
    './element-sort',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var Queue = require('./queue');
    var sortedIndexBy = require('./sorted-index-by');
    var elementSort = require('./element-sort');
    var canSymbol = require('can-symbol');
    var canElementSymbol = canSymbol.for('can.element');
    function sortTasks(taskA, taskB) {
        return elementSort.sortOrder(taskA.meta.element, taskB.meta.element);
    }
    var DomOrderQueue = function () {
        Queue.apply(this, arguments);
        this.taskMap = new Map();
        this.unsortable = [];
        this.isFlushing = false;
    };
    DomOrderQueue.prototype = Object.create(Queue.prototype);
    DomOrderQueue.prototype.constructor = DomOrderQueue;
    DomOrderQueue.prototype.enqueue = function (fn, context, args, meta) {
        var task;
        if (!this.taskMap.has(fn)) {
            if (!meta) {
                meta = {};
            }
            if (!meta.element) {
                meta.element = fn[canElementSymbol];
            }
            task = {
                fn: fn,
                context: context,
                args: args,
                meta: meta
            };
            this.taskMap.set(fn, task);
            var index = sortedIndexBy(sortTasks, this.tasks, task);
            this.tasks.splice(index, 0, task);
            if (this.tasks.length === 1) {
                this.callbacks.onFirstTask(this);
            }
        } else {
            task = this.taskMap.get(fn);
            task.context = context;
            task.args = args;
            if (!meta) {
                meta = {};
            }
            if (!meta.element) {
                meta.element = fn[canElementSymbol];
            }
            task.meta = meta;
        }
    };
    DomOrderQueue.prototype.flush = function () {
        if (this.isFlushing) {
            return;
        }
        this.isFlushing = true;
        while (this.tasks.length) {
            var task = this.tasks.shift();
            this.taskMap['delete'](task.fn);
            task.fn.apply(task.context, task.args);
        }
        this.isFlushing = false;
        this.callbacks.onComplete(this);
    };
    DomOrderQueue.prototype.isEnqueued = function (fn) {
        return this.taskMap.has(fn);
    };
    DomOrderQueue.prototype.flushQueuedTask = function (fn) {
        var task = this.dequeue(fn);
        if (task) {
            task.fn.apply(task.context, task.args);
        }
    };
    DomOrderQueue.prototype.dequeue = function (fn) {
        var task = this.taskMap.get(fn);
        if (task) {
            var index = this.tasks.indexOf(task);
            if (index >= 0) {
                this.tasks.splice(index, 1);
                this.taskMap['delete'](task.fn);
                return task;
            } else {
                console.warn('Task', fn, 'has already run');
            }
        }
    };
    DomOrderQueue.prototype.tasksRemainingCount = function () {
        return this.tasks.length;
    };
    module.exports = DomOrderQueue;
});
/*can-queues@1.3.1#can-queues*/
define('can-queues@1.3.1#can-queues', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    './queue',
    './priority-queue',
    './queue-state',
    './completion-queue',
    './dom-order-queue',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var canDev = require('can-log/dev/dev');
    var Queue = require('./queue');
    var PriorityQueue = require('./priority-queue');
    var queueState = require('./queue-state');
    var CompletionQueue = require('./completion-queue');
    var DomOrderQueue = require('./dom-order-queue');
    var ns = require('can-namespace');
    var batchStartCounter = 0;
    var addedTask = false;
    var isFlushing = false;
    var batchNum = 0;
    var batchData;
    var queueNames = [
        'notify',
        'derive',
        'domUI',
        'dom',
        'mutate'
    ];
    var NOTIFY_QUEUE, DERIVE_QUEUE, DOM_UI_QUEUE, DOM_QUEUE, MUTATE_QUEUE;
    NOTIFY_QUEUE = new Queue('NOTIFY', {
        onComplete: function () {
            DERIVE_QUEUE.flush();
        },
        onFirstTask: function () {
            if (!batchStartCounter) {
                NOTIFY_QUEUE.flush();
            } else {
                addedTask = true;
            }
        }
    });
    DERIVE_QUEUE = new PriorityQueue('DERIVE', {
        onComplete: function () {
            DOM_QUEUE.flush();
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    DOM_QUEUE = new DomOrderQueue('DOM   ', {
        onComplete: function () {
            DOM_UI_QUEUE.flush();
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    DOM_UI_QUEUE = new CompletionQueue('DOM_UI', {
        onComplete: function () {
            MUTATE_QUEUE.flush();
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    MUTATE_QUEUE = new Queue('MUTATE', {
        onComplete: function () {
            queueState.lastTask = null;
            isFlushing = false;
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    var queues = {
        Queue: Queue,
        PriorityQueue: PriorityQueue,
        CompletionQueue: CompletionQueue,
        DomOrderQueue: DomOrderQueue,
        notifyQueue: NOTIFY_QUEUE,
        deriveQueue: DERIVE_QUEUE,
        domQueue: DOM_QUEUE,
        domUIQueue: DOM_UI_QUEUE,
        mutateQueue: MUTATE_QUEUE,
        batch: {
            start: function () {
                batchStartCounter++;
                if (batchStartCounter === 1) {
                    batchNum++;
                    batchData = { number: batchNum };
                }
            },
            stop: function () {
                batchStartCounter--;
                if (batchStartCounter === 0) {
                    if (addedTask) {
                        addedTask = false;
                        isFlushing = true;
                        NOTIFY_QUEUE.flush();
                    }
                }
            },
            isCollecting: function () {
                return batchStartCounter > 0;
            },
            number: function () {
                return batchNum;
            },
            data: function () {
                return batchData;
            }
        },
        runAsTask: function (fn, reasonLog) {
            return fn;
        },
        enqueueByQueue: function enqueueByQueue(fnByQueue, context, args, makeMeta, reasonLog) {
            if (fnByQueue) {
                queues.batch.start();
                queueNames.forEach(function (queueName) {
                    var name = queueName + 'Queue';
                    var QUEUE = queues[name];
                    var tasks = fnByQueue[queueName];
                    if (tasks !== undefined) {
                        tasks.forEach(function (fn) {
                            var meta = makeMeta != null ? makeMeta(fn, context, args) : {};
                            meta.reasonLog = reasonLog;
                            QUEUE.enqueue(fn, context, args, meta);
                        });
                    }
                });
                queues.batch.stop();
            }
        },
        lastTask: function () {
            return queueState.lastTask;
        },
        stack: function (task) {
            var current = task || queueState.lastTask;
            var stack = [];
            while (current) {
                stack.unshift(current);
                current = current.meta.parentTask;
            }
            return stack;
        },
        logStack: function (task) {
            var stack = this.stack(task);
            stack.forEach(function (task, i) {
                var meta = task.meta;
                if (i === 0 && meta && meta.reasonLog) {
                    canDev.log.apply(canDev, meta.reasonLog);
                }
                var log = meta && meta.log ? meta.log : [
                    task.fn.name,
                    task
                ];
                canDev.log.apply(canDev, [task.meta.stack.name + ' ran task:'].concat(log));
            });
        },
        taskCount: function () {
            return NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;
        },
        flush: function () {
            NOTIFY_QUEUE.flush();
        },
        log: function () {
            NOTIFY_QUEUE.log.apply(NOTIFY_QUEUE, arguments);
            DERIVE_QUEUE.log.apply(DERIVE_QUEUE, arguments);
            DOM_UI_QUEUE.log.apply(DOM_UI_QUEUE, arguments);
            DOM_QUEUE.log.apply(DOM_QUEUE, arguments);
            MUTATE_QUEUE.log.apply(MUTATE_QUEUE, arguments);
        }
    };
    if (ns.queues) {
        throw new Error('You can\'t have two versions of can-queues, check your dependencies');
    } else {
        module.exports = ns.queues = queues;
    }
});
/*can-observation-recorder@1.3.1#can-observation-recorder*/
define('can-observation-recorder@1.3.1#can-observation-recorder', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var canSymbol = require('can-symbol');
    var stack = [];
    var addParentSymbol = canSymbol.for('can.addParent'), getValueSymbol = canSymbol.for('can.getValue');
    var ObservationRecorder = {
        stack: stack,
        start: function (name) {
            var deps = {
                keyDependencies: new Map(),
                valueDependencies: new Set(),
                childDependencies: new Set(),
                traps: null,
                ignore: 0,
                name: name
            };
            stack.push(deps);
            return deps;
        },
        stop: function () {
            return stack.pop();
        },
        add: function (obj, event) {
            var top = stack[stack.length - 1];
            if (top && top.ignore === 0) {
                if (top.traps) {
                    top.traps.push([
                        obj,
                        event
                    ]);
                } else {
                    if (event === undefined) {
                        top.valueDependencies.add(obj);
                    } else {
                        var eventSet = top.keyDependencies.get(obj);
                        if (!eventSet) {
                            eventSet = new Set();
                            top.keyDependencies.set(obj, eventSet);
                        }
                        eventSet.add(event);
                    }
                }
            }
        },
        addMany: function (observes) {
            var top = stack[stack.length - 1];
            if (top) {
                if (top.traps) {
                    top.traps.push.apply(top.traps, observes);
                } else {
                    for (var i = 0, len = observes.length; i < len; i++) {
                        this.add(observes[i][0], observes[i][1]);
                    }
                }
            }
        },
        created: function (obs) {
            var top = stack[stack.length - 1];
            if (top) {
                top.childDependencies.add(obs);
                if (obs[addParentSymbol]) {
                    obs[addParentSymbol](top);
                }
            }
        },
        ignore: function (fn) {
            return function () {
                if (stack.length) {
                    var top = stack[stack.length - 1];
                    top.ignore++;
                    var res = fn.apply(this, arguments);
                    top.ignore--;
                    return res;
                } else {
                    return fn.apply(this, arguments);
                }
            };
        },
        peekValue: function (value) {
            if (!value || !value[getValueSymbol]) {
                return value;
            }
            if (stack.length) {
                var top = stack[stack.length - 1];
                top.ignore++;
                var res = value[getValueSymbol]();
                top.ignore--;
                return res;
            } else {
                return value[getValueSymbol]();
            }
        },
        isRecording: function () {
            var len = stack.length;
            var last = len && stack[len - 1];
            return last && last.ignore === 0 && last;
        },
        makeDependenciesRecord: function (name) {
            return {
                traps: null,
                keyDependencies: new Map(),
                valueDependencies: new Set(),
                ignore: 0,
                name: name
            };
        },
        makeDependenciesRecorder: function () {
            return ObservationRecorder.makeDependenciesRecord();
        },
        trap: function () {
            if (stack.length) {
                var top = stack[stack.length - 1];
                var oldTraps = top.traps;
                var traps = top.traps = [];
                return function () {
                    top.traps = oldTraps;
                    return traps;
                };
            } else {
                return function () {
                    return [];
                };
            }
        },
        trapsCount: function () {
            if (stack.length) {
                var top = stack[stack.length - 1];
                return top.traps.length;
            } else {
                return 0;
            }
        }
    };
    if (namespace.ObservationRecorder) {
        throw new Error('You can\'t have two versions of can-observation-recorder, check your dependencies');
    } else {
        module.exports = namespace.ObservationRecorder = ObservationRecorder;
    }
});
/*can-key-tree@1.2.2#can-key-tree*/
define('can-key-tree@1.2.2#can-key-tree', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var reflect = require('can-reflect');
    function isBuiltInPrototype(obj) {
        if (obj === Object.prototype) {
            return true;
        }
        var protoString = Object.prototype.toString.call(obj);
        var isNotObjObj = protoString !== '[object Object]';
        var isObjSomething = protoString.indexOf('[object ') !== -1;
        return isNotObjObj && isObjSomething;
    }
    function getDeepSize(root, level) {
        if (level === 0) {
            return reflect.size(root);
        } else if (reflect.size(root) === 0) {
            return 0;
        } else {
            var count = 0;
            reflect.each(root, function (value) {
                count += getDeepSize(value, level - 1);
            });
            return count;
        }
    }
    function getDeep(node, items, depth, maxDepth) {
        if (!node) {
            return;
        }
        if (maxDepth === depth) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                reflect.addValues(items, reflect.toArray(node));
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value) {
                getDeep(value, items, depth + 1, maxDepth);
            });
        }
    }
    function clearDeep(node, keys, maxDepth, deleteHandler) {
        if (maxDepth === keys.length) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                var valuesToRemove = reflect.toArray(node);
                if (deleteHandler) {
                    valuesToRemove.forEach(function (value) {
                        deleteHandler.apply(null, keys.concat(value));
                    });
                }
                reflect.removeValues(node, valuesToRemove);
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value, key) {
                clearDeep(value, keys.concat(key), maxDepth, deleteHandler);
                reflect.deleteKeyValue(node, key);
            });
        }
    }
    var KeyTree = function (treeStructure, callbacks) {
        var FirstConstructor = treeStructure[0];
        if (reflect.isConstructorLike(FirstConstructor)) {
            this.root = new FirstConstructor();
        } else {
            this.root = FirstConstructor;
        }
        this.callbacks = callbacks || {};
        this.treeStructure = treeStructure;
        this.empty = true;
    };
    reflect.assign(KeyTree.prototype, {
        add: function (keys) {
            if (keys.length > this.treeStructure.length) {
                throw new Error('can-key-tree: Can not add path deeper than tree.');
            }
            var place = this.root;
            var rootWasEmpty = this.empty === true;
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(place, key);
                if (!childNode) {
                    var Constructor = this.treeStructure[i + 1];
                    if (isBuiltInPrototype(Constructor.prototype)) {
                        childNode = new Constructor();
                    } else {
                        childNode = new Constructor(key);
                    }
                    reflect.setKeyValue(place, key, childNode);
                }
                place = childNode;
            }
            if (reflect.isMoreListLikeThanMapLike(place)) {
                reflect.addValues(place, [keys[keys.length - 1]]);
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
            if (rootWasEmpty) {
                this.empty = false;
                if (this.callbacks.onFirst) {
                    this.callbacks.onFirst.call(this);
                }
            }
            return this;
        },
        getNode: function (keys) {
            var node = this.root;
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                node = reflect.getKeyValue(node, key);
                if (!node) {
                    return;
                }
            }
            return node;
        },
        get: function (keys) {
            var node = this.getNode(keys);
            if (this.treeStructure.length === keys.length) {
                return node;
            } else {
                var Type = this.treeStructure[this.treeStructure.length - 1];
                var items = new Type();
                getDeep(node, items, keys.length, this.treeStructure.length - 1);
                return items;
            }
        },
        delete: function (keys, deleteHandler) {
            var parentNode = this.root, path = [this.root], lastKey = keys[keys.length - 1];
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(parentNode, key);
                if (childNode === undefined) {
                    return false;
                } else {
                    path.push(childNode);
                }
                parentNode = childNode;
            }
            if (!keys.length) {
                clearDeep(parentNode, [], this.treeStructure.length - 1, deleteHandler);
            } else if (keys.length === this.treeStructure.length) {
                if (reflect.isMoreListLikeThanMapLike(parentNode)) {
                    if (deleteHandler) {
                        deleteHandler.apply(null, keys.concat(lastKey));
                    }
                    reflect.removeValues(parentNode, [lastKey]);
                } else {
                    throw new Error('can-key-tree: Map types are not supported yet.');
                }
            } else {
                var nodeToRemove = reflect.getKeyValue(parentNode, lastKey);
                if (nodeToRemove !== undefined) {
                    clearDeep(nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler);
                    reflect.deleteKeyValue(parentNode, lastKey);
                } else {
                    return false;
                }
            }
            for (i = path.length - 2; i >= 0; i--) {
                if (reflect.size(parentNode) === 0) {
                    parentNode = path[i];
                    reflect.deleteKeyValue(parentNode, keys[i]);
                } else {
                    break;
                }
            }
            if (reflect.size(this.root) === 0) {
                this.empty = true;
                if (this.callbacks.onEmpty) {
                    this.callbacks.onEmpty.call(this);
                }
            }
            return true;
        },
        size: function () {
            return getDeepSize(this.root, this.treeStructure.length - 1);
        },
        isEmpty: function () {
            return this.empty;
        }
    });
    module.exports = KeyTree;
});
/*can-define-lazy-value@1.1.1#define-lazy-value*/
define('can-define-lazy-value@1.1.1#define-lazy-value', function (require, exports, module) {
    'use strict';
    module.exports = function defineLazyValue(obj, prop, initializer, writable) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            get: function () {
                Object.defineProperty(this, prop, {
                    value: undefined,
                    writable: true
                });
                var value = initializer.call(this, obj, prop);
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            },
            set: function (value) {
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            }
        });
    };
});
/*can-event-queue@1.1.7#dependency-record/merge*/
define('can-event-queue@1.1.7#dependency-record/merge', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var mergeValueDependencies = function mergeValueDependencies(obj, source) {
        var sourceValueDeps = source.valueDependencies;
        if (sourceValueDeps) {
            var destValueDeps = obj.valueDependencies;
            if (!destValueDeps) {
                destValueDeps = new Set();
                obj.valueDependencies = destValueDeps;
            }
            canReflect.eachIndex(sourceValueDeps, function (dep) {
                destValueDeps.add(dep);
            });
        }
    };
    var mergeKeyDependencies = function mergeKeyDependencies(obj, source) {
        var sourcekeyDeps = source.keyDependencies;
        if (sourcekeyDeps) {
            var destKeyDeps = obj.keyDependencies;
            if (!destKeyDeps) {
                destKeyDeps = new Map();
                obj.keyDependencies = destKeyDeps;
            }
            canReflect.eachKey(sourcekeyDeps, function (keys, obj) {
                var entry = destKeyDeps.get(obj);
                if (!entry) {
                    entry = new Set();
                    destKeyDeps.set(obj, entry);
                }
                canReflect.eachIndex(keys, function (key) {
                    entry.add(key);
                });
            });
        }
    };
    module.exports = function mergeDependencyRecords(object, source) {
        mergeKeyDependencies(object, source);
        mergeValueDependencies(object, source);
        return object;
    };
});
/*can-event-queue@1.1.7#value/value*/
define('can-event-queue@1.1.7#value/value', [
    'require',
    'exports',
    'module',
    'can-queues',
    'can-key-tree',
    'can-reflect',
    'can-define-lazy-value',
    '../dependency-record/merge'
], function (require, exports, module) {
    'use strict';
    var queues = require('can-queues');
    var KeyTree = require('can-key-tree');
    var canReflect = require('can-reflect');
    var defineLazyValue = require('can-define-lazy-value');
    var mergeDependencyRecords = require('../dependency-record/merge');
    var properties = {
        on: function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        off: function (handler, queueName) {
            if (handler === undefined) {
                if (queueName === undefined) {
                    this.handlers.delete([]);
                } else {
                    this.handlers.delete([queueName]);
                }
            } else {
                this.handlers.delete([
                    queueName || 'mutate',
                    handler
                ]);
            }
        }
    };
    var symbols = {
        'can.onValue': properties.on,
        'can.offValue': properties.off,
        'can.dispatch': function (value, old) {
            var queuesArgs = [];
            queuesArgs = [
                this.handlers.getNode([]),
                this,
                [
                    value,
                    old
                ]
            ];
            queues.enqueueByQueue.apply(queues, queuesArgs);
        },
        'can.getWhatIChange': function getWhatIChange() {
        },
        'can.isBound': function isBound() {
            return !this.handlers.isEmpty();
        }
    };
    function defineLazyHandlers() {
        return new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.onBound !== undefined && this.onBound.bind(this),
            onEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)
        });
    }
    var mixinValueEventBindings = function (obj) {
        canReflect.assign(obj, properties);
        canReflect.assignSymbols(obj, symbols);
        defineLazyValue(obj, 'handlers', defineLazyHandlers, true);
        return obj;
    };
    mixinValueEventBindings.addHandlers = function (obj, callbacks) {
        console.warn('can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.');
        obj.handlers = new KeyTree([
            Object,
            Array
        ], callbacks);
        return obj;
    };
    module.exports = mixinValueEventBindings;
});
/*can-observation@4.2.0#recorder-dependency-helpers*/
define('can-observation@4.2.0#recorder-dependency-helpers', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    function addNewKeyDependenciesIfNotInOld(event) {
        if (this.oldEventSet === undefined || this.oldEventSet['delete'](event) === false) {
            canReflect.onKeyValue(this.observable, event, this.onDependencyChange, 'notify');
        }
    }
    function addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable) {
        eventSet.forEach(addNewKeyDependenciesIfNotInOld, {
            onDependencyChange: this.onDependencyChange,
            observable: observable,
            oldEventSet: this.oldDependencies.keyDependencies.get(observable)
        });
    }
    function removeKeyDependencies(event) {
        canReflect.offKeyValue(this.observable, event, this.onDependencyChange, 'notify');
    }
    function removeObservablesKeyDependencies(oldEventSet, observable) {
        oldEventSet.forEach(removeKeyDependencies, {
            onDependencyChange: this.onDependencyChange,
            observable: observable
        });
    }
    function addValueDependencies(observable) {
        if (this.oldDependencies.valueDependencies.delete(observable) === false) {
            canReflect.onValue(observable, this.onDependencyChange, 'notify');
        }
    }
    function removeValueDependencies(observable) {
        canReflect.offValue(observable, this.onDependencyChange, 'notify');
    }
    module.exports = {
        updateObservations: function (observationData) {
            observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);
            observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);
            observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);
            observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);
        },
        stopObserving: function (observationReciever, onDependencyChange) {
            observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, { onDependencyChange: onDependencyChange });
            observationReciever.valueDependencies.forEach(removeValueDependencies, { onDependencyChange: onDependencyChange });
        }
    };
});
/*can-observation@4.2.0#temporarily-bind*/
define('can-observation@4.2.0#temporarily-bind', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var temporarilyBoundNoOperation = function () {
    };
    var observables;
    var unbindTemporarilyBoundValue = function () {
        for (var i = 0, len = observables.length; i < len; i++) {
            canReflect.offValue(observables[i], temporarilyBoundNoOperation);
        }
        observables = null;
    };
    function temporarilyBind(compute) {
        var computeInstance = compute.computeInstance || compute;
        canReflect.onValue(computeInstance, temporarilyBoundNoOperation);
        if (!observables) {
            observables = [];
            setTimeout(unbindTemporarilyBoundValue, 10);
        }
        observables.push(computeInstance);
    }
    module.exports = temporarilyBind;
});
/*can-observation@4.2.0#can-observation*/
define('can-observation@4.2.0#can-observation', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-reflect',
    'can-queues',
    'can-observation-recorder',
    'can-symbol',
    'can-log/dev/dev',
    'can-event-queue/value/value',
    './recorder-dependency-helpers',
    './temporarily-bind'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var canReflect = require('can-reflect');
        var queues = require('can-queues');
        var ObservationRecorder = require('can-observation-recorder');
        var canSymbol = require('can-symbol');
        var dev = require('can-log/dev/dev');
        var valueEventBindings = require('can-event-queue/value/value');
        var recorderHelpers = require('./recorder-dependency-helpers');
        var temporarilyBind = require('./temporarily-bind');
        var dispatchSymbol = canSymbol.for('can.dispatch');
        var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
        var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
        function Observation(func, context, options) {
            this.deriveQueue = queues.deriveQueue;
            this.func = func;
            this.context = context;
            this.options = options || {
                priority: 0,
                isObservable: true
            };
            this.bound = false;
            this._value = undefined;
            this.newDependencies = ObservationRecorder.makeDependenciesRecord();
            this.oldDependencies = null;
            var self = this;
            this.onDependencyChange = function (newVal) {
                self.dependencyChange(this, newVal);
            };
            this.update = this.update.bind(this);
        }
        valueEventBindings(Observation.prototype);
        canReflect.assign(Observation.prototype, {
            onBound: function () {
                this.bound = true;
                this.oldDependencies = this.newDependencies;
                ObservationRecorder.start(this._name);
                this._value = this.func.call(this.context);
                this.newDependencies = ObservationRecorder.stop();
                recorderHelpers.updateObservations(this);
            },
            dependencyChange: function (context, args) {
                if (this.bound === true) {
                    var queuesArgs = [];
                    queuesArgs = [
                        this.update,
                        this,
                        [],
                        {
                            priority: this.options.priority,
                            element: this.options.element
                        }
                    ];
                    this.deriveQueue.enqueue.apply(this.deriveQueue, queuesArgs);
                }
            },
            update: function () {
                if (this.bound === true) {
                    var oldValue = this._value;
                    this.oldValue = null;
                    this.onBound();
                    if (oldValue !== this._value) {
                        this[dispatchSymbol](this._value, oldValue);
                    }
                }
            },
            onUnbound: function () {
                this.bound = false;
                recorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);
                this.newDependencies = ObservationRecorder.makeDependenciesRecord();
            },
            get: function () {
                if (this.options.isObservable && ObservationRecorder.isRecording()) {
                    ObservationRecorder.add(this);
                    if (this.bound === false) {
                        Observation.temporarilyBind(this);
                    }
                }
                if (this.bound === true) {
                    if (this.deriveQueue.tasksRemainingCount() > 0) {
                        Observation.updateChildrenAndSelf(this);
                    }
                    return this._value;
                } else {
                    return this.func.call(this.context);
                }
            },
            hasDependencies: function () {
                var newDependencies = this.newDependencies;
                return this.bound ? newDependencies.valueDependencies.size + newDependencies.keyDependencies.size > 0 : undefined;
            },
            log: function () {
            }
        });
        Object.defineProperty(Observation.prototype, 'value', {
            get: function () {
                return this.get();
            }
        });
        var observationProto = {
            'can.getValue': Observation.prototype.get,
            'can.isValueLike': true,
            'can.isMapLike': false,
            'can.isListLike': false,
            'can.valueHasDependencies': Observation.prototype.hasDependencies,
            'can.getValueDependencies': function () {
                if (this.bound === true) {
                    var deps = this.newDependencies, result = {};
                    if (deps.keyDependencies.size) {
                        result.keyDependencies = deps.keyDependencies;
                    }
                    if (deps.valueDependencies.size) {
                        result.valueDependencies = deps.valueDependencies;
                    }
                    return result;
                }
                return undefined;
            },
            'can.getPriority': function () {
                return this.options.priority;
            },
            'can.setPriority': function (priority) {
                this.options.priority = priority;
            },
            'can.setElement': function (element) {
                this.options.element = element;
                this.deriveQueue = queues.domQueue || queues.deriveQueue;
            }
        };
        canReflect.assignSymbols(Observation.prototype, observationProto);
        Observation.updateChildrenAndSelf = function (observation) {
            if (observation.update !== undefined && observation.deriveQueue.isEnqueued(observation.update) === true) {
                observation.deriveQueue.flushQueuedTask(observation.update);
                return true;
            }
            if (observation[getValueDependenciesSymbol]) {
                var childHasChanged = false;
                var valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];
                valueDependencies.forEach(function (observable) {
                    if (Observation.updateChildrenAndSelf(observable) === true) {
                        childHasChanged = true;
                    }
                });
                return childHasChanged;
            } else {
                return false;
            }
        };
        var alias = { addAll: 'addMany' };
        [
            'add',
            'addAll',
            'ignore',
            'trap',
            'trapsCount',
            'isRecording'
        ].forEach(function (methodName) {
            Observation[methodName] = function () {
                var name = alias[methodName] ? alias[methodName] : methodName;
                console.warn('can-observation: Call ' + name + '() on can-observation-recorder.');
                return ObservationRecorder[name].apply(this, arguments);
            };
        });
        Observation.prototype.start = function () {
            console.warn('can-observation: Use .on and .off to bind.');
            return this.onBound();
        };
        Observation.prototype.stop = function () {
            console.warn('can-observation: Use .on and .off to bind.');
            return this.onUnbound();
        };
        Observation.temporarilyBind = temporarilyBind;
        module.exports = namespace.Observation = Observation;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-observable@2.5.0#log*/
define('can-simple-observable@2.5.0#log', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var dev = require('can-log/dev/dev');
    var canReflect = require('can-reflect');
    function quoteString(x) {
        return typeof x === 'string' ? JSON.stringify(x) : x;
    }
    module.exports = function log() {
    };
});
/*can-simple-observable@2.5.0#can-simple-observable*/
define('can-simple-observable@2.5.0#can-simple-observable', [
    'require',
    'exports',
    'module',
    './log',
    'can-namespace',
    'can-symbol',
    'can-reflect',
    'can-observation-recorder',
    'can-event-queue/value/value'
], function (require, exports, module) {
    'use strict';
    var log = require('./log');
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var valueEventBindings = require('can-event-queue/value/value');
    var dispatchSymbol = canSymbol.for('can.dispatch');
    function SimpleObservable(initialValue) {
        this._value = initialValue;
    }
    valueEventBindings(SimpleObservable.prototype);
    canReflect.assignMap(SimpleObservable.prototype, {
        log: log,
        get: function () {
            ObservationRecorder.add(this);
            return this._value;
        },
        set: function (value) {
            var old = this._value;
            this._value = value;
            this[dispatchSymbol](value, old);
        }
    });
    Object.defineProperty(SimpleObservable.prototype, 'value', {
        set: function (value) {
            return this.set(value);
        },
        get: function () {
            return this.get();
        }
    });
    var simpleObservableProto = {
        'can.getValue': SimpleObservable.prototype.get,
        'can.setValue': SimpleObservable.prototype.set,
        'can.isMapLike': false,
        'can.valueHasDependencies': function () {
            return true;
        }
    };
    canReflect.assignSymbols(SimpleObservable.prototype, simpleObservableProto);
    module.exports = ns.SimpleObservable = SimpleObservable;
});
/*can-simple-observable@2.5.0#settable/settable*/
define('can-simple-observable@2.5.0#settable/settable', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation-recorder',
    '../can-simple-observable',
    'can-observation',
    'can-queues',
    '../log',
    'can-event-queue/value/value'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var SimpleObservable = require('../can-simple-observable');
    var Observation = require('can-observation');
    var queues = require('can-queues');
    var log = require('../log');
    var valueEventBindings = require('can-event-queue/value/value');
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    function SettableObservable(fn, context, initialValue) {
        this.lastSetValue = new SimpleObservable(initialValue);
        function observe() {
            return fn.call(context, this.lastSetValue.get());
        }
        this.handler = this.handler.bind(this);
        this.observation = new Observation(observe, this);
    }
    valueEventBindings(SettableObservable.prototype);
    canReflect.assignMap(SettableObservable.prototype, {
        log: log,
        constructor: SettableObservable,
        handler: function (newVal) {
            var old = this._value, reasonLog;
            this._value = newVal;
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                newVal,
                old
            ], null, reasonLog);
        },
        onBound: function () {
            if (!this.bound) {
                this.bound = true;
                this.activate();
            }
        },
        activate: function () {
            canReflect.onValue(this.observation, this.handler, 'notify');
            this._value = peek(this.observation);
        },
        onUnbound: function () {
            this.bound = false;
            canReflect.offValue(this.observation, this.handler, 'notify');
        },
        set: function (newVal) {
            var oldVal = this.lastSetValue.get();
            if (canReflect.isObservableLike(oldVal) && canReflect.isValueLike(oldVal) && !canReflect.isObservableLike(newVal)) {
                canReflect.setValue(oldVal, newVal);
            } else {
                if (newVal !== oldVal) {
                    this.lastSetValue.set(newVal);
                }
            }
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    this.onBound();
                }
            }
            if (this.bound === true) {
                return this._value;
            } else {
                return this.observation.get();
            }
        },
        hasDependencies: function () {
            return canReflect.valueHasDependencies(this.observation);
        },
        getValueDependencies: function () {
            return canReflect.getValueDependencies(this.observation);
        }
    });
    Object.defineProperty(SettableObservable.prototype, 'value', {
        set: function (value) {
            return this.set(value);
        },
        get: function () {
            return this.get();
        }
    });
    canReflect.assignSymbols(SettableObservable.prototype, {
        'can.getValue': SettableObservable.prototype.get,
        'can.setValue': SettableObservable.prototype.set,
        'can.isMapLike': false,
        'can.getPriority': function () {
            return canReflect.getPriority(this.observation);
        },
        'can.setPriority': function (newPriority) {
            canReflect.setPriority(this.observation, newPriority);
        },
        'can.valueHasDependencies': SettableObservable.prototype.hasDependencies,
        'can.getValueDependencies': SettableObservable.prototype.getValueDependencies
    });
    module.exports = SettableObservable;
});
/*can-simple-observable@2.5.0#async/async*/
define('can-simple-observable@2.5.0#async/async', [
    'require',
    'exports',
    'module',
    '../can-simple-observable',
    'can-observation',
    'can-queues',
    '../settable/settable',
    'can-reflect',
    'can-observation-recorder',
    'can-event-queue/value/value'
], function (require, exports, module) {
    'use strict';
    var SimpleObservable = require('../can-simple-observable');
    var Observation = require('can-observation');
    var queues = require('can-queues');
    var SettableObservable = require('../settable/settable');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var valueEventBindings = require('can-event-queue/value/value');
    function AsyncObservable(fn, context, initialValue) {
        this.resolve = this.resolve.bind(this);
        this.lastSetValue = new SimpleObservable(initialValue);
        this.handler = this.handler.bind(this);
        function observe() {
            this.resolveCalled = false;
            this.inGetter = true;
            var newVal = fn.call(context, this.lastSetValue.get(), this.bound === true ? this.resolve : undefined);
            this.inGetter = false;
            if (newVal !== undefined) {
                this.resolve(newVal);
            } else if (this.resolveCalled) {
                this.resolve(this._value);
            }
            if (this.bound !== true) {
                return newVal;
            }
        }
        this.observation = new Observation(observe, this);
    }
    AsyncObservable.prototype = Object.create(SettableObservable.prototype);
    AsyncObservable.prototype.constructor = AsyncObservable;
    AsyncObservable.prototype.handler = function (newVal) {
        if (newVal !== undefined) {
            SettableObservable.prototype.handler.apply(this, arguments);
        }
    };
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    AsyncObservable.prototype.activate = function () {
        canReflect.onValue(this.observation, this.handler, 'notify');
        if (!this.resolveCalled) {
            this._value = peek(this.observation);
        }
    };
    AsyncObservable.prototype.resolve = function resolve(newVal) {
        this.resolveCalled = true;
        var old = this._value;
        this._value = newVal;
        if (!this.inGetter) {
            var queuesArgs = [
                this.handlers.getNode([]),
                this,
                [
                    newVal,
                    old
                ],
                null
            ];
            queues.enqueueByQueue.apply(queues, queuesArgs);
        }
    };
    module.exports = AsyncObservable;
});
/*can-globals@1.2.2#can-globals-proto*/
define('can-globals@1.2.2#can-globals-proto', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        function dispatch(key) {
            var handlers = this.eventHandlers[key];
            if (handlers) {
                var handlersCopy = handlers.slice();
                var value = this.getKeyValue(key);
                for (var i = 0; i < handlersCopy.length; i++) {
                    handlersCopy[i](value);
                }
            }
        }
        function Globals() {
            this.eventHandlers = {};
            this.properties = {};
        }
        Globals.prototype.define = function (key, value, enableCache) {
            if (enableCache === undefined) {
                enableCache = true;
            }
            if (!this.properties[key]) {
                this.properties[key] = {
                    default: value,
                    value: value,
                    enableCache: enableCache
                };
            }
            return this;
        };
        Globals.prototype.getKeyValue = function (key) {
            var property = this.properties[key];
            if (property) {
                if (typeof property.value === 'function') {
                    if (property.cachedValue) {
                        return property.cachedValue;
                    }
                    if (property.enableCache) {
                        property.cachedValue = property.value();
                        return property.cachedValue;
                    } else {
                        return property.value();
                    }
                }
                return property.value;
            }
        };
        Globals.prototype.makeExport = function (key) {
            return function (value) {
                if (arguments.length === 0) {
                    return this.getKeyValue(key);
                }
                if (typeof value === 'undefined' || value === null) {
                    this.deleteKeyValue(key);
                } else {
                    if (typeof value === 'function') {
                        this.setKeyValue(key, function () {
                            return value;
                        });
                    } else {
                        this.setKeyValue(key, value);
                    }
                    return value;
                }
            }.bind(this);
        };
        Globals.prototype.offKeyValue = function (key, handler) {
            if (this.properties[key]) {
                var handlers = this.eventHandlers[key];
                if (handlers) {
                    var i = handlers.indexOf(handler);
                    handlers.splice(i, 1);
                }
            }
            return this;
        };
        Globals.prototype.onKeyValue = function (key, handler) {
            if (this.properties[key]) {
                if (!this.eventHandlers[key]) {
                    this.eventHandlers[key] = [];
                }
                this.eventHandlers[key].push(handler);
            }
            return this;
        };
        Globals.prototype.deleteKeyValue = function (key) {
            var property = this.properties[key];
            if (property !== undefined) {
                property.value = property.default;
                property.cachedValue = undefined;
                dispatch.call(this, key);
            }
            return this;
        };
        Globals.prototype.setKeyValue = function (key, value) {
            if (!this.properties[key]) {
                return this.define(key, value);
            }
            var property = this.properties[key];
            property.value = value;
            property.cachedValue = undefined;
            dispatch.call(this, key);
            return this;
        };
        Globals.prototype.reset = function () {
            for (var key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    this.properties[key].value = this.properties[key].default;
                    this.properties[key].cachedValue = undefined;
                    dispatch.call(this, key);
                }
            }
            return this;
        };
        canReflect.assignSymbols(Globals.prototype, {
            'can.getKeyValue': Globals.prototype.getKeyValue,
            'can.setKeyValue': Globals.prototype.setKeyValue,
            'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
            'can.onKeyValue': Globals.prototype.onKeyValue,
            'can.offKeyValue': Globals.prototype.offKeyValue
        });
        module.exports = Globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#can-globals-instance*/
define('can-globals@1.2.2#can-globals-instance', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './can-globals-proto'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Globals = require('./can-globals-proto');
        var globals = new Globals();
        if (namespace.globals) {
            throw new Error('You can\'t have two versions of can-globals, check your dependencies');
        } else {
            module.exports = namespace.globals = globals;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#global/global*/
define('can-globals@1.2.2#global/global', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('global', function () {
            return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
        });
        module.exports = globals.makeExport('global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#document/document*/
define('can-globals@1.2.2#document/document', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('document', function () {
            return globals.getKeyValue('global').document;
        });
        module.exports = globals.makeExport('document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#is-node/is-node*/
define('can-globals@1.2.2#is-node/is-node', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('isNode', function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        });
        module.exports = globals.makeExport('isNode');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#is-browser-window/is-browser-window*/
define('can-globals@1.2.2#is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    '../is-node/is-node'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('../is-node/is-node');
        globals.define('isBrowserWindow', function () {
            var isNode = globals.getKeyValue('isNode');
            return typeof window !== 'undefined' && typeof document !== 'undefined' && isNode === false;
        });
        module.exports = globals.makeExport('isBrowserWindow');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.3.11#helpers/util*/
define('can-dom-events@1.3.11#helpers/util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getCurrentDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        function getTargetDocument(target) {
            return target.ownerDocument || getCurrentDocument();
        }
        function createEvent(target, eventData, bubbles, cancelable) {
            var doc = getTargetDocument(target);
            var event = doc.createEvent('HTMLEvents');
            var eventType;
            if (typeof eventData === 'string') {
                eventType = eventData;
            } else {
                eventType = eventData.type;
                for (var prop in eventData) {
                    if (event[prop] === undefined) {
                        event[prop] = eventData[prop];
                    }
                }
            }
            if (bubbles === undefined) {
                bubbles = true;
            }
            event.initEvent(eventType, bubbles, cancelable);
            return event;
        }
        function isDomEventTarget(obj) {
            if (!(obj && obj.nodeName)) {
                return obj === window;
            }
            var nodeType = obj.nodeType;
            return nodeType === 1 || nodeType === 9 || nodeType === 11;
        }
        function addDomContext(context, args) {
            if (isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                args.unshift(context);
            }
            return args;
        }
        function removeDomContext(context, args) {
            if (!isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                context = args.shift();
            }
            return {
                context: context,
                args: args
            };
        }
        var fixSyntheticEventsOnDisabled = false;
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                input.removeEventListener(testEventName, onTest);
            };
            input.addEventListener(testEventName, onTest);
            try {
                var event = document.create('HTMLEvents');
                event.initEvent(testEventName, false);
                input.dispatchEvent(event);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
        function isDispatchingOnDisabled(element, event) {
            var eventType = event.type;
            var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        function forceEnabledForDispatch(element, event) {
            return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
        }
        module.exports = {
            createEvent: createEvent,
            addDomContext: addDomContext,
            removeDomContext: removeDomContext,
            isDomEventTarget: isDomEventTarget,
            getTargetDocument: getTargetDocument,
            forceEnabledForDispatch: forceEnabledForDispatch
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.3.11#helpers/make-event-registry*/
define('can-dom-events@1.3.11#helpers/make-event-registry', function (require, exports, module) {
    'use strict';
    function EventRegistry() {
        this._registry = {};
    }
    module.exports = function makeEventRegistry() {
        return new EventRegistry();
    };
    EventRegistry.prototype.has = function (eventType) {
        return !!this._registry[eventType];
    };
    EventRegistry.prototype.get = function (eventType) {
        return this._registry[eventType];
    };
    EventRegistry.prototype.add = function (event, eventType) {
        if (!event) {
            throw new Error('An EventDefinition must be provided');
        }
        if (typeof event.addEventListener !== 'function') {
            throw new TypeError('EventDefinition addEventListener must be a function');
        }
        if (typeof event.removeEventListener !== 'function') {
            throw new TypeError('EventDefinition removeEventListener must be a function');
        }
        eventType = eventType || event.defaultEventType;
        if (typeof eventType !== 'string') {
            throw new TypeError('Event type must be a string, not ' + eventType);
        }
        if (this.has(eventType)) {
            throw new Error('Event "' + eventType + '" is already registered');
        }
        this._registry[eventType] = event;
        var self = this;
        return function remove() {
            self._registry[eventType] = undefined;
        };
    };
});
/*can-dom-events@1.3.11#helpers/-make-delegate-event-tree*/
define('can-dom-events@1.3.11#helpers/-make-delegate-event-tree', [
    'require',
    'exports',
    'module',
    'can-key-tree',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var KeyTree = require('can-key-tree');
    var canReflect = require('can-reflect');
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    function makeDelegator(domEvents) {
        var Delegator = function Delegator(parentKey) {
            this.element = parentKey;
            this.events = {};
            this.delegated = {};
        };
        canReflect.assignSymbols(Delegator.prototype, {
            'can.setKeyValue': function (eventType, handlersBySelector) {
                var handler = this.delegated[eventType] = function (ev) {
                    var cur = ev.target;
                    var propagate = true;
                    var origStopPropagation = ev.stopPropagation;
                    ev.stopPropagation = function () {
                        origStopPropagation.apply(this, arguments);
                        propagate = false;
                    };
                    var origStopImmediatePropagation = ev.stopImmediatePropagation;
                    ev.stopImmediatePropagation = function () {
                        origStopImmediatePropagation.apply(this, arguments);
                        propagate = false;
                    };
                    do {
                        var el = cur === document ? document.documentElement : cur;
                        var matches = el.matches || el.msMatchesSelector;
                        canReflect.each(handlersBySelector, function (handlers, selector) {
                            if (matches && matches.call(el, selector)) {
                                handlers.forEach(function (handler) {
                                    handler.call(el, ev);
                                });
                            }
                        });
                        cur = cur.parentNode;
                    } while (cur && cur !== ev.currentTarget && propagate);
                };
                this.events[eventType] = handlersBySelector;
                domEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));
            },
            'can.getKeyValue': function (eventType) {
                return this.events[eventType];
            },
            'can.deleteKeyValue': function (eventType) {
                domEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));
                delete this.delegated[eventType];
                delete this.events[eventType];
            },
            'can.getOwnEnumerableKeys': function () {
                return Object.keys(this.events);
            }
        });
        return Delegator;
    }
    module.exports = function makeDelegateEventTree(domEvents) {
        var Delegator = makeDelegator(domEvents);
        return new KeyTree([
            Map,
            Delegator,
            Object,
            Array
        ]);
    };
});
/*can-dom-events@1.3.11#can-dom-events*/
define('can-dom-events@1.3.11#can-dom-events', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './helpers/util',
    './helpers/make-event-registry',
    './helpers/-make-delegate-event-tree'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var util = require('./helpers/util');
        var makeEventRegistry = require('./helpers/make-event-registry');
        var makeDelegateEventTree = require('./helpers/-make-delegate-event-tree');
        var domEvents = {
            _eventRegistry: makeEventRegistry(),
            addEvent: function (event, eventType) {
                return this._eventRegistry.add(event, eventType);
            },
            addEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.addEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.addEventListener.apply(target, eventArgs);
            },
            removeEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.removeEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.removeEventListener.apply(target, eventArgs);
            },
            addDelegateListener: function (root, eventType, selector, handler) {
                domEvents._eventTree.add([
                    root,
                    eventType,
                    selector,
                    handler
                ]);
            },
            removeDelegateListener: function (target, eventType, selector, handler) {
                domEvents._eventTree.delete([
                    target,
                    eventType,
                    selector,
                    handler
                ]);
            },
            dispatch: function (target, eventData, bubbles, cancelable) {
                var event = util.createEvent(target, eventData, bubbles, cancelable);
                var enableForDispatch = util.forceEnabledForDispatch(target, event);
                if (enableForDispatch) {
                    target.disabled = false;
                }
                var ret = target.dispatchEvent(event);
                if (enableForDispatch) {
                    target.disabled = true;
                }
                return ret;
            }
        };
        domEvents._eventTree = makeDelegateEventTree(domEvents);
        module.exports = namespace.domEvents = domEvents;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event-queue@1.1.7#map/map*/
define('can-event-queue@1.1.7#map/map', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-queues',
    'can-reflect',
    'can-symbol',
    'can-key-tree',
    'can-dom-events',
    'can-dom-events/helpers/util',
    '../dependency-record/merge'
], function (require, exports, module) {
    'use strict';
    var canDev = require('can-log/dev/dev');
    var queues = require('can-queues');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var KeyTree = require('can-key-tree');
    var domEvents = require('can-dom-events');
    var isDomEventTarget = require('can-dom-events/helpers/util').isDomEventTarget;
    var mergeDependencyRecords = require('../dependency-record/merge');
    var metaSymbol = canSymbol.for('can.meta'), dispatchBoundChangeSymbol = canSymbol.for('can.dispatchInstanceBoundChange'), dispatchInstanceOnPatchesSymbol = canSymbol.for('can.dispatchInstanceOnPatches'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), offKeyValueSymbol = canSymbol.for('can.offKeyValue'), onEventSymbol = canSymbol.for('can.onEvent'), offEventSymbol = canSymbol.for('can.offEvent'), onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue'), inSetupSymbol = canSymbol.for('can.initializing');
    var legacyMapBindings;
    function addHandlers(obj, meta) {
        if (!meta.handlers) {
            meta.handlers = new KeyTree([
                Object,
                Object,
                Object,
                Array
            ], {
                onFirst: function () {
                    if (obj._eventSetup !== undefined) {
                        obj._eventSetup();
                    }
                    var constructor = obj.constructor;
                    if (constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {
                        constructor[dispatchBoundChangeSymbol](obj, true);
                    }
                },
                onEmpty: function () {
                    if (obj._eventTeardown !== undefined) {
                        obj._eventTeardown();
                    }
                    var constructor = obj.constructor;
                    if (constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {
                        constructor[dispatchBoundChangeSymbol](obj, false);
                    }
                }
            });
        }
        if (!meta.listenHandlers) {
            meta.listenHandlers = new KeyTree([
                Map,
                Map,
                Object,
                Array
            ]);
        }
    }
    var ensureMeta = function ensureMeta(obj) {
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        addHandlers(obj, meta);
        return meta;
    };
    function stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {
        if (arguments.length && canReflect.isPrimitive(bindTarget)) {
            queueName = handler;
            handler = event;
            event = bindTarget;
            bindTarget = this.context;
        }
        if (typeof event === 'function') {
            queueName = handler;
            handler = event;
            event = undefined;
        }
        if (typeof handler === 'string') {
            queueName = handler;
            handler = undefined;
        }
        var keys = [];
        if (bindTarget) {
            keys.push(bindTarget);
            if (event || handler || queueName) {
                keys.push(event);
                if (queueName || handler) {
                    keys.push(queueName || this.defaultQueue);
                    if (handler) {
                        keys.push(handler);
                    }
                }
            }
        }
        return keys;
    }
    var props = {
        dispatch: function (event, args) {
            if (this.__inSetup !== true && this[inSetupSymbol] !== true) {
                if (typeof event === 'string') {
                    event = { type: event };
                }
                var meta = ensureMeta(this);
                var handlers = meta.handlers;
                var handlersByType = event.type !== undefined && handlers.getNode([event.type]);
                var dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];
                var patchesNode = event.patches !== undefined && handlers.getNode([
                    'can.patches',
                    'onKeyValue'
                ]);
                var keysNode = event.keyChanged !== undefined && handlers.getNode([
                    'can.keys',
                    'onKeyValue'
                ]);
                var batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;
                if (batch) {
                    queues.batch.start();
                }
                if (handlersByType) {
                    if (handlersByType.onKeyValue) {
                        queues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);
                    }
                    if (handlersByType.event) {
                        event.batchNum = queues.batch.number();
                        var eventAndArgs = [event].concat(args);
                        queues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);
                    }
                }
                if (keysNode) {
                    queues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);
                }
                if (patchesNode) {
                    queues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);
                }
                if (dispatchConstructorPatches) {
                    this.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);
                }
                if (batch) {
                    queues.batch.stop();
                }
            }
            return event;
        },
        addEventListener: function (key, handler, queueName) {
            ensureMeta(this).handlers.add([
                key,
                'event',
                queueName || 'mutate',
                handler
            ]);
            return this;
        },
        removeEventListener: function (key, handler, queueName) {
            if (key === undefined) {
                var handlers = ensureMeta(this).handlers;
                var keyHandlers = handlers.getNode([]);
                Object.keys(keyHandlers).forEach(function (key) {
                    handlers.delete([
                        key,
                        'event'
                    ]);
                });
            } else if (!handler && !queueName) {
                ensureMeta(this).handlers.delete([
                    key,
                    'event'
                ]);
            } else if (!handler) {
                ensureMeta(this).handlers.delete([
                    key,
                    'event',
                    queueName || 'mutate'
                ]);
            } else {
                ensureMeta(this).handlers.delete([
                    key,
                    'event',
                    queueName || 'mutate',
                    handler
                ]);
            }
            return this;
        },
        one: function (event, handler) {
            var one = function () {
                legacyMapBindings.off.call(this, event, one);
                return handler.apply(this, arguments);
            };
            legacyMapBindings.on.call(this, event, one);
            return this;
        },
        listenTo: function (bindTarget, event, handler, queueName) {
            if (canReflect.isPrimitive(bindTarget)) {
                queueName = handler;
                handler = event;
                event = bindTarget;
                bindTarget = this;
            }
            if (typeof event === 'function') {
                queueName = handler;
                handler = event;
                event = undefined;
            }
            ensureMeta(this).listenHandlers.add([
                bindTarget,
                event,
                queueName || 'mutate',
                handler
            ]);
            legacyMapBindings.on.call(bindTarget, event, handler, queueName || 'mutate');
            return this;
        },
        stopListening: function () {
            var keys = stopListeningArgumentsToKeys.apply({
                context: this,
                defaultQueue: 'mutate'
            }, arguments);
            var listenHandlers = ensureMeta(this).listenHandlers;
            function deleteHandler(bindTarget, event, queue, handler) {
                legacyMapBindings.off.call(bindTarget, event, handler, queue);
            }
            listenHandlers.delete(keys, deleteHandler);
            return this;
        },
        on: function (eventName, handler, queue) {
            var listenWithDOM = isDomEventTarget(this);
            if (listenWithDOM) {
                if (typeof handler === 'string') {
                    domEvents.addDelegateListener(this, eventName, handler, queue);
                } else {
                    domEvents.addEventListener(this, eventName, handler, queue);
                }
            } else {
                if (this[onEventSymbol]) {
                    this[onEventSymbol](eventName, handler, queue);
                } else if ('addEventListener' in this) {
                    this.addEventListener(eventName, handler, queue);
                } else if (this[onKeyValueSymbol]) {
                    canReflect.onKeyValue(this, eventName, handler, queue);
                } else {
                    if (!eventName && this[onValueSymbol]) {
                        canReflect.onValue(this, handler, queue);
                    } else {
                        throw new Error('can-event-queue: Unable to bind ' + eventName);
                    }
                }
            }
            return this;
        },
        off: function (eventName, handler, queue) {
            var listenWithDOM = isDomEventTarget(this);
            if (listenWithDOM) {
                if (typeof handler === 'string') {
                    domEvents.removeDelegateListener(this, eventName, handler, queue);
                } else {
                    domEvents.removeEventListener(this, eventName, handler, queue);
                }
            } else {
                if (this[offEventSymbol]) {
                    this[offEventSymbol](eventName, handler, queue);
                } else if ('removeEventListener' in this) {
                    this.removeEventListener(eventName, handler, queue);
                } else if (this[offKeyValueSymbol]) {
                    canReflect.offKeyValue(this, eventName, handler, queue);
                } else {
                    if (!eventName && this[offValueSymbol]) {
                        canReflect.offValue(this, handler, queue);
                    } else {
                        throw new Error('can-event-queue: Unable to unbind ' + eventName);
                    }
                }
            }
            return this;
        }
    };
    var symbols = {
        'can.onKeyValue': function (key, handler, queueName) {
            ensureMeta(this).handlers.add([
                key,
                'onKeyValue',
                queueName || 'mutate',
                handler
            ]);
        },
        'can.offKeyValue': function (key, handler, queueName) {
            ensureMeta(this).handlers.delete([
                key,
                'onKeyValue',
                queueName || 'mutate',
                handler
            ]);
        },
        'can.isBound': function () {
            return !ensureMeta(this).handlers.isEmpty();
        },
        'can.getWhatIChange': function getWhatIChange(key) {
        },
        'can.onPatches': function (handler, queue) {
            var handlers = ensureMeta(this).handlers;
            handlers.add([
                'can.patches',
                'onKeyValue',
                queue || 'notify',
                handler
            ]);
        },
        'can.offPatches': function (handler, queue) {
            var handlers = ensureMeta(this).handlers;
            handlers.delete([
                'can.patches',
                'onKeyValue',
                queue || 'notify',
                handler
            ]);
        }
    };
    function defineNonEnumerable(obj, prop, value) {
        Object.defineProperty(obj, prop, {
            enumerable: false,
            value: value
        });
    }
    legacyMapBindings = function (obj) {
        canReflect.assignMap(obj, props);
        return canReflect.assignSymbols(obj, symbols);
    };
    defineNonEnumerable(legacyMapBindings, 'addHandlers', addHandlers);
    defineNonEnumerable(legacyMapBindings, 'stopListeningArgumentsToKeys', stopListeningArgumentsToKeys);
    props.bind = props.addEventListener;
    props.unbind = props.removeEventListener;
    canReflect.assignMap(legacyMapBindings, props);
    canReflect.assignSymbols(legacyMapBindings, symbols);
    defineNonEnumerable(legacyMapBindings, 'start', function () {
        console.warn('use can-queues.batch.start()');
        queues.batch.start();
    });
    defineNonEnumerable(legacyMapBindings, 'stop', function () {
        console.warn('use can-queues.batch.stop()');
        queues.batch.stop();
    });
    defineNonEnumerable(legacyMapBindings, 'flush', function () {
        console.warn('use can-queues.flush()');
        queues.flush();
    });
    defineNonEnumerable(legacyMapBindings, 'afterPreviousEvents', function (handler) {
        console.warn('don\'t use afterPreviousEvents');
        queues.mutateQueue.enqueue(function afterPreviousEvents() {
            queues.mutateQueue.enqueue(handler);
        });
        queues.flush();
    });
    defineNonEnumerable(legacyMapBindings, 'after', function (handler) {
        console.warn('don\'t use after');
        queues.mutateQueue.enqueue(handler);
        queues.flush();
    });
    module.exports = legacyMapBindings;
});
/*can-simple-observable@2.5.0#resolver/resolver*/
define('can-simple-observable@2.5.0#resolver/resolver', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    'can-observation',
    'can-queues',
    'can-event-queue/map/map',
    '../settable/settable',
    '../can-simple-observable'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var Observation = require('can-observation');
    var queues = require('can-queues');
    var mapEventBindings = require('can-event-queue/map/map');
    var SettableObservable = require('../settable/settable');
    var SimpleObservable = require('../can-simple-observable');
    var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
    var metaSymbol = canSymbol.for('can.meta');
    function ResolverObservable(resolver, context, initialValue, options) {
        this.resolver = ObservationRecorder.ignore(resolver);
        this.context = context;
        this._valueOptions = {
            resolve: this.resolve.bind(this),
            listenTo: this.listenTo.bind(this),
            stopListening: this.stopListening.bind(this),
            lastSet: new SimpleObservable(initialValue)
        };
        this.update = this.update.bind(this);
        this.contextHandlers = new WeakMap();
        this.teardown = null;
        this.binder = {};
        this[metaSymbol] = canReflect.assignMap({}, options);
    }
    ResolverObservable.prototype = Object.create(SettableObservable.prototype);
    function deleteHandler(bindTarget, event, queue, handler) {
        mapEventBindings.off.call(bindTarget, event, handler, queue);
    }
    canReflect.assignMap(ResolverObservable.prototype, {
        constructor: ResolverObservable,
        listenTo: function (bindTarget, event, handler, queueName) {
            if (canReflect.isPrimitive(bindTarget)) {
                handler = event;
                event = bindTarget;
                bindTarget = this.context;
            }
            if (typeof event === 'function') {
                handler = event;
                event = undefined;
            }
            var resolverInstance = this;
            var contextHandler = handler.bind(this.context);
            contextHandler[getChangesSymbol] = function getChangesDependencyRecord() {
                var s = new Set();
                s.add(resolverInstance);
                return { valueDependencies: s };
            };
            this.contextHandlers.set(handler, contextHandler);
            mapEventBindings.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || 'notify');
        },
        stopListening: function () {
            var meta = this.binder[canSymbol.for('can.meta')];
            var listenHandlers = meta && meta.listenHandlers;
            if (listenHandlers) {
                var keys = mapEventBindings.stopListeningArgumentsToKeys.call({
                    context: this.context,
                    defaultQueue: 'notify'
                });
                listenHandlers.delete(keys, deleteHandler);
            }
            return this;
        },
        resolve: function (newVal) {
            this._value = newVal;
            if (this.isBinding) {
                this.lastValue = this._value;
                return newVal;
            }
            if (this._value !== this.lastValue) {
                var enqueueMeta = {};
                queues.batch.start();
                queues.deriveQueue.enqueue(this.update, this, [], enqueueMeta);
                queues.batch.stop();
            }
            return newVal;
        },
        update: function () {
            if (this.lastValue !== this._value) {
                var old = this.lastValue;
                this.lastValue = this._value;
                queues.enqueueByQueue(this.handlers.getNode([]), this, [
                    this._value,
                    old
                ]);
            }
        },
        activate: function () {
            this.isBinding = true;
            this.teardown = this.resolver.call(this.context, this._valueOptions);
            this.isBinding = false;
        },
        onUnbound: function () {
            this.bound = false;
            mapEventBindings.stopListening.call(this.binder);
            if (this.teardown != null) {
                this.teardown();
                this.teardown = null;
            }
        },
        set: function (value) {
            this._valueOptions.lastSet.set(value);
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    this.onBound();
                }
            }
            if (this.bound === true) {
                return this._value;
            } else {
                if (this[metaSymbol].resetUnboundValueInGet) {
                    this._value = undefined;
                }
                var handler = function () {
                };
                this.on(handler);
                var val = this._value;
                this.off(handler);
                return val;
            }
        },
        hasDependencies: function hasDependencies() {
            var hasDependencies = false;
            if (this.bound) {
                var meta = this.binder[metaSymbol];
                var listenHandlers = meta && meta.listenHandlers;
                hasDependencies = !!listenHandlers.size();
            }
            return hasDependencies;
        },
        getValueDependencies: function getValueDependencies() {
            if (this.bound) {
                var meta = this.binder[canSymbol.for('can.meta')];
                var listenHandlers = meta && meta.listenHandlers;
                var keyDeps = new Map();
                var valueDeps = new Set();
                if (listenHandlers) {
                    canReflect.each(listenHandlers.root, function (events, obj) {
                        canReflect.each(events, function (queues, eventName) {
                            if (eventName === undefined) {
                                valueDeps.add(obj);
                            } else {
                                var entry = keyDeps.get(obj);
                                if (!entry) {
                                    entry = new Set();
                                    keyDeps.set(obj, entry);
                                }
                                entry.add(eventName);
                            }
                        });
                    });
                    if (valueDeps.size || keyDeps.size) {
                        var result = {};
                        if (keyDeps.size) {
                            result.keyDependencies = keyDeps;
                        }
                        if (valueDeps.size) {
                            result.valueDependencies = valueDeps;
                        }
                        return result;
                    }
                }
            }
        }
    });
    canReflect.assignSymbols(ResolverObservable.prototype, {
        'can.getValue': ResolverObservable.prototype.get,
        'can.setValue': ResolverObservable.prototype.set,
        'can.isMapLike': false,
        'can.getPriority': function () {
            return this.priority || 0;
        },
        'can.setPriority': function (newPriority) {
            this.priority = newPriority;
        },
        'can.valueHasDependencies': ResolverObservable.prototype.hasDependencies,
        'can.getValueDependencies': ResolverObservable.prototype.getValueDependencies
    });
    module.exports = ResolverObservable;
});
/*can-event-queue@1.1.7#type/type*/
define('can-event-queue@1.1.7#type/type', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-key-tree',
    'can-queues'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var KeyTree = require('can-key-tree');
    var queues = require('can-queues');
    var metaSymbol = canSymbol.for('can.meta');
    function addHandlers(obj, meta) {
        if (!meta.lifecycleHandlers) {
            meta.lifecycleHandlers = new KeyTree([
                Object,
                Array
            ]);
        }
        if (!meta.instancePatchesHandlers) {
            meta.instancePatchesHandlers = new KeyTree([
                Object,
                Array
            ]);
        }
    }
    function ensureMeta(obj) {
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        addHandlers(obj, meta);
        return meta;
    }
    var props = {};
    function onOffAndDispatch(symbolName, dispatchName, handlersName) {
        props['can.on' + symbolName] = function (handler, queueName) {
            ensureMeta(this)[handlersName].add([
                queueName || 'mutate',
                handler
            ]);
        };
        props['can.off' + symbolName] = function (handler, queueName) {
            ensureMeta(this)[handlersName].delete([
                queueName || 'mutate',
                handler
            ]);
        };
        props['can.' + dispatchName] = function (instance, arg) {
            queues.enqueueByQueue(ensureMeta(this)[handlersName].getNode([]), this, [
                instance,
                arg
            ]);
        };
    }
    onOffAndDispatch('InstancePatches', 'dispatchInstanceOnPatches', 'instancePatchesHandlers');
    onOffAndDispatch('InstanceBoundChange', 'dispatchInstanceBoundChange', 'lifecycleHandlers');
    function mixinTypeBindings(obj) {
        return canReflect.assignSymbols(obj, props);
    }
    Object.defineProperty(mixinTypeBindings, 'addHandlers', {
        enumerable: false,
        value: addHandlers
    });
    module.exports = mixinTypeBindings;
});
/*can-string-to-any@1.2.1#can-string-to-any*/
define('can-string-to-any@1.2.1#can-string-to-any', function (require, exports, module) {
    'use strict';
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-data-types@1.2.1#maybe-boolean/maybe-boolean*/
define('can-data-types@1.2.1#maybe-boolean/maybe-boolean', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    function toBoolean(val) {
        if (val == null) {
            return val;
        }
        if (val === 'false' || val === '0' || !val) {
            return false;
        }
        return true;
    }
    module.exports = canReflect.assignSymbols(toBoolean, {
        'can.new': toBoolean,
        'can.getSchema': function () {
            return {
                type: 'Or',
                values: [
                    true,
                    false,
                    undefined,
                    null
                ]
            };
        },
        'can.getName': function () {
            return 'MaybeBoolean';
        },
        'can.isMember': function (value) {
            return value == null || typeof value === 'boolean';
        }
    });
});
/*can-data-types@1.2.1#maybe-date/maybe-date*/
define('can-data-types@1.2.1#maybe-date/maybe-date', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    function toDate(str) {
        var type = typeof str;
        if (type === 'string') {
            str = Date.parse(str);
            return isNaN(str) ? null : new Date(str);
        } else if (type === 'number') {
            return new Date(str);
        } else {
            return str;
        }
    }
    function DateStringSet(dateStr) {
        this.setValue = dateStr;
        var date = toDate(dateStr);
        this.value = date == null ? date : date.getTime();
    }
    DateStringSet.prototype.valueOf = function () {
        return this.value;
    };
    canReflect.assignSymbols(DateStringSet.prototype, {
        'can.serialize': function () {
            return this.setValue;
        }
    });
    module.exports = canReflect.assignSymbols(toDate, {
        'can.new': toDate,
        'can.getSchema': function () {
            return {
                type: 'Or',
                values: [
                    Date,
                    undefined,
                    null
                ]
            };
        },
        'can.ComparisonSetType': DateStringSet,
        'can.getName': function () {
            return 'MaybeDate';
        },
        'can.isMember': function (value) {
            return value == null || value instanceof Date;
        }
    });
});
/*can-data-types@1.2.1#maybe-number/maybe-number*/
define('can-data-types@1.2.1#maybe-number/maybe-number', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    function toNumber(val) {
        if (val == null) {
            return val;
        }
        return +val;
    }
    module.exports = canReflect.assignSymbols(toNumber, {
        'can.new': toNumber,
        'can.getSchema': function () {
            return {
                type: 'Or',
                values: [
                    Number,
                    undefined,
                    null
                ]
            };
        },
        'can.getName': function () {
            return 'MaybeNumber';
        },
        'can.isMember': function (value) {
            return value == null || typeof value === 'number';
        }
    });
});
/*can-data-types@1.2.1#maybe-string/maybe-string*/
define('can-data-types@1.2.1#maybe-string/maybe-string', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    function toString(val) {
        if (val == null) {
            return val;
        }
        return '' + val;
    }
    module.exports = canReflect.assignSymbols(toString, {
        'can.new': toString,
        'can.getSchema': function () {
            return {
                type: 'Or',
                values: [
                    String,
                    undefined,
                    null
                ]
            };
        },
        'can.getName': function () {
            return 'MaybeString';
        },
        'can.isMember': function (value) {
            return value == null || typeof value === 'string';
        }
    });
});
/*can-define@2.8.0#can-define*/
define('can-define@2.8.0#can-define', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-symbol',
    'can-reflect',
    'can-observation',
    'can-observation-recorder',
    'can-simple-observable/async/async',
    'can-simple-observable/settable/settable',
    'can-simple-observable/resolver/resolver',
    'can-event-queue/map/map',
    'can-event-queue/type/type',
    'can-queues',
    'can-assign',
    'can-log/dev/dev',
    'can-string-to-any',
    'can-define-lazy-value',
    'can-data-types/maybe-boolean/maybe-boolean',
    'can-data-types/maybe-date/maybe-date',
    'can-data-types/maybe-number/maybe-number',
    'can-data-types/maybe-string/maybe-string'
], function (require, exports, module) {
    'use strict';
    'format cjs';
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var AsyncObservable = require('can-simple-observable/async/async');
    var SettableObservable = require('can-simple-observable/settable/settable');
    var ResolverObservable = require('can-simple-observable/resolver/resolver');
    var eventQueue = require('can-event-queue/map/map');
    var addTypeEvents = require('can-event-queue/type/type');
    var queues = require('can-queues');
    var assign = require('can-assign');
    var canLogDev = require('can-log/dev/dev');
    var stringToAny = require('can-string-to-any');
    var defineLazyValue = require('can-define-lazy-value');
    var MaybeBoolean = require('can-data-types/maybe-boolean/maybe-boolean'), MaybeDate = require('can-data-types/maybe-date/maybe-date'), MaybeNumber = require('can-data-types/maybe-number/maybe-number'), MaybeString = require('can-data-types/maybe-string/maybe-string');
    var newSymbol = canSymbol.for('can.new'), serializeSymbol = canSymbol.for('can.serialize'), inSetupSymbol = canSymbol.for('can.initializing');
    var eventsProto, define, make, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod;
    function isDefineType(func) {
        return func && (func.canDefineType === true || func[newSymbol]);
    }
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    var Object_defineNamedPrototypeProperty = Object.defineProperty;
    function defineConfigurableAndNotEnumerable(obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    }
    function eachPropertyDescriptor(map, cb) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                cb.call(map, prop, Object.getOwnPropertyDescriptor(map, prop));
            }
        }
    }
    function getEveryPropertyAndSymbol(obj) {
        var props = Object.getOwnPropertyNames(obj);
        var symbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(obj) : [];
        return props.concat(symbols);
    }
    function cleanUpDefinition(prop, definition, shouldWarn, typePrototype) {
        if (definition.value !== undefined && (typeof definition.value !== 'function' || definition.value.length === 0)) {
            definition.default = definition.value;
            delete definition.value;
        }
        if (definition.Value !== undefined) {
            definition.Default = definition.Value;
            delete definition.Value;
        }
    }
    function isValueResolver(definition) {
        return typeof definition.value === 'function' && definition.value.length;
    }
    module.exports = define = ns.define = function (typePrototype, defines, baseDefine) {
        var prop, dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null), computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);
        var result = getDefinitionsAndMethods(defines, baseDefine, typePrototype);
        result.dataInitializers = dataInitializers;
        result.computedInitializers = computedInitializers;
        canReflect.eachKey(result.definitions, function (definition, property) {
            define.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);
        });
        if (typePrototype.hasOwnProperty('_data')) {
            for (prop in dataInitializers) {
                defineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);
            }
        } else {
            defineLazyValue(typePrototype, '_data', function () {
                var map = this;
                var data = {};
                for (var prop in dataInitializers) {
                    defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);
                }
                return data;
            });
        }
        if (typePrototype.hasOwnProperty('_computed')) {
            for (prop in computedInitializers) {
                defineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));
            }
        } else {
            defineLazyValue(typePrototype, '_computed', function () {
                var map = this;
                var data = Object.create(null);
                for (var prop in computedInitializers) {
                    defineLazyValue(data, prop, computedInitializers[prop].bind(map));
                }
                return data;
            });
        }
        getEveryPropertyAndSymbol(eventsProto).forEach(function (prop) {
            Object.defineProperty(typePrototype, prop, {
                enumerable: false,
                value: eventsProto[prop],
                configurable: true,
                writable: true
            });
        });
        Object.defineProperty(typePrototype, '_define', {
            enumerable: false,
            value: result,
            configurable: true,
            writable: true
        });
        var iteratorSymbol = canSymbol.iterator || canSymbol.for('iterator');
        if (!typePrototype[iteratorSymbol]) {
            defineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function () {
                return new define.Iterator(this);
            });
        }
        return result;
    };
    var onlyType = function (obj) {
        for (var prop in obj) {
            if (prop !== 'type') {
                return false;
            }
        }
        return true;
    };
    define.extensions = function () {
    };
    define.property = function (typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {
        var propertyDefinition = define.extensions.apply(this, arguments);
        if (propertyDefinition) {
            definition = makeDefinition(prop, propertyDefinition, defaultDefinition || {}, typePrototype);
        }
        var type = definition.type;
        if (type && onlyType(definition) && type === define.types['*']) {
            Object_defineNamedPrototypeProperty(typePrototype, prop, {
                get: make.get.data(prop),
                set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
                enumerable: true,
                configurable: true
            });
            return;
        }
        definition.type = type;
        var dataProperty = definition.get || isValueResolver(definition) ? 'computed' : 'data', reader = make.read[dataProperty](prop), getter = make.get[dataProperty](prop), setter = make.set[dataProperty](prop), getInitialValue;
        var typeConvert = function (val) {
            return val;
        };
        if (definition.Type) {
            typeConvert = make.set.Type(prop, definition.Type, typeConvert);
        }
        if (type) {
            typeConvert = make.set.type(prop, type, typeConvert);
        }
        var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
        if (isValueResolver(definition)) {
            computedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);
        } else if (definition.default !== undefined || definition.Default !== undefined) {
            getInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
        }
        if (definition.get) {
            computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
        } else if (getInitialValue) {
            dataInitializers[prop] = getInitialValue;
        }
        if (definition.get && definition.set) {
            setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
            if (definition.get.length === 0) {
            }
        } else if (definition.set) {
            setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
        } else if (dataProperty === 'data') {
            setter = eventsSetter;
        } else if (definition.get && definition.get.length < 1) {
            setter = function () {
            };
        }
        if (type) {
            setter = make.set.type(prop, type, setter);
        }
        if (definition.Type) {
            setter = make.set.Type(prop, definition.Type, setter);
        }
        Object_defineNamedPrototypeProperty(typePrototype, prop, {
            get: getter,
            set: setter,
            enumerable: 'serialize' in definition ? !!definition.serialize : !definition.get,
            configurable: true
        });
    };
    define.makeDefineInstanceKey = function (constructor) {
        constructor[canSymbol.for('can.defineInstanceKey')] = function (property, value) {
            var defineResult = this.prototype._define;
            if (typeof value === 'object') {
                cleanUpDefinition(property, value, false, this);
            }
            var definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition, this);
            if (definition && typeof definition === 'object') {
                define.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);
                defineResult.definitions[property] = definition;
            } else {
                defineResult.methods[property] = definition;
            }
            this.prototype.dispatch({
                action: 'can.keys',
                type: 'can.keys',
                target: this.prototype
            });
        };
    };
    define.Constructor = function (defines, sealed) {
        var constructor = function DefineConstructor(props) {
            Object.defineProperty(this, inSetupSymbol, {
                configurable: true,
                enumerable: false,
                value: true,
                writable: true
            });
            define.setup.call(this, props, sealed);
            this[inSetupSymbol] = false;
        };
        var result = define(constructor.prototype, defines);
        addTypeEvents(constructor);
        define.makeDefineInstanceKey(constructor, result);
        return constructor;
    };
    make = {
        computeObj: function (map, prop, observable) {
            var computeObj = {
                oldValue: undefined,
                compute: observable,
                count: 0,
                handler: function (newVal) {
                    var oldValue = computeObj.oldValue;
                    computeObj.oldValue = newVal;
                    map.dispatch({
                        action: 'set',
                        key: 'prop',
                        target: map,
                        value: newVal,
                        oldValue: oldValue,
                        type: prop
                    }, [
                        newVal,
                        oldValue
                    ]);
                }
            };
            return computeObj;
        },
        valueResolver: function (prop, definition, typeConvert) {
            var getDefault = make.get.defaultValue(prop, definition, typeConvert);
            return function () {
                var map = this;
                var defaultValue = getDefault.call(this);
                var computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map, defaultValue));
                return computeObj;
            };
        },
        compute: function (prop, get, defaultValueFn) {
            return function () {
                var map = this, defaultValue = defaultValueFn && defaultValueFn.call(this), observable, computeObj;
                if (get.length === 0) {
                    observable = new Observation(get, map);
                } else if (get.length === 1) {
                    observable = new SettableObservable(get, map, defaultValue);
                } else {
                    observable = new AsyncObservable(get, map, defaultValue);
                }
                computeObj = make.computeObj(map, prop, observable);
                return computeObj;
            };
        },
        set: {
            data: function (prop) {
                return function (newVal) {
                    this._data[prop] = newVal;
                };
            },
            computed: function (prop) {
                return function (val) {
                    canReflect.setValue(this._computed[prop].compute, val);
                };
            },
            events: function (prop, getCurrent, setData, eventType) {
                return function (newVal) {
                    if (this[inSetupSymbol]) {
                        setData.call(this, newVal);
                    } else {
                        var current = getCurrent.call(this);
                        if (newVal === current) {
                            return;
                        }
                        var dispatched;
                        setData.call(this, newVal);
                        dispatched = {
                            patches: [{
                                    type: 'set',
                                    key: prop,
                                    value: newVal
                                }],
                            target: this,
                            action: 'set',
                            value: newVal,
                            oldValue: current,
                            key: prop,
                            type: prop
                        };
                        this.dispatch(dispatched, [
                            newVal,
                            current
                        ]);
                    }
                };
            },
            setter: function (prop, setter, getCurrent, setEvents, hasGetter) {
                return function (value) {
                    var self = this;
                    queues.batch.start();
                    var setterCalled = false, current = getCurrent.call(this), setValue = setter.call(this, value, function (value) {
                            setEvents.call(self, value);
                            setterCalled = true;
                        }, current);
                    if (setterCalled) {
                        queues.batch.stop();
                    } else {
                        if (hasGetter) {
                            if (setValue !== undefined) {
                                if (current !== setValue) {
                                    setEvents.call(this, setValue);
                                }
                                queues.batch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                queues.batch.stop();
                                return;
                            } else if (setter.length === 1) {
                                queues.batch.stop();
                            } else {
                                queues.batch.stop();
                                return;
                            }
                        } else {
                            if (setValue !== undefined) {
                                setEvents.call(this, setValue);
                                queues.batch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                queues.batch.stop();
                                return;
                            } else if (setter.length === 1) {
                                setEvents.call(this, undefined);
                                queues.batch.stop();
                            } else {
                                queues.batch.stop();
                                return;
                            }
                        }
                    }
                };
            },
            type: function (prop, type, set) {
                function setter(newValue) {
                    return set.call(this, type.call(this, newValue, prop));
                }
                if (isDefineType(type)) {
                    if (type.canDefineType) {
                        return setter;
                    } else {
                        return function setter(newValue) {
                            return set.call(this, canReflect.convert(newValue, type));
                        };
                    }
                }
                if (typeof type === 'object') {
                    return make.set.Type(prop, type, set);
                } else {
                    return setter;
                }
            },
            Type: function (prop, Type, set) {
                if (Array.isArray(Type) && define.DefineList) {
                    Type = define.DefineList.extend({ '#': Type[0] });
                } else if (typeof Type === 'object') {
                    if (define.DefineMap) {
                        Type = define.DefineMap.extend(Type);
                    } else {
                        Type = define.Constructor(Type);
                    }
                }
                return function (newValue) {
                    if (newValue instanceof Type || newValue == null) {
                        return set.call(this, newValue);
                    } else {
                        return set.call(this, new Type(newValue));
                    }
                };
            }
        },
        eventType: {
            data: function (prop) {
                return function (newVal, oldVal) {
                    return oldVal !== undefined || this._data.hasOwnProperty(prop) ? 'set' : 'add';
                };
            },
            computed: function () {
                return function () {
                    return 'set';
                };
            }
        },
        read: {
            data: function (prop) {
                return function () {
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            },
            lastSet: function (prop) {
                return function () {
                    var observable = this._computed[prop].compute;
                    if (observable.lastSetValue) {
                        return canReflect.getValue(observable.lastSetValue);
                    }
                };
            }
        },
        get: {
            defaultValue: function (prop, definition, typeConvert, callSetter) {
                return function () {
                    var value = definition.default;
                    if (value !== undefined) {
                        if (typeof value === 'function') {
                            value = value.call(this);
                        }
                        value = typeConvert.call(this, value);
                    } else {
                        var Default = definition.Default;
                        if (Default) {
                            value = typeConvert.call(this, new Default());
                        }
                    }
                    if (definition.set) {
                        var VALUE;
                        var sync = true;
                        var setter = make.set.setter(prop, definition.set, function () {
                        }, function (value) {
                            if (sync) {
                                VALUE = value;
                            } else {
                                callSetter.call(this, value);
                            }
                        }, definition.get);
                        setter.call(this, value);
                        sync = false;
                        return VALUE;
                    }
                    return value;
                };
            },
            data: function (prop) {
                return function () {
                    if (!this[inSetupSymbol]) {
                        ObservationRecorder.add(this, prop);
                    }
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function (val) {
                    var compute = this._computed[prop].compute;
                    if (ObservationRecorder.isRecording()) {
                        ObservationRecorder.add(this, prop);
                        if (!canReflect.isBound(compute)) {
                            Observation.temporarilyBind(compute);
                        }
                    }
                    return peek(compute);
                };
            }
        }
    };
    define.behaviors = [
        'get',
        'set',
        'value',
        'Value',
        'type',
        'Type',
        'serialize'
    ];
    var addBehaviorToDefinition = function (definition, behavior, value) {
        if (behavior === 'enumerable') {
            definition.serialize = !!value;
        } else if (behavior === 'type') {
            var behaviorDef = value;
            if (typeof behaviorDef === 'string') {
                behaviorDef = define.types[behaviorDef];
                if (typeof behaviorDef === 'object' && !isDefineType(behaviorDef)) {
                    assign(definition, behaviorDef);
                    behaviorDef = behaviorDef[behavior];
                }
            }
            if (typeof behaviorDef !== 'undefined') {
                definition[behavior] = behaviorDef;
            }
        } else {
            definition[behavior] = value;
        }
    };
    makeDefinition = function (prop, def, defaultDefinition, typePrototype) {
        var definition = {};
        canReflect.eachKey(def, function (value, behavior) {
            addBehaviorToDefinition(definition, behavior, value);
        });
        canReflect.eachKey(defaultDefinition, function (value, prop) {
            if (definition[prop] === undefined) {
                if (prop !== 'type' && prop !== 'Type') {
                    definition[prop] = value;
                }
            }
        });
        if (def.Type) {
            var value = def.Type;
            var serialize = value[serializeSymbol];
            if (serialize) {
                definition.serialize = function (val) {
                    return serialize.call(val);
                };
            }
            if (value[newSymbol]) {
                definition.type = value;
                delete definition.Type;
            }
        }
        if (typeof def.type !== 'string') {
            if (!definition.type && !definition.Type) {
                var defaultsCopy = canReflect.assignMap({}, defaultDefinition);
                definition = canReflect.assignMap(defaultsCopy, definition);
            }
            if (canReflect.size(definition) === 0) {
                definition.type = define.types['*'];
            }
        }
        cleanUpDefinition(prop, definition, true, typePrototype);
        return definition;
    };
    getDefinitionOrMethod = function (prop, value, defaultDefinition, typePrototype) {
        var definition;
        if (typeof value === 'string') {
            definition = { type: value };
        } else if (value && (value[serializeSymbol] || value[newSymbol])) {
            definition = { Type: value };
        } else if (typeof value === 'function') {
            if (canReflect.isConstructorLike(value)) {
                definition = { Type: value };
            }
        } else if (Array.isArray(value)) {
            definition = { Type: value };
        } else if (canReflect.isPlainObject(value)) {
            definition = value;
        }
        if (definition) {
            return makeDefinition(prop, definition, defaultDefinition, typePrototype);
        } else {
            return value;
        }
    };
    getDefinitionsAndMethods = function (defines, baseDefines, typePrototype) {
        var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
        var methods = {};
        var defaults = defines['*'], defaultDefinition;
        if (defaults) {
            delete defines['*'];
            defaultDefinition = getDefinitionOrMethod('*', defaults, {});
        } else {
            defaultDefinition = Object.create(null);
        }
        eachPropertyDescriptor(defines, function (prop, propertyDescriptor) {
            var value;
            if (propertyDescriptor.get || propertyDescriptor.set) {
                value = {
                    get: propertyDescriptor.get,
                    set: propertyDescriptor.set
                };
            } else {
                value = propertyDescriptor.value;
            }
            if (prop === 'constructor') {
                methods[prop] = value;
                return;
            } else {
                var result = getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype);
                if (result && typeof result === 'object' && canReflect.size(result) > 0) {
                    definitions[prop] = result;
                } else {
                    if (typeof result === 'function') {
                        methods[prop] = result;
                    }
                }
            }
        });
        if (defaults) {
            defineConfigurableAndNotEnumerable(defines, '*', defaults);
        }
        return {
            definitions: definitions,
            methods: methods,
            defaultDefinition: defaultDefinition
        };
    };
    eventsProto = eventQueue({});
    function setupComputed(instance, eventName) {
        var computedBinding = instance._computed && instance._computed[eventName];
        if (computedBinding && computedBinding.compute) {
            if (!computedBinding.count) {
                computedBinding.count = 1;
                canReflect.onValue(computedBinding.compute, computedBinding.handler, 'notify');
                computedBinding.oldValue = peek(computedBinding.compute);
            } else {
                computedBinding.count++;
            }
        }
    }
    function teardownComputed(instance, eventName) {
        var computedBinding = instance._computed && instance._computed[eventName];
        if (computedBinding) {
            if (computedBinding.count === 1) {
                computedBinding.count = 0;
                canReflect.offValue(computedBinding.compute, computedBinding.handler, 'notify');
            } else {
                computedBinding.count--;
            }
        }
    }
    var canMetaSymbol = canSymbol.for('can.meta');
    assign(eventsProto, {
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        addEventListener: function (eventName, handler, queue) {
            setupComputed(this, eventName);
            return eventQueue.addEventListener.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            teardownComputed(this, eventName);
            return eventQueue.removeEventListener.apply(this, arguments);
        }
    });
    eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
    eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
    var onKeyValueSymbol = canSymbol.for('can.onKeyValue');
    var offKeyValueSymbol = canSymbol.for('can.offKeyValue');
    canReflect.assignSymbols(eventsProto, {
        'can.onKeyValue': function (key) {
            setupComputed(this, key);
            return eventQueue[onKeyValueSymbol].apply(this, arguments);
        },
        'can.offKeyValue': function (key) {
            teardownComputed(this, key);
            return eventQueue[offKeyValueSymbol].apply(this, arguments);
        }
    });
    delete eventsProto.one;
    define.setup = function (props, sealed) {
        Object.defineProperty(this, 'constructor', {
            value: this.constructor,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, canMetaSymbol, {
            value: Object.create(null),
            enumerable: false,
            writable: false
        });
        var definitions = this._define.definitions;
        var instanceDefinitions = Object.create(null);
        var map = this;
        canReflect.eachKey(props, function (value, prop) {
            if (definitions[prop] !== undefined) {
                map[prop] = value;
            } else {
                define.expando(map, prop, value);
            }
        });
        if (canReflect.size(instanceDefinitions) > 0) {
            defineConfigurableAndNotEnumerable(this, '_instanceDefinitions', instanceDefinitions);
        }
    };
    var returnFirstArg = function (arg) {
        return arg;
    };
    define.expando = function (map, prop, value) {
        if (define._specialKeys[prop]) {
            return true;
        }
        var constructorDefines = map._define.definitions;
        if (constructorDefines && constructorDefines[prop]) {
            return;
        }
        var instanceDefines = map._instanceDefinitions;
        if (!instanceDefines) {
            if (Object.isSealed(map)) {
                return;
            }
            Object.defineProperty(map, '_instanceDefinitions', {
                configurable: true,
                enumerable: false,
                writable: true,
                value: {}
            });
            instanceDefines = map._instanceDefinitions;
        }
        if (!instanceDefines[prop]) {
            var defaultDefinition = map._define.defaultDefinition || { type: define.types.observable };
            define.property(map, prop, defaultDefinition, {}, {});
            if (defaultDefinition.type) {
                map._data[prop] = define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);
            } else if (defaultDefinition.Type && canReflect.isConstructorLike(defaultDefinition.Type)) {
                map._data[prop] = define.make.set.Type(prop, defaultDefinition.Type, returnFirstArg).call(map, value);
            } else {
                map._data[prop] = define.types.observable(value);
            }
            instanceDefines[prop] = defaultDefinition;
            if (!map[inSetupSymbol]) {
                queues.batch.start();
                map.dispatch({
                    action: 'can.keys',
                    target: map,
                    type: 'can.keys'
                });
                if (Object.prototype.hasOwnProperty.call(map._data, prop)) {
                    map.dispatch({
                        action: 'add',
                        target: map,
                        value: map._data[prop],
                        oldValue: undefined,
                        key: prop,
                        type: prop,
                        patches: [{
                                type: 'add',
                                key: prop,
                                value: map._data[prop]
                            }]
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                } else {
                    map.dispatch({
                        type: 'set',
                        target: map,
                        patches: [{
                                type: 'add',
                                key: prop,
                                value: map._data[prop]
                            }]
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                }
                queues.batch.stop();
            }
            return true;
        }
    };
    define.replaceWith = defineLazyValue;
    define.eventsProto = eventsProto;
    define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
    define.make = make;
    define.getDefinitionOrMethod = getDefinitionOrMethod;
    define._specialKeys = {
        _data: true,
        _computed: true
    };
    var simpleGetterSetters = {};
    define.makeSimpleGetterSetter = function (prop) {
        if (simpleGetterSetters[prop] === undefined) {
            var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
            simpleGetterSetters[prop] = {
                get: make.get.data(prop),
                set: function (newVal) {
                    return setter.call(this, define.types.observable(newVal));
                },
                enumerable: true,
                configurable: true
            };
        }
        return simpleGetterSetters[prop];
    };
    define.Iterator = function (obj) {
        this.obj = obj;
        this.definitions = Object.keys(obj._define.definitions);
        this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
        this.hasGet = typeof obj.get === 'function';
    };
    define.Iterator.prototype.next = function () {
        var key;
        if (this.definitions.length) {
            key = this.definitions.shift();
            var def = this.obj._define.definitions[key];
            if (def.get) {
                return this.next();
            }
        } else if (this.instanceDefinitions.length) {
            key = this.instanceDefinitions.shift();
        } else {
            return {
                value: undefined,
                done: true
            };
        }
        return {
            value: [
                key,
                this.hasGet ? this.obj.get(key) : this.obj[key]
            ],
            done: false
        };
    };
    function isObservableValue(obj) {
        return canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);
    }
    define.types = {
        'date': MaybeDate,
        'number': MaybeNumber,
        'boolean': MaybeBoolean,
        'observable': function (newVal) {
            if (Array.isArray(newVal) && define.DefineList) {
                newVal = new define.DefineList(newVal);
            } else if (canReflect.isPlainObject(newVal) && define.DefineMap) {
                newVal = new define.DefineMap(newVal);
            }
            return newVal;
        },
        'stringOrObservable': function (newVal) {
            if (Array.isArray(newVal)) {
                return new define.DefaultList(newVal);
            } else if (canReflect.isPlainObject(newVal)) {
                return new define.DefaultMap(newVal);
            } else {
                return canReflect.convert(newVal, define.types.string);
            }
        },
        'htmlbool': function (val) {
            if (val === '') {
                return true;
            }
            return !!stringToAny(val);
        },
        '*': function (val) {
            return val;
        },
        'any': function (val) {
            return val;
        },
        'string': MaybeString,
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (isObservableValue(newValue)) {
                    return newValue;
                }
                if (isObservableValue(oldValue)) {
                    canReflect.setValue(oldValue, newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return isObservableValue(value) ? canReflect.getValue(value) : value;
            }
        }
    };
    define.updateSchemaKeys = function (schema, definitions) {
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (definition.serialize !== false) {
                if (definition.Type) {
                    schema.keys[prop] = definition.Type;
                } else if (definition.type) {
                    schema.keys[prop] = definition.type;
                } else {
                    schema.keys[prop] = function (val) {
                        return val;
                    };
                }
                if (definitions[prop].identity === true) {
                    schema.identity.push(prop);
                }
            }
        }
        return schema;
    };
});
/*can-define@2.8.0#ensure-meta*/
define('can-define@2.8.0#ensure-meta', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
});
/*can-define@2.8.0#define-helpers/define-helpers*/
define('can-define@2.8.0#define-helpers/define-helpers', [
    'require',
    'exports',
    'module',
    'can-define',
    'can-reflect',
    'can-queues',
    'can-log/dev/dev',
    '../ensure-meta'
], function (require, exports, module) {
    'use strict';
    var define = require('can-define');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var dev = require('can-log/dev/dev');
    var ensureMeta = require('../ensure-meta');
    var defineHelpers = {
        defineExpando: define.expando,
        reflectSerialize: function (unwrapped) {
            var constructorDefinitions = this._define.definitions;
            var defaultDefinition = this._define.defaultDefinition;
            this.forEach(function (val, name) {
                var propDef = constructorDefinitions[name];
                if (propDef && typeof propDef.serialize === 'function') {
                    val = propDef.serialize.call(this, val, name);
                } else if (defaultDefinition && typeof defaultDefinition.serialize === 'function') {
                    val = defaultDefinition.serialize.call(this, val, name);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.forEach(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        },
        log: function (key) {
            var instance = this;
            var quoteString = function quoteString(x) {
                return typeof x === 'string' ? JSON.stringify(x) : x;
            };
            var meta = ensureMeta(instance);
            var allowed = meta.allowedLogKeysSet || new Set();
            meta.allowedLogKeysSet = allowed;
            if (key) {
                allowed.add(key);
            }
            meta._log = function (event, data) {
                var type = event.type;
                if (type === 'can.onPatches' || key && !allowed.has(type) || type === 'can.keys' || key && !allowed.has(type)) {
                    return;
                }
                if (type === 'add' || type === 'remove') {
                    dev.log(canReflect.getName(instance), '\n how   ', quoteString(type), '\n what  ', quoteString(data[0]), '\n index ', quoteString(data[1]));
                } else {
                    dev.log(canReflect.getName(instance), '\n key ', quoteString(type), '\n is  ', quoteString(data[0]), '\n was ', quoteString(data[1]));
                }
            };
        },
        deleteKey: function (prop) {
            var instanceDefines = this._instanceDefinitions;
            if (instanceDefines && Object.prototype.hasOwnProperty.call(instanceDefines, prop) && !Object.isSealed(this)) {
                delete instanceDefines[prop];
                queues.batch.start();
                this.dispatch({
                    action: 'can.keys',
                    type: 'can.keys',
                    target: this
                });
                var oldValue = this._data[prop];
                if (oldValue !== undefined) {
                    delete this._data[prop];
                    this.dispatch({
                        action: 'delete',
                        key: prop,
                        value: undefined,
                        oldValue: oldValue,
                        type: prop,
                        target: this,
                        patches: [{
                                type: 'delete',
                                key: prop
                            }]
                    }, [
                        undefined,
                        oldValue
                    ]);
                }
                queues.batch.stop();
            } else {
                this.set(prop, undefined);
            }
            return this;
        }
    };
    module.exports = defineHelpers;
});
/*can-define@2.8.0#map/map*/
define('can-define@2.8.0#map/map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    '../define-helpers/define-helpers',
    'can-observation-recorder',
    'can-namespace',
    'can-log',
    'can-log/dev/dev',
    'can-reflect',
    'can-symbol',
    'can-queues',
    'can-event-queue/type/type'
], function (require, exports, module) {
    'use strict';
    var Construct = require('can-construct');
    var define = require('can-define');
    var defineHelpers = require('../define-helpers/define-helpers');
    var ObservationRecorder = require('can-observation-recorder');
    var ns = require('can-namespace');
    var canLog = require('can-log');
    var canLogDev = require('can-log/dev/dev');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var queues = require('can-queues');
    var addTypeEvents = require('can-event-queue/type/type');
    var keysForDefinition = function (definitions) {
        var keys = [];
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (typeof definition !== 'object' || ('serialize' in definition ? !!definition.serialize : !definition.get)) {
                keys.push(prop);
            }
        }
        return keys;
    };
    function assign(source) {
        queues.batch.start();
        canReflect.assignMap(this, source || {});
        queues.batch.stop();
    }
    function update(source) {
        queues.batch.start();
        canReflect.updateMap(this, source || {});
        queues.batch.stop();
    }
    function assignDeep(source) {
        queues.batch.start();
        canReflect.assignDeepMap(this, source || {});
        queues.batch.stop();
    }
    function updateDeep(source) {
        queues.batch.start();
        canReflect.updateDeepMap(this, source || {});
        queues.batch.stop();
    }
    function setKeyValue(key, value) {
        var defined = defineHelpers.defineExpando(this, key, value);
        if (!defined) {
            this[key] = value;
        }
    }
    function getKeyValue(key) {
        var value = this[key];
        if (value !== undefined || key in this || Object.isSealed(this)) {
            return value;
        } else {
            ObservationRecorder.add(this, key);
            return this[key];
        }
    }
    var getSchemaSymbol = canSymbol.for('can.getSchema');
    function getSchema() {
        var def = this.prototype._define;
        var definitions = def ? def.definitions : {};
        var schema = {
            type: 'map',
            identity: [],
            keys: {}
        };
        return define.updateSchemaKeys(schema, definitions);
    }
    var sealedSetup = function (props) {
        define.setup.call(this, props || {}, this.constructor.seal);
    };
    var DefineMap = Construct.extend('DefineMap', {
        setup: function (base) {
            var key, prototype = this.prototype;
            if (DefineMap) {
                var result = define(prototype, prototype, base.prototype._define);
                define.makeDefineInstanceKey(this, result);
                addTypeEvents(this);
                for (key in DefineMap.prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
                if (prototype.setup === DefineMap.prototype.setup) {
                    define.defineConfigurableAndNotEnumerable(prototype, 'setup', sealedSetup);
                }
                var _computedGetter = Object.getOwnPropertyDescriptor(prototype, '_computed').get;
                Object.defineProperty(prototype, '_computed', {
                    configurable: true,
                    enumerable: false,
                    get: function () {
                        if (this === prototype) {
                            return;
                        }
                        return _computedGetter.call(this, arguments);
                    }
                });
            } else {
                for (key in prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
            }
            define.defineConfigurableAndNotEnumerable(prototype, 'constructor', this);
            this[getSchemaSymbol] = getSchema;
        }
    }, {
        setup: function (props, sealed) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, props || {}, sealed === true);
        },
        get: function (prop) {
            if (prop) {
                return getKeyValue.call(this, prop);
            } else {
                return canReflect.unwrap(this, Map);
            }
        },
        set: function (prop, value) {
            if (typeof prop === 'object') {
                if (value === true) {
                    updateDeep.call(this, prop);
                } else {
                    assignDeep.call(this, prop);
                }
            } else {
                setKeyValue.call(this, prop, value);
            }
            return this;
        },
        assignDeep: function (prop) {
            assignDeep.call(this, prop);
            return this;
        },
        updateDeep: function (prop) {
            updateDeep.call(this, prop);
            return this;
        },
        assign: function (prop) {
            assign.call(this, prop);
            return this;
        },
        update: function (prop) {
            update.call(this, prop);
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        },
        deleteKey: defineHelpers.deleteKey,
        forEach: function () {
            var forEach = function (list, cb, thisarg) {
                    return canReflect.eachKey(list, cb, thisarg);
                }, noObserve = ObservationRecorder.ignore(forEach);
            return function (cb, thisarg, observe) {
                return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
            };
        }(),
        '*': { type: define.types.observable }
    });
    var defineMapProto = {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': getKeyValue,
        'can.setKeyValue': setKeyValue,
        'can.deleteKeyValue': defineHelpers.deleteKey,
        'can.getOwnKeys': function () {
            var keys = canReflect.getOwnEnumerableKeys(this);
            if (this._computed) {
                var computedKeys = canReflect.getOwnKeys(this._computed);
                var key;
                for (var i = 0; i < computedKeys.length; i++) {
                    key = computedKeys[i];
                    if (keys.indexOf(key) < 0) {
                        keys.push(key);
                    }
                }
            }
            return keys;
        },
        'can.getOwnEnumerableKeys': function () {
            ObservationRecorder.add(this, 'can.keys');
            ObservationRecorder.add(Object.getPrototypeOf(this), 'can.keys');
            return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));
        },
        'can.hasOwnKey': function (key) {
            return Object.hasOwnProperty.call(this._define.definitions, key) || this._instanceDefinitions !== undefined && Object.hasOwnProperty.call(this._instanceDefinitions, key);
        },
        'can.hasKey': function (key) {
            return key in this._define.definitions || this._instanceDefinitions !== undefined && key in this._instanceDefinitions;
        },
        'can.assignDeep': assignDeep,
        'can.updateDeep': updateDeep,
        'can.unwrap': defineHelpers.reflectUnwrap,
        'can.serialize': defineHelpers.reflectSerialize,
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new Set();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        }
    };
    canReflect.assignSymbols(DefineMap.prototype, defineMapProto);
    canReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function () {
        return new define.Iterator(this);
    });
    for (var prop in define.eventsProto) {
        DefineMap[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineMap.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    function getSymbolsForIE(obj) {
        return Object.getOwnPropertyNames(obj).filter(function (name) {
            return name.indexOf('@@symbol') === 0;
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : getSymbolsForIE(define.eventsProto);
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineMap.prototype, sym, {
            configurable: true,
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    define.DefineMap = DefineMap;
    Object.defineProperty(DefineMap.prototype, 'toObject', {
        enumerable: false,
        writable: true,
        value: function () {
            canLog.warn('Use DefineMap::get instead of DefineMap::toObject');
            return this.get();
        }
    });
    module.exports = ns.DefineMap = DefineMap;
});
/*can-globals@1.2.2#location/location*/
define('can-globals@1.2.2#location/location', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('location', function () {
            return globals.getKeyValue('global').location;
        });
        module.exports = globals.makeExport('location');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#mutation-observer/mutation-observer*/
define('can-globals@1.2.2#mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('MutationObserver', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
        });
        module.exports = globals.makeExport('MutationObserver');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#custom-elements/custom-elements*/
define('can-globals@1.2.2#custom-elements/custom-elements', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('customElements', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.customElements;
        });
        module.exports = globals.makeExport('customElements');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#can-globals*/
define('can-globals@1.2.2#can-globals', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    './global/global',
    './document/document',
    './location/location',
    './mutation-observer/mutation-observer',
    './is-browser-window/is-browser-window',
    './is-node/is-node',
    './custom-elements/custom-elements'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('./global/global');
        require('./document/document');
        require('./location/location');
        require('./mutation-observer/mutation-observer');
        require('./is-browser-window/is-browser-window');
        require('./is-node/is-node');
        require('./custom-elements/custom-elements');
        module.exports = globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-debug@2.0.7#src/proxy-namespace*/
define('can-debug@2.0.7#src/proxy-namespace', function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var warned = false;
        module.exports = function proxyNamespace(namespace) {
            return new Proxy(namespace, {
                get: function get(target, name) {
                    if (!warned) {
                        console.warn('Warning: use of \'can\' global should be for debugging purposes only.');
                        warned = true;
                    }
                    return target[name];
                }
            });
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-debug@2.0.7#src/temporarily-bind*/
define('can-debug@2.0.7#src/temporarily-bind', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var onValueSymbol = canSymbol.for('can.onValue');
    var offValueSymbol = canSymbol.for('can.offValue');
    var onKeyValueSymbol = canSymbol.for('can.onKeyValue');
    var offKeyValueSymbol = canSymbol.for('can.offKeyValue');
    var noop = function noop() {
    };
    function isFunction(value) {
        return typeof value === 'function';
    }
    function withKey(obj, key, fn) {
        var result;
        if (isFunction(obj[onKeyValueSymbol])) {
            canReflect.onKeyValue(obj, key, noop);
        }
        result = fn(obj, key);
        if (isFunction(obj[offKeyValueSymbol])) {
            canReflect.offKeyValue(obj, key, noop);
        }
        return result;
    }
    function withoutKey(obj, fn) {
        var result;
        if (isFunction(obj[onValueSymbol])) {
            canReflect.onValue(obj, noop);
        }
        result = fn(obj);
        if (isFunction(obj[offValueSymbol])) {
            canReflect.offValue(obj, noop);
        }
        return result;
    }
    module.exports = function temporarilyBind(fn) {
        return function (obj, key) {
            var gotKey = arguments.length === 2;
            return gotKey ? withKey(obj, key, fn) : withoutKey(obj, fn);
        };
    };
});
/*can-debug@2.0.7#src/graph/graph*/
define('can-debug@2.0.7#src/graph/graph', [
    'require',
    'exports',
    'module',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var canAssign = require('can-assign');
    function Graph() {
        this.nodes = [];
        this.arrows = new Map();
        this.arrowsMeta = new Map();
    }
    Graph.prototype.addNode = function addNode(node) {
        this.nodes.push(node);
        this.arrows.set(node, new Set());
    };
    Graph.prototype.addArrow = function addArrow(head, tail, meta) {
        var graph = this;
        graph.arrows.get(head).add(tail);
        if (meta) {
            addArrowMeta(graph, head, tail, meta);
        }
    };
    Graph.prototype.hasArrow = function hasArrow(head, tail) {
        return this.getNeighbors(head).has(tail);
    };
    Graph.prototype.getArrowMeta = function getArrowMeta(head, tail) {
        return this.arrowsMeta.get(head) && this.arrowsMeta.get(head).get(tail);
    };
    Graph.prototype.setArrowMeta = function setArrowMeta(head, tail, meta) {
        addArrowMeta(this, head, tail, meta);
    };
    Graph.prototype.getNeighbors = function getNeighbors(node) {
        return this.arrows.get(node);
    };
    Graph.prototype.findNode = function findNode(cb) {
        var found = null;
        var graph = this;
        var i, node;
        for (i = 0; i < graph.nodes.length; i++) {
            node = graph.nodes[i];
            if (cb(node)) {
                found = node;
                break;
            }
        }
        return found;
    };
    Graph.prototype.bfs = function bfs(visit) {
        var graph = this;
        var node = graph.nodes[0];
        var queue = [node];
        var visited = new Map();
        visited.set(node, true);
        while (queue.length) {
            node = queue.shift();
            visit(node);
            graph.arrows.get(node).forEach(function (adj) {
                if (!visited.has(adj)) {
                    queue.push(adj);
                    visited.set(adj, true);
                }
            });
        }
    };
    Graph.prototype.dfs = function dfs(visit) {
        var graph = this;
        var node = graph.nodes[0];
        var stack = [node];
        var visited = new Map();
        while (stack.length) {
            node = stack.pop();
            visit(node);
            if (!visited.has(node)) {
                visited.set(node, true);
                graph.arrows.get(node).forEach(function (adj) {
                    stack.push(adj);
                });
            }
        }
    };
    Graph.prototype.reverse = function reverse() {
        var graph = this;
        var reversed = new Graph();
        graph.nodes.forEach(reversed.addNode.bind(reversed));
        graph.nodes.forEach(function (node) {
            graph.getNeighbors(node).forEach(function (adj) {
                var meta = graph.getArrowMeta(node, adj);
                reversed.addArrow(adj, node, meta);
            });
        });
        return reversed;
    };
    function addArrowMeta(graph, head, tail, meta) {
        var entry = graph.arrowsMeta.get(head);
        if (entry) {
            var arrowMeta = entry.get(tail);
            if (!arrowMeta) {
                arrowMeta = {};
            }
            entry.set(tail, canAssign(arrowMeta, meta));
        } else {
            entry = new Map();
            entry.set(tail, meta);
            graph.arrowsMeta.set(head, entry);
        }
    }
    module.exports = Graph;
});
/*can-debug@2.0.7#src/get-graph/make-node*/
define('can-debug@2.0.7#src/get-graph/make-node', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    module.exports = function makeNode(obj, key) {
        var gotKey = arguments.length === 2;
        var node = {
            obj: obj,
            name: canReflect.getName(obj),
            value: gotKey ? canReflect.getKeyValue(obj, key) : canReflect.getValue(obj)
        };
        if (gotKey) {
            node.key = key;
        }
        return node;
    };
});
/*can-reflect-dependencies@1.1.2#src/add-mutated-by*/
define('can-reflect-dependencies@1.1.2#src/add-mutated-by', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var makeDependencyRecord = function makeDependencyRecord() {
        return {
            keyDependencies: new Map(),
            valueDependencies: new Set()
        };
    };
    var makeRootRecord = function makeRootRecord() {
        return {
            mutateDependenciesForKey: new Map(),
            mutateDependenciesForValue: makeDependencyRecord()
        };
    };
    module.exports = function (mutatedByMap) {
        return function addMutatedBy(mutated, key, mutator) {
            var gotKey = arguments.length === 3;
            if (arguments.length === 2) {
                mutator = key;
                key = undefined;
            }
            if (!mutator.keyDependencies && !mutator.valueDependencies) {
                var s = new Set();
                s.add(mutator);
                mutator = { valueDependencies: s };
            }
            var root = mutatedByMap.get(mutated);
            if (!root) {
                root = makeRootRecord();
                mutatedByMap.set(mutated, root);
            }
            if (gotKey && !root.mutateDependenciesForKey.get(key)) {
                root.mutateDependenciesForKey.set(key, makeDependencyRecord());
            }
            var dependencyRecord = gotKey ? root.mutateDependenciesForKey.get(key) : root.mutateDependenciesForValue;
            if (mutator.valueDependencies) {
                canReflect.addValues(dependencyRecord.valueDependencies, mutator.valueDependencies);
            }
            if (mutator.keyDependencies) {
                canReflect.each(mutator.keyDependencies, function (keysSet, obj) {
                    var entry = dependencyRecord.keyDependencies.get(obj);
                    if (!entry) {
                        entry = new Set();
                        dependencyRecord.keyDependencies.set(obj, entry);
                    }
                    canReflect.addValues(entry, keysSet);
                });
            }
        };
    };
});
/*can-reflect-dependencies@1.1.2#src/delete-mutated-by*/
define('can-reflect-dependencies@1.1.2#src/delete-mutated-by', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    module.exports = function (mutatedByMap) {
        return function deleteMutatedBy(mutated, key, mutator) {
            var gotKey = arguments.length === 3;
            var root = mutatedByMap.get(mutated);
            if (arguments.length === 2) {
                mutator = key;
                key = undefined;
            }
            if (!mutator.keyDependencies && !mutator.valueDependencies) {
                var s = new Set();
                s.add(mutator);
                mutator = { valueDependencies: s };
            }
            var dependencyRecord = gotKey ? root.mutateDependenciesForKey.get(key) : root.mutateDependenciesForValue;
            if (mutator.valueDependencies) {
                canReflect.removeValues(dependencyRecord.valueDependencies, mutator.valueDependencies);
            }
            if (mutator.keyDependencies) {
                canReflect.each(mutator.keyDependencies, function (keysSet, obj) {
                    var entry = dependencyRecord.keyDependencies.get(obj);
                    if (entry) {
                        canReflect.removeValues(entry, keysSet);
                        if (!entry.size) {
                            dependencyRecord.keyDependencies.delete(obj);
                        }
                    }
                });
            }
        };
    };
});
/*can-reflect-dependencies@1.1.2#src/is-function*/
define('can-reflect-dependencies@1.1.2#src/is-function', function (require, exports, module) {
    'use strict';
    module.exports = function isFunction(value) {
        return typeof value === 'function';
    };
});
/*can-reflect-dependencies@1.1.2#src/get-dependency-data-of*/
define('can-reflect-dependencies@1.1.2#src/get-dependency-data-of', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-reflect',
    './is-function',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isFunction = require('./is-function');
    var canAssign = require('can-assign');
    var getWhatIChangeSymbol = canSymbol.for('can.getWhatIChange');
    var getKeyDependenciesSymbol = canSymbol.for('can.getKeyDependencies');
    var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
    var getKeyDependencies = function getKeyDependencies(obj, key) {
        if (isFunction(obj[getKeyDependenciesSymbol])) {
            return canReflect.getKeyDependencies(obj, key);
        }
    };
    var getValueDependencies = function getValueDependencies(obj) {
        if (isFunction(obj[getValueDependenciesSymbol])) {
            return canReflect.getValueDependencies(obj);
        }
    };
    var getMutatedKeyDependencies = function getMutatedKeyDependencies(mutatedByMap, obj, key) {
        var root = mutatedByMap.get(obj);
        var dependencyRecord;
        if (root && root.mutateDependenciesForKey.has(key)) {
            dependencyRecord = root.mutateDependenciesForKey.get(key);
        }
        return dependencyRecord;
    };
    var getMutatedValueDependencies = function getMutatedValueDependencies(mutatedByMap, obj) {
        var result;
        var root = mutatedByMap.get(obj);
        if (root) {
            var dependencyRecord = root.mutateDependenciesForValue;
            if (dependencyRecord.keyDependencies.size) {
                result = result || {};
                result.keyDependencies = dependencyRecord.keyDependencies;
            }
            if (dependencyRecord.valueDependencies.size) {
                result = result || {};
                result.valueDependencies = dependencyRecord.valueDependencies;
            }
        }
        return result;
    };
    var getWhatIChange = function getWhatIChange(obj, key) {
        if (isFunction(obj[getWhatIChangeSymbol])) {
            var gotKey = arguments.length === 2;
            return gotKey ? canReflect.getWhatIChange(obj, key) : canReflect.getWhatIChange(obj);
        }
    };
    var isEmptyRecord = function isEmptyRecord(record) {
        return record == null || !Object.keys(record).length || record.keyDependencies && !record.keyDependencies.size && (record.valueDependencies && !record.valueDependencies.size);
    };
    var getWhatChangesMe = function getWhatChangesMe(mutatedByMap, obj, key) {
        var gotKey = arguments.length === 3;
        var mutate = gotKey ? getMutatedKeyDependencies(mutatedByMap, obj, key) : getMutatedValueDependencies(mutatedByMap, obj);
        var derive = gotKey ? getKeyDependencies(obj, key) : getValueDependencies(obj);
        if (!isEmptyRecord(mutate) || !isEmptyRecord(derive)) {
            return canAssign(canAssign({}, mutate ? { mutate: mutate } : null), derive ? { derive: derive } : null);
        }
    };
    module.exports = function (mutatedByMap) {
        return function getDependencyDataOf(obj, key) {
            var gotKey = arguments.length === 2;
            var whatChangesMe = gotKey ? getWhatChangesMe(mutatedByMap, obj, key) : getWhatChangesMe(mutatedByMap, obj);
            var whatIChange = gotKey ? getWhatIChange(obj, key) : getWhatIChange(obj);
            if (whatChangesMe || whatIChange) {
                return canAssign(canAssign({}, whatIChange ? { whatIChange: whatIChange } : null), whatChangesMe ? { whatChangesMe: whatChangesMe } : null);
            }
        };
    };
});
/*can-reflect-dependencies@1.1.2#can-reflect-dependencies*/
define('can-reflect-dependencies@1.1.2#can-reflect-dependencies', [
    'require',
    'exports',
    'module',
    './src/add-mutated-by',
    './src/delete-mutated-by',
    './src/get-dependency-data-of'
], function (require, exports, module) {
    'use strict';
    var addMutatedBy = require('./src/add-mutated-by');
    var deleteMutatedBy = require('./src/delete-mutated-by');
    var getDependencyDataOf = require('./src/get-dependency-data-of');
    var mutatedByMap = new WeakMap();
    module.exports = {
        addMutatedBy: addMutatedBy(mutatedByMap),
        deleteMutatedBy: deleteMutatedBy(mutatedByMap),
        getDependencyDataOf: getDependencyDataOf(mutatedByMap)
    };
});
/*can-debug@2.0.7#src/get-graph/get-graph*/
define('can-debug@2.0.7#src/get-graph/get-graph', [
    'require',
    'exports',
    'module',
    '../graph/graph',
    './make-node',
    'can-reflect',
    'can-reflect-dependencies'
], function (require, exports, module) {
    'use strict';
    var Graph = require('../graph/graph');
    var makeNode = require('./make-node');
    var canReflect = require('can-reflect');
    var mutateDeps = require('can-reflect-dependencies');
    module.exports = function getGraph(obj, key) {
        var order = 0;
        var graph = new Graph();
        var gotKey = arguments.length === 2;
        var addArrow = function addArrow(direction, parent, child, meta) {
            switch (direction) {
            case 'whatIChange':
                graph.addArrow(parent, child, meta);
                break;
            case 'whatChangesMe':
                graph.addArrow(child, parent, meta);
                break;
            default:
                throw new Error('Unknown direction value: ', meta.direction);
            }
        };
        var visitKeyDependencies = function visitKeyDependencies(source, meta, cb) {
            canReflect.eachKey(source.keyDependencies || {}, function (keys, obj) {
                canReflect.each(keys, function (key) {
                    cb(obj, meta, key);
                });
            });
        };
        var visitValueDependencies = function visitValueDependencies(source, meta, cb) {
            canReflect.eachIndex(source.valueDependencies || [], function (obj) {
                cb(obj, meta);
            });
        };
        var visit = function visit(obj, meta, key) {
            var gotKey = arguments.length === 3;
            var node = graph.findNode(function (node) {
                return gotKey ? node.obj === obj && node.key === key : node.obj === obj;
            });
            if (node) {
                if (meta.parent) {
                    addArrow(meta.direction, meta.parent, node, {
                        kind: meta.kind,
                        direction: meta.direction
                    });
                }
                return graph;
            }
            order += 1;
            node = gotKey ? makeNode(obj, key) : makeNode(obj);
            node.order = order;
            graph.addNode(node);
            if (meta.parent) {
                addArrow(meta.direction, meta.parent, node, {
                    kind: meta.kind,
                    direction: meta.direction
                });
            }
            var nextMeta;
            var data = gotKey ? mutateDeps.getDependencyDataOf(obj, key) : mutateDeps.getDependencyDataOf(obj);
            if (data && data.whatIChange) {
                nextMeta = {
                    direction: 'whatIChange',
                    parent: node
                };
                canReflect.eachKey(data.whatIChange, function (dependencyRecord, kind) {
                    nextMeta.kind = kind;
                    visitKeyDependencies(dependencyRecord, nextMeta, visit);
                    visitValueDependencies(dependencyRecord, nextMeta, visit);
                });
            }
            if (data && data.whatChangesMe) {
                nextMeta = {
                    direction: 'whatChangesMe',
                    parent: node
                };
                canReflect.eachKey(data.whatChangesMe, function (dependencyRecord, kind) {
                    nextMeta.kind = kind;
                    visitKeyDependencies(dependencyRecord, nextMeta, visit);
                    visitValueDependencies(dependencyRecord, nextMeta, visit);
                });
            }
            return graph;
        };
        return gotKey ? visit(obj, {}, key) : visit(obj, {});
    };
});
/*can-debug@2.0.7#src/format-graph/format-graph*/
define('can-debug@2.0.7#src/format-graph/format-graph', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var canAssign = require('can-assign');
    module.exports = function formatGraph(graph) {
        var nodeIdMap = new Map();
        graph.nodes.forEach(function (node, index) {
            nodeIdMap.set(node, index + 1);
        });
        var nodesDataSet = graph.nodes.map(function (node) {
            return {
                shape: 'box',
                id: nodeIdMap.get(node),
                label: canReflect.getName(node.obj) + (node.key ? '.' + node.key : '')
            };
        });
        var getArrowData = function getArrowData(meta) {
            var regular = { arrows: 'to' };
            var withDashes = {
                arrows: 'to',
                dashes: true
            };
            var map = {
                derive: regular,
                mutate: withDashes
            };
            return map[meta.kind];
        };
        var visited = new Map();
        var arrowsDataSet = [];
        graph.nodes.forEach(function (node) {
            var visit = function (node) {
                if (!visited.has(node)) {
                    visited.set(node, true);
                    var arrows = graph.arrows.get(node);
                    var headId = nodeIdMap.get(node);
                    arrows.forEach(function (neighbor) {
                        var tailId = nodeIdMap.get(neighbor);
                        var meta = graph.arrowsMeta.get(node).get(neighbor);
                        arrowsDataSet.push(canAssign({
                            from: headId,
                            to: tailId
                        }, getArrowData(meta)));
                        visit(neighbor);
                    });
                }
            };
            visit(node);
        });
        return {
            nodes: nodesDataSet,
            edges: arrowsDataSet
        };
    };
});
/*can-debug@2.0.7#src/log-data/log-data*/
define('can-debug@2.0.7#src/log-data/log-data', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var quoteString = function quoteString(x) {
        return typeof x === 'string' ? JSON.stringify(x) : x;
    };
    module.exports = function log(data) {
        var node = data.node;
        var nameParts = [
            node.name,
            'key' in node ? '.' + node.key : ''
        ];
        console.group(nameParts.join(''));
        console.log('value  ', quoteString(node.value));
        console.log('object ', node.obj);
        if (data.derive.length) {
            console.group('DERIVED FROM');
            canReflect.eachIndex(data.derive, log);
            console.groupEnd();
        }
        if (data.mutations.length) {
            console.group('MUTATED BY');
            canReflect.eachIndex(data.mutations, log);
            console.groupEnd();
        }
        if (data.twoWay.length) {
            console.group('TWO WAY');
            canReflect.eachIndex(data.twoWay, log);
            console.groupEnd();
        }
        console.groupEnd();
    };
});
/*can-debug@2.0.7#src/label-cycles/label-cycles*/
define('can-debug@2.0.7#src/label-cycles/label-cycles', [
    'require',
    'exports',
    'module',
    '../graph/graph'
], function (require, exports, module) {
    'use strict';
    var Graph = require('../graph/graph');
    module.exports = function labelCycles(graph) {
        var visited = new Map();
        var result = new Graph();
        graph.nodes.forEach(function (node) {
            result.addNode(node);
        });
        var visit = function visit(node) {
            visited.set(node, true);
            graph.getNeighbors(node).forEach(function (adj) {
                if (visited.has(adj)) {
                    var isTwoWay = graph.hasArrow(node, adj);
                    if (isTwoWay) {
                        result.addArrow(adj, node, { kind: 'twoWay' });
                    }
                } else {
                    result.addArrow(node, adj, graph.getArrowMeta(node, adj));
                    visit(adj);
                }
            });
        };
        visit(graph.nodes[0]);
        return result;
    };
});
/*can-debug@2.0.7#src/get-data/get-data*/
define('can-debug@2.0.7#src/get-data/get-data', [
    'require',
    'exports',
    'module',
    '../label-cycles/label-cycles'
], function (require, exports, module) {
    'use strict';
    var labelCycles = require('../label-cycles/label-cycles');
    var isDisconnected = function isDisconnected(data) {
        return !data.derive.length && !data.mutations.length && !data.twoWay.length;
    };
    module.exports = function getDebugData(inputGraph, direction) {
        var visited = new Map();
        var graph = labelCycles(direction === 'whatChangesMe' ? inputGraph.reverse() : inputGraph);
        var visit = function visit(node) {
            var data = {
                node: node,
                derive: [],
                mutations: [],
                twoWay: []
            };
            visited.set(node, true);
            graph.getNeighbors(node).forEach(function (adj) {
                var meta = graph.getArrowMeta(node, adj);
                if (!visited.has(adj)) {
                    switch (meta.kind) {
                    case 'twoWay':
                        data.twoWay.push(visit(adj));
                        break;
                    case 'derive':
                        data.derive.push(visit(adj));
                        break;
                    case 'mutate':
                        data.mutations.push(visit(adj));
                        break;
                    default:
                        throw new Error('Unknow meta.kind value: ', meta.kind);
                    }
                }
            });
            return data;
        };
        var result = visit(graph.nodes[0]);
        return isDisconnected(result) ? null : result;
    };
});
/*can-debug@2.0.7#src/what-i-change/what-i-change*/
define('can-debug@2.0.7#src/what-i-change/what-i-change', [
    'require',
    'exports',
    'module',
    '../log-data/log-data',
    '../get-data/get-data',
    '../get-graph/get-graph'
], function (require, exports, module) {
    'use strict';
    var log = require('../log-data/log-data');
    var getData = require('../get-data/get-data');
    var getGraph = require('../get-graph/get-graph');
    module.exports = function logWhatIChange(obj, key) {
        var gotKey = arguments.length === 2;
        var data = getData(gotKey ? getGraph(obj, key) : getGraph(obj), 'whatIChange');
        if (data) {
            log(data);
        }
    };
});
/*can-debug@2.0.7#src/what-changes-me/what-changes-me*/
define('can-debug@2.0.7#src/what-changes-me/what-changes-me', [
    'require',
    'exports',
    'module',
    '../log-data/log-data',
    '../get-data/get-data',
    '../get-graph/get-graph'
], function (require, exports, module) {
    'use strict';
    var log = require('../log-data/log-data');
    var getData = require('../get-data/get-data');
    var getGraph = require('../get-graph/get-graph');
    module.exports = function logWhatChangesMe(obj, key) {
        var gotKey = arguments.length === 2;
        var data = getData(gotKey ? getGraph(obj, key) : getGraph(obj), 'whatChangesMe');
        if (data) {
            log(data);
        }
    };
});
/*can-debug@2.0.7#src/get-what-i-change/get-what-i-change*/
define('can-debug@2.0.7#src/get-what-i-change/get-what-i-change', [
    'require',
    'exports',
    'module',
    '../get-data/get-data',
    '../get-graph/get-graph'
], function (require, exports, module) {
    'use strict';
    var getData = require('../get-data/get-data');
    var getGraph = require('../get-graph/get-graph');
    module.exports = function getWhatChangesMe(obj, key) {
        var gotKey = arguments.length === 2;
        return getData(gotKey ? getGraph(obj, key) : getGraph(obj), 'whatIChange');
    };
});
/*can-debug@2.0.7#src/get-what-changes-me/get-what-changes-me*/
define('can-debug@2.0.7#src/get-what-changes-me/get-what-changes-me', [
    'require',
    'exports',
    'module',
    '../get-data/get-data',
    '../get-graph/get-graph'
], function (require, exports, module) {
    'use strict';
    var getData = require('../get-data/get-data');
    var getGraph = require('../get-graph/get-graph');
    module.exports = function getWhatChangesMe(obj, key) {
        var gotKey = arguments.length === 2;
        return getData(gotKey ? getGraph(obj, key) : getGraph(obj), 'whatChangesMe');
    };
});
/*can-diff@1.5.0#list/list*/
define('can-diff@1.5.0#list/list', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var slice = [].slice;
    function defaultIdentity(a, b) {
        return a === b;
    }
    function makeIdentityFromMapSchema(typeSchema) {
        if (typeSchema.identity && typeSchema.identity.length) {
            return function identityCheck(a, b) {
                var aId = canReflect.getIdentity(a, typeSchema), bId = canReflect.getIdentity(b, typeSchema);
                return aId === bId;
            };
        } else {
            return defaultIdentity;
        }
    }
    function makeIdentityFromListSchema(listSchema) {
        return listSchema.values != null ? makeIdentityFromMapSchema(canReflect.getSchema(listSchema.values)) : defaultIdentity;
    }
    function makeIdentity(oldList, oldListLength) {
        var listSchema = canReflect.getSchema(oldList), typeSchema;
        if (listSchema != null) {
            if (listSchema.values != null) {
                typeSchema = canReflect.getSchema(listSchema.values);
            } else {
                return defaultIdentity;
            }
        }
        if (typeSchema == null && oldListLength > 0) {
            typeSchema = canReflect.getSchema(canReflect.getKeyValue(oldList, 0));
        }
        if (typeSchema) {
            return makeIdentityFromMapSchema(typeSchema);
        } else {
            return defaultIdentity;
        }
    }
    function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
        var oldIndex = oldList.length - 1, newIndex = newList.length - 1;
        while (oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem, oldIndex)) {
                oldIndex--;
                newIndex--;
                continue;
            } else {
                return [{
                        type: 'splice',
                        index: newDiffStopIndex,
                        deleteCount: oldIndex - oldDiffStopIndex + 1,
                        insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
                    }];
            }
        }
        return [{
                type: 'splice',
                index: newDiffStopIndex,
                deleteCount: oldIndex - oldDiffStopIndex + 1,
                insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
            }];
    }
    module.exports = function (oldList, newList, schemaOrIdentity) {
        var oldIndex = 0, newIndex = 0, oldLength = canReflect.size(oldList), newLength = canReflect.size(newList), patches = [];
        var schemaType = typeof schemaOrIdentity, identity;
        if (schemaType === 'function') {
            identity = schemaOrIdentity;
        } else if (schemaOrIdentity != null) {
            if (schemaOrIdentity.type === 'map') {
                identity = makeIdentityFromMapSchema(schemaOrIdentity);
            } else {
                identity = makeIdentityFromListSchema(schemaOrIdentity);
            }
        } else {
            identity = makeIdentity(oldList, oldLength);
        }
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem, oldIndex)) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && identity(oldItem, newList[newIndex + 1], oldIndex)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]],
                    type: 'splice'
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && identity(oldList[oldIndex + 1], newItem, oldIndex + 1)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: [],
                    type: 'splice'
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push.apply(patches, reverseDiff(oldIndex, newIndex, oldList, newList, identity));
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            type: 'splice',
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*can-diff@1.5.0#merge-deep/merge-deep*/
define('can-diff@1.5.0#merge-deep/merge-deep', [
    'require',
    'exports',
    'module',
    'can-reflect',
    '../list/list'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var diffList = require('../list/list');
    function smartMerge(instance, props) {
        props = canReflect.serialize(props);
        if (canReflect.isMoreListLikeThanMapLike(instance)) {
            mergeList(instance, props);
        } else {
            mergeMap(instance, props);
        }
        return instance;
    }
    function mergeMap(instance, data) {
        canReflect.eachKey(instance, function (value, prop) {
            if (!canReflect.hasKey(data, prop)) {
                canReflect.deleteKeyValue(instance, prop);
                return;
            }
            var newValue = canReflect.getKeyValue(data, prop);
            canReflect.deleteKeyValue(data, prop);
            if (canReflect.isPrimitive(value)) {
                canReflect.setKeyValue(instance, prop, newValue);
                return;
            }
            var newValueIsList = Array.isArray(newValue), currentValueIsList = canReflect.isMoreListLikeThanMapLike(value);
            if (currentValueIsList && newValueIsList) {
                mergeList(value, newValue);
            } else if (!newValueIsList && !currentValueIsList && canReflect.isMapLike(value) && canReflect.isPlainObject(newValue)) {
                var schema = canReflect.getSchema(value);
                if (schema && schema.identity && schema.identity.length) {
                    var id = canReflect.getIdentity(value, schema);
                    if (id != null && id === canReflect.getIdentity(newValue, schema)) {
                        mergeMap(value, newValue);
                        return;
                    }
                }
                canReflect.setKeyValue(instance, prop, canReflect.new(value.constructor, newValue));
            } else {
                canReflect.setKeyValue(instance, prop, newValue);
            }
        });
        canReflect.eachKey(data, function (value, prop) {
            canReflect.setKeyValue(instance, prop, value);
        });
    }
    function mergeList(list, data) {
        var ItemType, itemSchema;
        var listSchema = canReflect.getSchema(list);
        if (listSchema) {
            ItemType = listSchema.values;
        }
        if (ItemType) {
            itemSchema = canReflect.getSchema(ItemType);
        }
        if (!itemSchema && canReflect.size(list) > 0) {
            itemSchema = canReflect.getSchema(canReflect.getKeyValue(list, 0));
        }
        var identity;
        if (itemSchema && itemSchema.identity && itemSchema.identity.length) {
            identity = function (a, b) {
                var aId = canReflect.getIdentity(a, itemSchema), bId = canReflect.getIdentity(b, itemSchema);
                var eq = aId === bId;
                if (eq) {
                    mergeMap(a, b);
                }
                return eq;
            };
        } else {
            identity = function (a, b) {
                var eq = a === b;
                if (eq) {
                    if (!canReflect.isPrimitive(a)) {
                        mergeMap(a, b);
                    }
                }
                return eq;
            };
        }
        var patches = diffList(list, data, identity);
        var hydrate = ItemType ? canReflect.new.bind(canReflect, ItemType) : function (v) {
            return v;
        };
        if (!patches.length) {
            return list;
        }
        patches.forEach(function (patch) {
            applyPatch(list, patch, hydrate);
        });
    }
    function applyPatch(list, patch, makeInstance) {
        var insert = makeInstance && patch.insert.map(function (val) {
            return makeInstance(val);
        }) || patch.insert;
        var args = [
            patch.index,
            patch.deleteCount
        ].concat(insert);
        list.splice.apply(list, args);
        return list;
    }
    smartMerge.applyPatch = applyPatch;
    module.exports = smartMerge;
});
/*can-debug@2.0.7#can-debug*/
define('can-debug@2.0.7#can-debug', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-globals',
    './src/proxy-namespace',
    './src/temporarily-bind',
    './src/get-graph/get-graph',
    './src/format-graph/format-graph',
    './src/what-i-change/what-i-change',
    './src/what-changes-me/what-changes-me',
    './src/get-what-i-change/get-what-i-change',
    './src/get-what-changes-me/get-what-changes-me',
    'can-observation',
    'can-symbol',
    'can-reflect',
    'can-queues',
    'can-diff/merge-deep/merge-deep'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var globals = require('can-globals');
        var proxyNamespace = require('./src/proxy-namespace');
        var temporarilyBind = require('./src/temporarily-bind');
        var getGraph = require('./src/get-graph/get-graph');
        var formatGraph = require('./src/format-graph/format-graph');
        var logWhatIChange = require('./src/what-i-change/what-i-change');
        var logWhatChangesMe = require('./src/what-changes-me/what-changes-me');
        var getWhatIChange = require('./src/get-what-i-change/get-what-i-change');
        var getWhatChangesMe = require('./src/get-what-changes-me/get-what-changes-me');
        var Observation = require('can-observation');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var canQueues = require('can-queues');
        var mergeDeep = require('can-diff/merge-deep/merge-deep');
        var global = globals.getKeyValue('global');
        var devtoolsRegistrationComplete = false;
        function registerWithDevtools() {
            if (devtoolsRegistrationComplete) {
                return;
            }
            var devtoolsGlobalName = '__CANJS_DEVTOOLS__';
            var devtoolsCanModules = {
                Observation: Observation,
                Reflect: canReflect,
                Symbol: canSymbol,
                formatGraph: namespace.debug.formatGraph,
                getGraph: namespace.debug.getGraph,
                mergeDeep: mergeDeep,
                queues: canQueues
            };
            if (global[devtoolsGlobalName]) {
                global[devtoolsGlobalName].register(devtoolsCanModules);
            } else {
                Object.defineProperty(global, devtoolsGlobalName, {
                    set: function (devtoolsGlobal) {
                        Object.defineProperty(global, devtoolsGlobalName, { value: devtoolsGlobal });
                        devtoolsGlobal.register(devtoolsCanModules);
                    },
                    configurable: true
                });
            }
            devtoolsRegistrationComplete = true;
        }
        module.exports = function () {
            namespace.debug = {
                formatGraph: temporarilyBind(formatGraph),
                getGraph: temporarilyBind(getGraph),
                getWhatIChange: temporarilyBind(getWhatIChange),
                getWhatChangesMe: temporarilyBind(getWhatChangesMe),
                logWhatIChange: temporarilyBind(logWhatIChange),
                logWhatChangesMe: temporarilyBind(logWhatChangesMe)
            };
            registerWithDevtools();
            global.can = typeof Proxy !== 'undefined' ? proxyNamespace(namespace) : namespace;
            return namespace.debug;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can@5.33.3#enable-can-debug*/
define('can@5.33.3#enable-can-debug', ['can-debug@2.0.7#can-debug'], function (_canDebug) {
    'use strict';
    var _canDebug2 = _interopRequireDefault(_canDebug);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
});
/*can-bind@1.5.1#can-bind*/
define('can-bind@1.5.1#can-bind', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-namespace',
    'can-queues',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var namespace = require('can-namespace');
    var queues = require('can-queues');
    var canAssign = require('can-assign');
    var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
    var getValueSymbol = canSymbol.for('can.getValue');
    var onValueSymbol = canSymbol.for('can.onValue');
    var onEmitSymbol = canSymbol.for('can.onEmit');
    var offEmitSymbol = canSymbol.for('can.offEmit');
    var setValueSymbol = canSymbol.for('can.setValue');
    var canElementSymbol = canSymbol.for('can.element');
    function defaultSetValue(newValue, observable) {
        canReflect.setValue(observable, newValue);
    }
    function onEmit(listenToObservable, updateFunction, queue) {
        return listenToObservable[onEmitSymbol](updateFunction, queue);
    }
    function offEmit(listenToObservable, updateFunction, queue) {
        return listenToObservable[offEmitSymbol](updateFunction, queue);
    }
    function turnOffListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {
        var offValueOrOffEmitFn;
        if (listenToObservable[onValueSymbol]) {
            offValueOrOffEmitFn = canReflect.offValue;
        } else if (listenToObservable[onEmitSymbol]) {
            offValueOrOffEmitFn = offEmit;
        }
        if (offValueOrOffEmitFn) {
            offValueOrOffEmitFn(listenToObservable, updateFunction, queue);
        }
    }
    function turnOnListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {
        var onValueOrOnEmitFn;
        if (listenToObservable[onValueSymbol]) {
            onValueOrOnEmitFn = canReflect.onValue;
        } else if (listenToObservable[onEmitSymbol]) {
            onValueOrOnEmitFn = onEmit;
        }
        if (onValueOrOnEmitFn) {
            onValueOrOnEmitFn(listenToObservable, updateFunction, queue);
        }
    }
    function Semaphore(binding, type) {
        this.value = 0;
        this._binding = binding;
        this._type = type;
    }
    canAssign(Semaphore.prototype, {
        decrement: function () {
            this.value -= 1;
        },
        increment: function (args) {
            this._incremented = true;
            this.value += 1;
        }
    });
    function Bind(options) {
        this._options = options;
        if (options.queue === undefined) {
            if (options.element) {
                options.queue = 'dom';
            } else {
                options.queue = 'domUI';
            }
        }
        if (options.cycles > 0 === false) {
            options.cycles = 0;
        }
        options.onInitDoNotUpdateChild = typeof options.onInitDoNotUpdateChild === 'boolean' ? options.onInitDoNotUpdateChild : false;
        options.onInitDoNotUpdateParent = typeof options.onInitDoNotUpdateParent === 'boolean' ? options.onInitDoNotUpdateParent : false;
        options.onInitSetUndefinedParentIfChildIsDefined = typeof options.onInitSetUndefinedParentIfChildIsDefined === 'boolean' ? options.onInitSetUndefinedParentIfChildIsDefined : true;
        var childSemaphore = new Semaphore(this, 'child');
        var parentSemaphore = new Semaphore(this, 'parent');
        var childToParent = true;
        if (typeof options.childToParent === 'boolean') {
            childToParent = options.childToParent;
        } else if (options.child[getValueSymbol] == null) {
            childToParent = false;
        } else if (options.setParent === undefined && options.parent[setValueSymbol] == null) {
            childToParent = false;
        }
        var parentToChild = true;
        if (typeof options.parentToChild === 'boolean') {
            parentToChild = options.parentToChild;
        } else if (options.parent[getValueSymbol] == null) {
            parentToChild = false;
        } else if (options.setChild === undefined && options.child[setValueSymbol] == null) {
            parentToChild = false;
        }
        if (childToParent === false && parentToChild === false) {
            throw new Error('Neither the child nor parent will be updated; this is a no-way binding');
        }
        this._childToParent = childToParent;
        this._parentToChild = parentToChild;
        if (options.setChild === undefined) {
            options.setChild = defaultSetValue;
        }
        if (options.setParent === undefined) {
            options.setParent = defaultSetValue;
        }
        if (options.priority !== undefined) {
            canReflect.setPriority(options.child, options.priority);
            canReflect.setPriority(options.parent, options.priority);
        }
        var allowedUpdates = options.cycles * 2;
        var allowedChildUpdates = allowedUpdates + (options.sticky === 'childSticksToParent' ? 1 : 0);
        var allowedParentUpdates = allowedUpdates + (options.sticky === 'parentSticksToChild' ? 1 : 0);
        this._bindingState = {
            child: false,
            parent: false
        };
        this._updateChild = function (newValue) {
            updateValue.call(this, {
                bindingState: this._bindingState,
                newValue: newValue,
                debugObservableName: 'child',
                debugPartnerName: 'parent',
                observable: options.child,
                setValue: options.setChild,
                semaphore: childSemaphore,
                allowedUpdates: allowedChildUpdates,
                sticky: options.sticky === 'parentSticksToChild',
                partner: options.parent,
                setPartner: options.setParent,
                partnerSemaphore: parentSemaphore
            });
        }.bind(this);
        this._updateParent = function (newValue) {
            updateValue.call(this, {
                bindingState: this._bindingState,
                newValue: newValue,
                debugObservableName: 'parent',
                debugPartnerName: 'child',
                observable: options.parent,
                setValue: options.setParent,
                semaphore: parentSemaphore,
                allowedUpdates: allowedParentUpdates,
                sticky: options.sticky === 'childSticksToParent',
                partner: options.child,
                setPartner: options.setChild,
                partnerSemaphore: childSemaphore
            });
        }.bind(this);
        if (options.element) {
            this._updateChild[canElementSymbol] = this._updateParent[canElementSymbol] = options.element;
        }
    }
    Object.defineProperty(Bind.prototype, 'parentValue', {
        get: function () {
            return canReflect.getValue(this._options.parent);
        }
    });
    canAssign(Bind.prototype, {
        start: function () {
            var childValue;
            var options = this._options;
            var parentValue;
            this.startParent();
            this.startChild();
            if (this._childToParent === true && this._parentToChild === true) {
                parentValue = canReflect.getValue(options.parent);
                if (parentValue === undefined) {
                    childValue = canReflect.getValue(options.child);
                    if (childValue === undefined) {
                        if (options.onInitDoNotUpdateChild === false) {
                            this._updateChild(parentValue);
                        }
                    } else if (options.onInitDoNotUpdateParent === false && options.onInitSetUndefinedParentIfChildIsDefined === true) {
                        this._updateParent(childValue);
                    }
                } else {
                    if (options.onInitDoNotUpdateChild === false) {
                        this._updateChild(parentValue);
                    }
                }
            } else if (this._childToParent === true) {
                if (options.onInitDoNotUpdateParent === false) {
                    childValue = canReflect.getValue(options.child);
                    this._updateParent(childValue);
                }
            } else if (this._parentToChild === true) {
                if (options.onInitDoNotUpdateChild === false) {
                    parentValue = canReflect.getValue(options.parent);
                    this._updateChild(parentValue);
                }
            }
        },
        startChild: function () {
            if (this._bindingState.child === false && this._childToParent === true) {
                var options = this._options;
                this._bindingState.child = true;
                turnOnListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);
            }
        },
        startParent: function () {
            if (this._bindingState.parent === false && this._parentToChild === true) {
                var options = this._options;
                this._bindingState.parent = true;
                turnOnListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);
            }
        },
        stop: function () {
            var bindingState = this._bindingState;
            var options = this._options;
            if (bindingState.parent === true && this._parentToChild === true) {
                bindingState.parent = false;
                turnOffListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);
            }
            if (bindingState.child === true && this._childToParent === true) {
                bindingState.child = false;
                turnOffListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);
            }
        }
    });
    [
        'parent',
        'child'
    ].forEach(function (property) {
        Object.defineProperty(Bind.prototype, property, {
            get: function () {
                return this._options[property];
            }
        });
    });
    function updateValue(args) {
        var bindingState = args.bindingState;
        if (bindingState.child === false && bindingState.parent === false) {
            return;
        }
        var semaphore = args.semaphore;
        if (semaphore.value + args.partnerSemaphore.value <= args.allowedUpdates) {
            queues.batch.start();
            semaphore.increment(args);
            args.setValue(args.newValue, args.observable);
            queues.mutateQueue.enqueue(semaphore.decrement, semaphore, []);
            queues.batch.stop();
            if (args.sticky) {
                var observableValue = canReflect.getValue(args.observable);
                if (observableValue !== canReflect.getValue(args.partner)) {
                    args.setPartner(observableValue, args.partner);
                }
            }
        } else {
        }
    }
    module.exports = namespace.Bind = Bind;
});
/*can-attribute-encoder@1.1.4#can-attribute-encoder*/
define('can-attribute-encoder@1.1.4#can-attribute-encoder', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var dev = require('can-log/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector,controlsList');
    function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    }
    function startsWith(allOfIt, startsWith) {
        return allOfIt.indexOf(startsWith) === 0;
    }
    function endsWith(allOfIt, endsWith) {
        return allOfIt.length - allOfIt.lastIndexOf(endsWith) === endsWith.length;
    }
    var regexes = {
        leftParens: /\(/g,
        rightParens: /\)/g,
        leftBrace: /\{/g,
        rightBrace: /\}/g,
        camelCase: /([a-z]|[0-9]|^)([A-Z])/g,
        forwardSlash: /\//g,
        space: /\s/g,
        uppercase: /[A-Z]/g,
        uppercaseDelimiterThenChar: /:u:([a-z])/g,
        caret: /\^/g,
        dollar: /\$/g,
        at: /@/g
    };
    var delimiters = {
        prependUppercase: ':u:',
        replaceSpace: ':s:',
        replaceForwardSlash: ':f:',
        replaceLeftParens: ':lp:',
        replaceRightParens: ':rp:',
        replaceLeftBrace: ':lb:',
        replaceRightBrace: ':rb:',
        replaceCaret: ':c:',
        replaceDollar: ':d:',
        replaceAt: ':at:'
    };
    var encoder = {};
    encoder.encode = function (name) {
        var encoded = name;
        if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
            if (startsWith(encoded, 'on:') || endsWith(encoded, ':to') || endsWith(encoded, ':from') || endsWith(encoded, ':bind') || endsWith(encoded, ':raw')) {
                encoded = encoded.replace(regexes.uppercase, function (char) {
                    return delimiters.prependUppercase + char.toLowerCase();
                });
            } else if (startsWith(encoded, '(') || startsWith(encoded, '{')) {
                encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
            }
        }
        encoded = encoded.replace(regexes.space, delimiters.replaceSpace).replace(regexes.forwardSlash, delimiters.replaceForwardSlash).replace(regexes.leftParens, delimiters.replaceLeftParens).replace(regexes.rightParens, delimiters.replaceRightParens).replace(regexes.leftBrace, delimiters.replaceLeftBrace).replace(regexes.rightBrace, delimiters.replaceRightBrace).replace(regexes.caret, delimiters.replaceCaret).replace(regexes.dollar, delimiters.replaceDollar).replace(regexes.at, delimiters.replaceAt);
        return encoded;
    };
    encoder.decode = function (name) {
        var decoded = name;
        if (!caseMattersAttributes[decoded] && regexes.uppercaseDelimiterThenChar.test(decoded)) {
            if (startsWith(decoded, 'on:') || endsWith(decoded, ':to') || endsWith(decoded, ':from') || endsWith(decoded, ':bind') || endsWith(decoded, ':raw')) {
                decoded = decoded.replace(regexes.uppercaseDelimiterThenChar, function (match, char) {
                    return char.toUpperCase();
                });
            }
        }
        decoded = decoded.replace(delimiters.replaceLeftParens, '(').replace(delimiters.replaceRightParens, ')').replace(delimiters.replaceLeftBrace, '{').replace(delimiters.replaceRightBrace, '}').replace(delimiters.replaceForwardSlash, '/').replace(delimiters.replaceSpace, ' ').replace(delimiters.replaceCaret, '^').replace(delimiters.replaceDollar, '$').replace(delimiters.replaceAt, '@');
        return decoded;
    };
    if (namespace.encoder) {
        throw new Error('You can\'t have two versions of can-attribute-encoder, check your dependencies');
    } else {
        module.exports = namespace.encoder = encoder;
    }
});
/*can-view-parser@4.1.3#can-view-parser*/
define('can-view-parser@4.1.3#can-view-parser', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev',
    'can-attribute-encoder'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace'), dev = require('can-log/dev/dev'), encoder = require('can-attribute-encoder');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, magicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), magicMatch = new RegExp('\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?', 'g'), space = /\s/, alphaRegex = new RegExp('[' + alphaNumeric + ']'), attributeRegexp = new RegExp('[' + alphaNumericHU + ']+s*=s*("[^"]*"|\'[^\']*\')');
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var startOppositesMap = {
        '{': '}',
        '(': ')'
    };
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        var end = arguments.length;
                        if (arguments[end - 1] === undefined) {
                            end = arguments.length - 1;
                        }
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0, end)
                        });
                    }
                };
            });
        }
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary, lineNo);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler, lineNo);
            handler.end(tagName, unary, lineNo);
            if (tagName === 'html') {
                skipChars = true;
            }
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i], lineNo);
                    }
                }
                stack.length = pos;
                if (tagName === 'body') {
                    skipChars = true;
                }
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside, lineNo);
            }
        }
        var callChars = function () {
            if (charsText && !skipChars) {
                if (handler.chars) {
                    handler.chars(charsText, lineNo);
                }
            }
            skipChars = false;
            charsText = '';
        };
        var index, chars, skipChars, match, lineNo, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index), lineNo);
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        match[0].replace(endTag, parseEndTag);
                        html = html.substring(match[0].length);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        parseStartTag.apply(null, res.match);
                        html = res.html;
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        match[0].replace(magicMatch, parseMustache);
                        html = html.substring(match[0].length);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text, lineNo);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done(lineNo);
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest, lineNo) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = encoder.encode(attrName);
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart, lineNo);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest, lineNo) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            var val = rest.substring(state.valueStart, curIndex);
            handler.attrValue(val, lineNo);
        }
        handler.attrEnd(state.attrStart, lineNo);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    HTMLParser.parseAttrs = function (rest, handler, lineNo) {
        if (!rest) {
            return;
        }
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1], lineNo);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                var started = rest[state.nameStart], otherStart, otherOpposite;
                if (startOppositesMap[started] === cur) {
                    otherStart = started === '{' ? '(' : '{';
                    otherOpposite = startOppositesMap[otherStart];
                    if (rest[curIndex + 1] === otherOpposite) {
                        callAttrStart(state, curIndex + 2, handler, rest, lineNo);
                        i++;
                    } else {
                        callAttrStart(state, curIndex + 1, handler, rest, lineNo);
                    }
                    state.lookingForEq = true;
                } else if (space.test(cur) && started !== '{' && started !== '(') {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest, lineNo);
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        } else if (state.lookingForEq || state.lookingForValue || state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        var attributeRange = attributeRegexp.exec(html.substring(1));
        var afterAttributeOffset = 1;
        while (attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {
            afterAttributeOffset += attributeRange.index + attributeRange[0].length;
            while (closingIndex < afterAttributeOffset) {
                closingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;
            }
            attributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));
        }
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-dom-mutate@1.3.11#-util*/
define('can-dom-mutate@1.3.11#-util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        function eliminate(array, item) {
            var index = array.indexOf(item);
            if (index >= 0) {
                array.splice(index, 1);
            }
        }
        function addToSet(items, set) {
            for (var i = 0, length = items.length; i < length; i++) {
                set.add(items[i]);
            }
        }
        function contains(parent, child) {
            if (parent.contains) {
                return parent.contains(child);
            }
            if (parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {
                return contains(parent.documentElement, child);
            } else {
                child = child.parentNode;
                if (child === parent) {
                    return true;
                }
                return false;
            }
        }
        function isInDocument(node) {
            var root = getDocument();
            if (root === node) {
                return true;
            }
            return contains(root, node);
        }
        function isDocumentElement(node) {
            return getDocument().documentElement === node;
        }
        function isFragment(node) {
            return !!(node && node.nodeType === 11);
        }
        function isElementNode(node) {
            return !!(node && node.nodeType === 1);
        }
        function getChildren(parentNode) {
            var nodes = [];
            var node = parentNode.firstChild;
            while (node) {
                nodes.push(node);
                node = node.nextSibling;
            }
            return nodes;
        }
        function getParents(node) {
            var nodes;
            if (isFragment(node)) {
                nodes = getChildren(node);
            } else {
                nodes = [node];
            }
            return nodes;
        }
        function getNodesLegacyB(node) {
            var skip, tmp;
            var depth = 0;
            var items = isFragment(node) ? [] : [node];
            if (node.firstChild == null) {
                return items;
            }
            do {
                if (!skip && (tmp = node.firstChild)) {
                    depth++;
                    items.push(tmp);
                } else if (tmp = node.nextSibling) {
                    skip = false;
                    items.push(tmp);
                } else {
                    tmp = node.parentNode;
                    depth--;
                    skip = true;
                }
                node = tmp;
            } while (depth > 0);
            return items;
        }
        function treeWalkerFilterFunction() {
            return NodeFilter.FILTER_ACCEPT;
        }
        var treeWalkerFilter = treeWalkerFilterFunction;
        treeWalkerFilter.acceptNode = treeWalkerFilterFunction;
        function getNodesWithTreeWalker(rootNode) {
            var result = isFragment(rootNode) ? [] : [rootNode];
            var walker = isElementNode(rootNode) && getDocument().createTreeWalker(rootNode, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, treeWalkerFilter, false);
            var node;
            while (node = walker && walker.nextNode()) {
                result.push(node);
            }
            return result;
        }
        function getAllNodes(node) {
            if (getDocument().createTreeWalker !== undefined) {
                return getNodesWithTreeWalker(node);
            } else {
                return getNodesLegacyB(node);
            }
        }
        function subscription(fn) {
            return function _subscription() {
                var disposal = fn.apply(this, arguments);
                var isDisposed = false;
                return function _disposal() {
                    if (isDisposed) {
                        var fnName = fn.name || fn.displayName || 'an anonymous function';
                        var message = 'Disposal function returned by ' + fnName + ' called more than once.';
                        throw new Error(message);
                    }
                    disposal.apply(this, arguments);
                    isDisposed = true;
                };
            };
        }
        module.exports = {
            eliminate: eliminate,
            isInDocument: isInDocument,
            getDocument: getDocument,
            isDocumentElement: isDocumentElement,
            isFragment: isFragment,
            getParents: getParents,
            getAllNodes: getAllNodes,
            getChildren: getChildren,
            subscription: subscription,
            addToSet: addToSet
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.11#can-dom-mutate*/
define('can-dom-mutate@1.3.11#can-dom-mutate', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-globals/global/global',
    'can-globals/mutation-observer/mutation-observer',
    'can-namespace',
    'can-globals/document/document',
    'can-reflect',
    './-util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var getRoot = require('can-globals/global/global');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var namespace = require('can-namespace');
        var DOCUMENT = require('can-globals/document/document');
        var canReflect = require('can-reflect');
        var util = require('./-util');
        var eliminate = util.eliminate;
        var subscription = util.subscription;
        var isDocumentElement = util.isDocumentElement;
        var getAllNodes = util.getAllNodes;
        var slice = Array.prototype.slice;
        var domMutate, dispatchInsertion, dispatchRemoval;
        var dataStore = new WeakMap();
        function getRelatedData(node, key) {
            var data = dataStore.get(node);
            if (data) {
                return data[key];
            }
        }
        function setRelatedData(node, key, targetListenersMap) {
            var data = dataStore.get(node);
            if (!data) {
                data = {};
                dataStore.set(node, data);
            }
            data[key] = targetListenersMap;
        }
        function deleteRelatedData(node, key) {
            var data = dataStore.get(node);
            return delete data[key];
        }
        function toMutationEvents(nodes) {
            var events = [];
            for (var i = 0; i < nodes.length; i++) {
                events.push({ target: nodes[i] });
            }
            return events;
        }
        function batch(processBatchItems) {
            return function batchAdd(items, callback) {
                processBatchItems(items);
                if (callback) {
                    callback();
                }
            };
        }
        function getDocumentListeners(target, key) {
            var doc = DOCUMENT();
            var data = getRelatedData(doc, key);
            if (data) {
                return data.listeners;
            }
        }
        function getTargetListeners(target, key) {
            var doc = DOCUMENT();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                return;
            }
            return targetListenersMap.get(target);
        }
        function addTargetListener(target, key, listener) {
            var doc = DOCUMENT();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                targetListenersMap = new WeakMap();
                setRelatedData(doc, key, targetListenersMap);
            }
            var targetListeners = targetListenersMap.get(target);
            if (!targetListeners) {
                targetListeners = [];
                targetListenersMap.set(target, targetListeners);
            }
            targetListeners.push(listener);
        }
        function removeTargetListener(target, key, listener) {
            var doc = DOCUMENT();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                return;
            }
            var targetListeners = targetListenersMap.get(target);
            if (!targetListeners) {
                return;
            }
            eliminate(targetListeners, listener);
            if (targetListeners.length === 0) {
                targetListenersMap['delete'](target);
                if (targetListenersMap.size === 0) {
                    deleteRelatedData(doc, key);
                }
            }
        }
        function fire(callbacks, arg) {
            var safeCallbacks = slice.call(callbacks, 0);
            var safeCallbackCount = safeCallbacks.length;
            for (var i = 0; i < safeCallbackCount; i++) {
                safeCallbacks[i](arg);
            }
        }
        function dispatch(listenerKey, documentDataKey) {
            return function dispatchEvents(events) {
                for (var e = 0; e < events.length; e++) {
                    var event = events[e];
                    var target = event.target;
                    var targetListeners = getTargetListeners(target, listenerKey);
                    if (targetListeners) {
                        fire(targetListeners, event);
                    }
                    if (!documentDataKey) {
                        continue;
                    }
                    var documentListeners = getDocumentListeners(target, documentDataKey);
                    if (documentListeners) {
                        fire(documentListeners, event);
                    }
                }
            };
        }
        var count = 0;
        function observeMutations(target, observerKey, config, handler) {
            var observerData = getRelatedData(target, observerKey);
            if (!observerData) {
                observerData = { observingCount: 0 };
                setRelatedData(target, observerKey, observerData);
            }
            var setupObserver = function () {
                if (observerData.observer) {
                    observerData.observer.disconnect();
                    observerData.observer = null;
                }
                var MutationObserver = getMutationObserver();
                if (MutationObserver) {
                    var Node = getRoot().Node;
                    var isRealNode = !!(Node && target instanceof Node);
                    if (isRealNode) {
                        var targetObserver = new MutationObserver(handler);
                        targetObserver.id = count++;
                        targetObserver.observe(target, config);
                        observerData.observer = targetObserver;
                    }
                }
            };
            if (observerData.observingCount === 0) {
                globals.onKeyValue('MutationObserver', setupObserver);
                setupObserver();
            }
            observerData.observingCount++;
            return function stopObservingMutations() {
                var observerData = getRelatedData(target, observerKey);
                if (observerData) {
                    observerData.observingCount--;
                    if (observerData.observingCount <= 0) {
                        if (observerData.observer) {
                            observerData.observer.disconnect();
                        }
                        deleteRelatedData(target, observerKey);
                        globals.offKeyValue('MutationObserver', setupObserver);
                    }
                }
            };
        }
        function handleTreeMutations(mutations) {
            if (typeof Set === 'undefined') {
                return;
            }
            var mutationCount = mutations.length;
            var added = new Set(), removed = new Set();
            for (var m = 0; m < mutationCount; m++) {
                var mutation = mutations[m];
                var addedCount = mutation.addedNodes.length;
                for (var a = 0; a < addedCount; a++) {
                    util.addToSet(getAllNodes(mutation.addedNodes[a]), added);
                }
                var removedCount = mutation.removedNodes.length;
                for (var r = 0; r < removedCount; r++) {
                    util.addToSet(getAllNodes(mutation.removedNodes[r]), removed);
                }
            }
            dispatchRemoval(toMutationEvents(canReflect.toArray(removed)));
            dispatchInsertion(toMutationEvents(canReflect.toArray(added)));
        }
        function handleAttributeMutations(mutations) {
            var mutationCount = mutations.length;
            for (var m = 0; m < mutationCount; m++) {
                var mutation = mutations[m];
                if (mutation.type === 'attributes') {
                    var node = mutation.target;
                    var attributeName = mutation.attributeName;
                    var oldValue = mutation.oldValue;
                    domMutate.dispatchNodeAttributeChange(node, attributeName, oldValue);
                }
            }
        }
        var treeMutationConfig = {
            subtree: true,
            childList: true
        };
        var attributeMutationConfig = {
            attributes: true,
            attributeOldValue: true
        };
        function addNodeListener(listenerKey, observerKey, isAttributes) {
            return subscription(function _addNodeListener(target, listener) {
                if (target.nodeType === 11) {
                    return Function.prototype;
                }
                var stopObserving;
                if (isAttributes) {
                    stopObserving = observeMutations(target, observerKey, attributeMutationConfig, handleAttributeMutations);
                } else {
                    stopObserving = observeMutations(DOCUMENT(), observerKey, treeMutationConfig, handleTreeMutations);
                }
                addTargetListener(target, listenerKey, listener);
                return function removeNodeListener() {
                    stopObserving();
                    removeTargetListener(target, listenerKey, listener);
                };
            });
        }
        function addGlobalListener(globalDataKey, addNodeListener) {
            return subscription(function addGlobalGroupListener(documentElement, listener) {
                if (!isDocumentElement(documentElement)) {
                    throw new Error('Global mutation listeners must pass a documentElement');
                }
                var doc = DOCUMENT();
                var documentData = getRelatedData(doc, globalDataKey);
                if (!documentData) {
                    documentData = { listeners: [] };
                    setRelatedData(doc, globalDataKey, documentData);
                }
                var listeners = documentData.listeners;
                if (listeners.length === 0) {
                    documentData.removeListener = addNodeListener(doc, function () {
                    });
                }
                listeners.push(listener);
                return function removeGlobalGroupListener() {
                    var documentData = getRelatedData(doc, globalDataKey);
                    if (!documentData) {
                        return;
                    }
                    var listeners = documentData.listeners;
                    eliminate(listeners, listener);
                    if (listeners.length === 0) {
                        documentData.removeListener();
                        deleteRelatedData(doc, globalDataKey);
                    }
                };
            });
        }
        var domMutationPrefix = 'domMutation';
        var insertionDataKey = domMutationPrefix + 'InsertionData';
        var removalDataKey = domMutationPrefix + 'RemovalData';
        var attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';
        var documentInsertionDataKey = domMutationPrefix + 'DocumentInsertionData';
        var documentRemovalDataKey = domMutationPrefix + 'DocumentRemovalData';
        var documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';
        var treeDataKey = domMutationPrefix + 'TreeData';
        var attributeDataKey = domMutationPrefix + 'AttributeData';
        dispatchInsertion = batch(dispatch(insertionDataKey, documentInsertionDataKey));
        dispatchRemoval = batch(dispatch(removalDataKey, documentRemovalDataKey));
        var dispatchAttributeChange = batch(dispatch(attributeChangeDataKey, documentAttributeChangeDataKey));
        var addNodeInsertionListener = addNodeListener(insertionDataKey, treeDataKey);
        var addNodeRemovalListener = addNodeListener(removalDataKey, treeDataKey);
        var addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);
        var addInsertionListener = addGlobalListener(documentInsertionDataKey, addNodeInsertionListener);
        var addRemovalListener = addGlobalListener(documentRemovalDataKey, addNodeRemovalListener);
        var addAttributeChangeListener = addGlobalListener(documentAttributeChangeDataKey, addNodeAttributeChangeListener);
        domMutate = {
            dispatchNodeInsertion: function (node, callback) {
                var nodes = new Set();
                util.addToSet(getAllNodes(node), nodes);
                var events = toMutationEvents(canReflect.toArray(nodes));
                dispatchInsertion(events, callback);
            },
            dispatchNodeRemoval: function (node, callback) {
                var nodes = new Set();
                util.addToSet(getAllNodes(node), nodes);
                var events = toMutationEvents(canReflect.toArray(nodes));
                dispatchRemoval(events, callback);
            },
            dispatchNodeAttributeChange: function (target, attributeName, oldValue, callback) {
                dispatchAttributeChange([{
                        target: target,
                        attributeName: attributeName,
                        oldValue: oldValue
                    }], callback);
            },
            onNodeInsertion: addNodeInsertionListener,
            onNodeRemoval: addNodeRemovalListener,
            onNodeAttributeChange: addNodeAttributeChangeListener,
            onRemoval: addRemovalListener,
            onInsertion: addInsertionListener,
            onAttributeChange: addAttributeChangeListener
        };
        module.exports = namespace.domMutate = domMutate;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.11#node/node*/
define('can-dom-mutate@1.3.11#node/node', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-namespace',
    '../can-dom-mutate',
    '../-util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var namespace = require('can-namespace');
        var domMutate = require('../can-dom-mutate');
        var util = require('../-util');
        var isInDocument = util.isInDocument;
        var getParents = util.getParents;
        var synthetic = {
            dispatchNodeInsertion: function (container, node) {
                if (isInDocument(node)) {
                    domMutate.dispatchNodeInsertion(node);
                }
            },
            dispatchNodeRemoval: function (container, node) {
                if (isInDocument(container) && !isInDocument(node)) {
                    domMutate.dispatchNodeRemoval(node);
                }
            }
        };
        var compat = {
            replaceChild: function (newChild, oldChild) {
                var newChildren = getParents(newChild);
                var result = this.replaceChild(newChild, oldChild);
                synthetic.dispatchNodeRemoval(this, oldChild);
                for (var i = 0; i < newChildren.length; i++) {
                    synthetic.dispatchNodeInsertion(this, newChildren[i]);
                }
                return result;
            },
            setAttribute: function (name, value) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.setAttribute(name, value);
                var newAttributeValue = this.getAttribute(name);
                if (oldAttributeValue !== newAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            },
            setAttributeNS: function (namespace, name, value) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.setAttributeNS(namespace, name, value);
                var newAttributeValue = this.getAttribute(name);
                if (oldAttributeValue !== newAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            },
            removeAttribute: function (name) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.removeAttribute(name);
                if (oldAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            }
        };
        var compatData = [
            [
                'appendChild',
                'Insertion'
            ],
            [
                'insertBefore',
                'Insertion'
            ],
            [
                'removeChild',
                'Removal'
            ]
        ];
        compatData.forEach(function (pair) {
            var nodeMethod = pair[0];
            var dispatchMethod = 'dispatchNode' + pair[1];
            compat[nodeMethod] = function (node) {
                var nodes = getParents(node);
                var result = this[nodeMethod].apply(this, arguments);
                for (var i = 0; i < nodes.length; i++) {
                    synthetic[dispatchMethod](this, nodes[i]);
                }
                return result;
            };
        });
        var normal = {};
        var nodeMethods = [
            'appendChild',
            'insertBefore',
            'removeChild',
            'replaceChild',
            'setAttribute',
            'setAttributeNS',
            'removeAttribute'
        ];
        nodeMethods.forEach(function (methodName) {
            normal[methodName] = function () {
                return this[methodName].apply(this, arguments);
            };
        });
        var mutate = {};
        function setMutateStrategy(observer) {
            var strategy = observer ? normal : compat;
            for (var key in strategy) {
                mutate[key] = strategy[key];
            }
        }
        var mutationObserverKey = 'MutationObserver';
        setMutateStrategy(globals.getKeyValue(mutationObserverKey));
        globals.onKeyValue(mutationObserverKey, setMutateStrategy);
        module.exports = namespace.domMutateNode = domMutate.node = mutate;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.11#node*/
define('can-dom-mutate@1.3.11#node', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './node/node'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var node = require('./node/node');
    module.exports = namespace.node = node;
});
/*can-view-nodelist@4.3.4#can-view-nodelist*/
define('can-view-nodelist@4.3.4#can-view-nodelist', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-dom-mutate/node'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var domMutate = require('can-dom-mutate/node');
    var nodeMap = new Map(), splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements) {
            var map = new Map();
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map.set(node, replacements[i]);
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap) {
            rMap.forEach(function (replacement) {
                list.newDeepChildren.push(replacement);
            });
        };
    var nodeLists = {
        update: function (nodeList, newNodes, oldNodes) {
            if (!oldNodes) {
                oldNodes = nodeLists.unregisterChildren(nodeList);
            }
            var arr = [];
            for (var i = 0, ref = arr.length = newNodes.length; i < ref; i++) {
                arr[i] = newNodes[i];
            }
            newNodes = arr;
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, rMap = replacementMap(list.replacements), rCount = list.replacements.length;
            while (index < list.length && rCount) {
                var node = list[index], replacement = rMap.get(node);
                if (replacement) {
                    rMap['delete'](node);
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap.get(node);
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap.set(node, list);
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            for (var n = 0; n < nodeList.length; n++) {
                var node = nodeList[n];
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        nodeMap['delete'](node);
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            }
            var deepChildren = nodeList.deepChildren;
            if (deepChildren) {
                for (var l = 0; l < deepChildren.length; l++) {
                    nodeLists.unregister(deepChildren[l], true);
                }
            }
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            nodeList.isUnregistered = true;
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            var child;
            for (var i = 0; i < elementsToBeRemoved.length; i++) {
                child = elementsToBeRemoved[i];
                if (child.parentNode === parent) {
                    domMutate.removeChild.call(parent, child);
                }
            }
        },
        nodeMap: nodeMap
    };
    module.exports = namespace.nodeLists = nodeLists;
});
/*can-child-nodes@1.2.1#can-child-nodes*/
define('can-child-nodes@1.2.1#can-child-nodes', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    function childNodes(node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    }
    module.exports = namespace.childNodes = childNodes;
});
/*can-fragment@1.3.1#can-fragment*/
define('can-fragment@1.3.1#can-fragment', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-namespace',
    'can-reflect',
    'can-child-nodes',
    'can-symbol'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var namespace = require('can-namespace');
        var canReflect = require('can-reflect');
        var childNodes = require('can-child-nodes');
        var canSymbol = require('can-symbol');
        var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, toDOMSymbol = canSymbol.for('can.toDOM');
        function makeFragment(html, name, doc) {
            if (name === undefined) {
                name = fragmentRE.test(html) && RegExp.$1;
            }
            if (html && toString.call(html.replace) === '[object Function]') {
                html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
            }
            var container = doc.createElement('div'), temp = doc.createElement('div');
            if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                temp.innerHTML = '<table>' + html + '</table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else if (name === 'col') {
                temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'tr') {
                temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
            } else if (name === 'td' || name === 'th') {
                temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
            } else if (name === 'option') {
                temp.innerHTML = '<select>' + html + '</select>';
                container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
            } else {
                container.innerHTML = '' + html;
            }
            return [].slice.call(childNodes(container));
        }
        function fragment(html, doc) {
            if (html && html.nodeType === 11) {
                return html;
            }
            if (!doc) {
                doc = getDocument();
            } else if (doc.length) {
                doc = doc[0];
            }
            var parts = makeFragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
            for (var i = 0, length = parts.length; i < length; i++) {
                frag.appendChild(parts[i]);
            }
            return frag;
        }
        var makeFrag = function (item, doc) {
            var document = doc || getDocument();
            var frag;
            if (!item || typeof item === 'string') {
                frag = fragment(item == null ? '' : '' + item, document);
            } else if (typeof item[toDOMSymbol] === 'function') {
                return makeFrag(item[toDOMSymbol]());
            } else if (item.nodeType === 11) {
                return item;
            } else if (typeof item.nodeType === 'number') {
                frag = document.createDocumentFragment();
                frag.appendChild(item);
                return frag;
            } else if (canReflect.isListLike(item)) {
                frag = document.createDocumentFragment();
                canReflect.eachIndex(item, function (item) {
                    frag.appendChild(makeFrag(item));
                });
            } else {
                frag = fragment('' + item, document);
            }
            if (!childNodes(frag).length) {
                frag.appendChild(document.createTextNode(''));
            }
            return frag;
        };
        module.exports = namespace.fragment = namespace.frag = makeFrag;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-callbacks@4.4.1#can-view-callbacks*/
define('can-view-callbacks@4.4.1#can-view-callbacks', [
    'require',
    'exports',
    'module',
    'can-observation-recorder',
    'can-log/dev/dev',
    'can-globals/global/global',
    'can-globals/document/document',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-namespace',
    'can-view-nodelist',
    'can-fragment',
    'can-globals',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var ObservationRecorder = require('can-observation-recorder');
        var dev = require('can-log/dev/dev');
        var getGlobal = require('can-globals/global/global');
        var getDocument = require('can-globals/document/document');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var namespace = require('can-namespace');
        var nodeLists = require('can-view-nodelist');
        var makeFrag = require('can-fragment');
        var globals = require('can-globals');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var callbackMapSymbol = canSymbol.for('can.callbackMap');
        var initializeSymbol = canSymbol.for('can.initialize');
        var tags = {};
        var automountEnabled = function () {
            var document = globals.getKeyValue('document');
            if (document == null || document.documentElement == null) {
                return false;
            }
            return document.documentElement.getAttribute('data-can-automount') !== 'false';
        };
        var renderedElements = new WeakMap();
        var mountElement = function (node) {
            var tagName = node.tagName && node.tagName.toLowerCase();
            var tagHandler = tags[tagName];
            if (tagHandler) {
                callbacks.tagHandler(node, tagName, {});
            }
        };
        var mutationObserverEnabled = false;
        var disableMutationObserver;
        var enableMutationObserver = function () {
            var docEl = getDocument().documentElement;
            if (mutationObserverEnabled) {
                if (mutationObserverEnabled === docEl) {
                    return;
                }
                disableMutationObserver();
            }
            var undoOnInsertionHandler = domMutate.onInsertion(docEl, function (mutation) {
                mountElement(mutation.target);
            });
            mutationObserverEnabled = true;
            disableMutationObserver = function () {
                undoOnInsertionHandler();
                mutationObserverEnabled = false;
            };
        };
        var renderTagsInDocument = function (tagName) {
            var nodes = getDocument().getElementsByTagName(tagName);
            for (var i = 0, node; (node = nodes[i]) !== undefined; i++) {
                mountElement(node);
            }
        };
        var attr = function (attributeName, attrHandler) {
            if (attrHandler) {
                if (typeof attributeName === 'string') {
                    attributes[attributeName] = attrHandler;
                } else {
                    regExpAttributes.push({
                        match: attributeName,
                        handler: attrHandler
                    });
                }
            } else {
                var cb = attributes[attributeName];
                if (!cb) {
                    for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                        var attrMatcher = regExpAttributes[i];
                        if (attrMatcher.match.test(attributeName)) {
                            return attrMatcher.handler;
                        }
                    }
                }
                return cb;
            }
        };
        var attrs = function (attrMap) {
            var map = canReflect.getKeyValue(attrMap, callbackMapSymbol) || attrMap;
            if (attrMaps.has(map)) {
                return;
            } else {
                attrMaps.set(map, true);
            }
            canReflect.eachKey(map, function (callback, exp) {
                attr(exp, callback);
            });
        };
        var attributes = {}, regExpAttributes = [], attrMaps = new WeakMap(), automaticCustomElementCharacters = /[-\:]/;
        var defaultCallback = function () {
        };
        var tag = function (tagName, tagHandler) {
            if (tagHandler) {
                var validCustomElementName = automaticCustomElementCharacters.test(tagName), tagExists = typeof tags[tagName.toLowerCase()] !== 'undefined', customElementExists;
                tags[tagName.toLowerCase()] = tagHandler;
                if (automountEnabled()) {
                    var customElements = globals.getKeyValue('customElements');
                    if (customElements) {
                        customElementExists = customElements.get(tagName.toLowerCase());
                        if (validCustomElementName && !customElementExists) {
                            var CustomElement = function () {
                                return Reflect.construct(HTMLElement, [], CustomElement);
                            };
                            CustomElement.prototype = Object.create(HTMLElement.prototype);
                            CustomElement.prototype.connectedCallback = function () {
                                callbacks.tagHandler(this, tagName.toLowerCase(), {});
                            };
                            customElements.define(tagName, CustomElement);
                        }
                    } else {
                        enableMutationObserver();
                        renderTagsInDocument(tagName);
                    }
                } else if (mutationObserverEnabled) {
                    disableMutationObserver();
                }
            } else {
                var cb;
                if (tagHandler === null) {
                    delete tags[tagName.toLowerCase()];
                } else {
                    cb = tags[tagName.toLowerCase()];
                }
                if (!cb && automaticCustomElementCharacters.test(tagName)) {
                    cb = defaultCallback;
                }
                return cb;
            }
        };
        var callbacks = {
            _tags: tags,
            _attributes: attributes,
            _regExpAttributes: regExpAttributes,
            defaultCallback: defaultCallback,
            tag: tag,
            attr: attr,
            attrs: attrs,
            tagHandler: function (el, tagName, tagData) {
                if (renderedElements.has(el)) {
                    return;
                }
                var scope = tagData.scope, helperTagCallback = scope && scope.templateContext.tags.get(tagName), tagCallback = helperTagCallback || tags[tagName] || el[initializeSymbol], res;
                if (tagCallback) {
                    res = ObservationRecorder.ignore(tagCallback)(el, tagData);
                    renderedElements.set(el, true);
                } else {
                    res = scope;
                }
                if (res && tagData.subtemplate) {
                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);
                    nodeList.expression = '<' + el.tagName + '>';
                    var result = tagData.subtemplate(scope, tagData.options, nodeList);
                    var frag = typeof result === 'string' ? makeFrag(result) : result;
                    domMutateNode.appendChild.call(el, frag);
                }
            }
        };
        namespace.view = namespace.view || {};
        if (namespace.view.callbacks) {
            throw new Error('You can\'t have two versions of can-view-callbacks, check your dependencies');
        } else {
            module.exports = namespace.view.callbacks = callbacks;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-target@4.1.6#can-view-target*/
define('can-view-target@4.1.6#can-view-target', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-dom-mutate/node',
    'can-namespace',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var domMutate = require('can-dom-mutate/node');
        var namespace = require('can-namespace');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        var processNodes = function (nodes, paths, location, document) {
                var frag = document.createDocumentFragment();
                for (var i = 0, len = nodes.length; i < len; i++) {
                    var node = nodes[i];
                    frag.appendChild(processNode(node, paths, location.concat(i), document));
                }
                return frag;
            }, keepsTextNodes = typeof document !== 'undefined' && function () {
                var testFrag = document.createDocumentFragment();
                var div = document.createElement('div');
                div.appendChild(document.createTextNode(''));
                div.appendChild(document.createTextNode(''));
                testFrag.appendChild(div);
                var cloned = testFrag.cloneNode(true);
                return cloned.firstChild.childNodes.length === 2;
            }(), clonesWork = typeof document !== 'undefined' && function () {
                var el = document.createElement('a');
                el.innerHTML = '<xyz></xyz>';
                var clone = el.cloneNode(true);
                var works = clone.innerHTML === '<xyz></xyz>';
                var MO, observer;
                if (works) {
                    el = document.createDocumentFragment();
                    el.appendChild(document.createTextNode('foo-bar'));
                    MO = MUTATION_OBSERVER();
                    if (MO) {
                        observer = new MO(function () {
                        });
                        observer.observe(document.documentElement, {
                            childList: true,
                            subtree: true
                        });
                        clone = el.cloneNode(true);
                        observer.disconnect();
                    } else {
                        clone = el.cloneNode(true);
                    }
                    return clone.childNodes.length === 1;
                }
                return works;
            }(), namespacesWork = typeof document !== 'undefined' && !!document.createElementNS;
        var cloneNode = clonesWork ? function (el) {
            return el.cloneNode(true);
        } : function (node) {
            var document = node.ownerDocument;
            var copy;
            if (node.nodeType === 1) {
                if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {
                    copy = document.createElementNS(node.namespaceURI, node.nodeName);
                } else {
                    copy = document.createElement(node.nodeName);
                }
            } else if (node.nodeType === 3) {
                copy = document.createTextNode(node.nodeValue);
            } else if (node.nodeType === 8) {
                copy = document.createComment(node.nodeValue);
            } else if (node.nodeType === 11) {
                copy = document.createDocumentFragment();
            }
            if (node.attributes) {
                var attributes = node.attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    if (attribute && attribute.specified) {
                        if (attribute.namespaceURI) {
                            copy.setAttributeNS(attribute.namespaceURI, attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);
                        } else {
                            copy.setAttribute(attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);
                        }
                    }
                }
            }
            if (node && node.firstChild) {
                var child = node.firstChild;
                while (child) {
                    copy.appendChild(cloneNode(child));
                    child = child.nextSibling;
                }
            }
            return copy;
        };
        function processNode(node, paths, location, document) {
            var callback, loc = location, nodeType = typeof node, el, p, i, len;
            var getCallback = function () {
                if (!callback) {
                    callback = {
                        path: location,
                        callbacks: []
                    };
                    paths.push(callback);
                    loc = [];
                }
                return callback;
            };
            if (nodeType === 'object') {
                if (node.tag) {
                    if (namespacesWork && node.namespace) {
                        el = document.createElementNS(node.namespace, node.tag);
                    } else {
                        el = document.createElement(node.tag);
                    }
                    if (node.attrs) {
                        for (var attrName in node.attrs) {
                            var value = node.attrs[attrName];
                            if (typeof value === 'function') {
                                getCallback().callbacks.push({ callback: value });
                            } else if (value !== null && typeof value === 'object' && value.namespaceURI) {
                                el.setAttributeNS(value.namespaceURI, attrName, value.value);
                            } else {
                                domMutate.setAttribute.call(el, attrName, value);
                            }
                        }
                    }
                    if (node.attributes) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.attributes[i] });
                        }
                    }
                    if (node.children && node.children.length) {
                        if (callback) {
                            p = callback.paths = [];
                        } else {
                            p = paths;
                        }
                        el.appendChild(processNodes(node.children, p, loc, document));
                    }
                } else if (node.comment) {
                    el = document.createComment(node.comment);
                    if (node.callbacks) {
                        for (i = 0, len = node.callbacks.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.callbacks[i] });
                        }
                    }
                }
            } else if (nodeType === 'string') {
                el = document.createTextNode(node);
            } else if (nodeType === 'function') {
                if (keepsTextNodes) {
                    el = document.createTextNode('');
                    getCallback().callbacks.push({ callback: node });
                } else {
                    el = document.createComment('~');
                    getCallback().callbacks.push({
                        callback: function () {
                            var el = document.createTextNode('');
                            domMutate.replaceChild.call(this.parentNode, el, this);
                            return node.apply(el, arguments);
                        }
                    });
                }
            }
            return el;
        }
        function getCallbacks(el, pathData, elementCallbacks) {
            var path = pathData.path, callbacks = pathData.callbacks, paths = pathData.paths, child = el, pathLength = path ? path.length : 0, pathsLength = paths ? paths.length : 0;
            for (var i = 0; i < pathLength; i++) {
                child = child.childNodes.item(path[i]);
            }
            for (i = 0; i < pathsLength; i++) {
                getCallbacks(child, paths[i], elementCallbacks);
            }
            elementCallbacks.push({
                element: child,
                callbacks: callbacks
            });
        }
        function hydrateCallbacks(callbacks, args) {
            var len = callbacks.length, callbacksLength, callbackElement, callbackData;
            for (var i = 0; i < len; i++) {
                callbackData = callbacks[i];
                callbacksLength = callbackData.callbacks.length;
                callbackElement = callbackData.element;
                for (var c = 0; c < callbacksLength; c++) {
                    callbackData.callbacks[c].callback.apply(callbackElement, args);
                }
            }
        }
        function makeTarget(nodes, doc) {
            var paths = [];
            var frag = processNodes(nodes, paths, [], doc || getDocument());
            return {
                paths: paths,
                clone: frag,
                hydrate: function () {
                    var cloned = cloneNode(this.clone);
                    var args = [];
                    for (var a = 0, ref = args.length = arguments.length; a < ref; a++) {
                        args[a] = arguments[a];
                    }
                    var callbacks = [];
                    for (var i = 0; i < paths.length; i++) {
                        getCallbacks(cloned, paths[i], callbacks);
                    }
                    hydrateCallbacks(callbacks, args);
                    return cloned;
                }
            };
        }
        makeTarget.keepsTextNodes = keepsTextNodes;
        makeTarget.cloneNode = cloneNode;
        namespace.view = namespace.view || {};
        module.exports = namespace.view.target = makeTarget;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect-promise@2.2.1#can-reflect-promise*/
define('can-reflect-promise@2.2.1#can-reflect-promise', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    'can-queues',
    'can-key-tree',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var queues = require('can-queues');
    var KeyTree = require('can-key-tree');
    var dev = require('can-log/dev/dev');
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue'), observeDataSymbol = canSymbol.for('can.meta');
    var promiseDataPrototype = {
        isPending: true,
        state: 'pending',
        isResolved: false,
        isRejected: false,
        value: undefined,
        reason: undefined
    };
    function setVirtualProp(promise, property, value) {
        var observeData = promise[observeDataSymbol];
        var old = observeData[property];
        observeData[property] = value;
        queues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [
            value,
            old
        ], function () {
            return {};
        }, [
            'Promise',
            promise,
            'resolved with value',
            value,
            'and changed virtual property: ' + property
        ]);
    }
    function initPromise(promise) {
        var observeData = promise[observeDataSymbol];
        if (!observeData) {
            Object.defineProperty(promise, observeDataSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: Object.create(promiseDataPrototype)
            });
            observeData = promise[observeDataSymbol];
            observeData.handlers = new KeyTree([
                Object,
                Object,
                Array
            ]);
        }
        promise.then(function (value) {
            queues.batch.start();
            setVirtualProp(promise, 'isPending', false);
            setVirtualProp(promise, 'isResolved', true);
            setVirtualProp(promise, 'value', value);
            setVirtualProp(promise, 'state', 'resolved');
            queues.batch.stop();
        }, function (reason) {
            queues.batch.start();
            setVirtualProp(promise, 'isPending', false);
            setVirtualProp(promise, 'isRejected', true);
            setVirtualProp(promise, 'reason', reason);
            setVirtualProp(promise, 'state', 'rejected');
            queues.batch.stop();
        });
    }
    function setupPromise(value) {
        var oldPromiseFn;
        var proto = 'getPrototypeOf' in Object ? Object.getPrototypeOf(value) : value.__proto__;
        if (value[getKeyValueSymbol] && value[observeDataSymbol]) {
            return;
        }
        if (proto === null || proto === Object.prototype) {
            proto = value;
            if (typeof proto.promise === 'function') {
                oldPromiseFn = proto.promise;
                proto.promise = function () {
                    var result = oldPromiseFn.call(proto);
                    setupPromise(result);
                    return result;
                };
            }
        }
        canReflect.assignSymbols(proto, {
            'can.getKeyValue': function (key) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                ObservationRecorder.add(this, key);
                switch (key) {
                case 'state':
                case 'isPending':
                case 'isResolved':
                case 'isRejected':
                case 'value':
                case 'reason':
                    return this[observeDataSymbol][key];
                default:
                    return this[key];
                }
            },
            'can.getValue': function () {
                return this[getKeyValueSymbol]('value');
            },
            'can.isValueLike': false,
            'can.onKeyValue': function (key, handler, queue) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                this[observeDataSymbol].handlers.add([
                    key,
                    queue || 'mutate',
                    handler
                ]);
            },
            'can.offKeyValue': function (key, handler, queue) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                this[observeDataSymbol].handlers.delete([
                    key,
                    queue || 'mutate',
                    handler
                ]);
            },
            'can.hasOwnKey': function (key) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                return key in this[observeDataSymbol];
            }
        });
    }
    module.exports = setupPromise;
});
/*can-stache-key@1.4.3#can-stache-key*/
define('can-stache-key@1.4.3#can-stache-key', [
    'require',
    'exports',
    'module',
    'can-observation-recorder',
    'can-log/dev/dev',
    'can-symbol',
    'can-reflect',
    'can-reflect-promise'
], function (require, exports, module) {
    'use strict';
    var ObservationRecorder = require('can-observation-recorder');
    var dev = require('can-log/dev/dev');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var canReflectPromise = require('can-reflect-promise');
    var getValueSymbol = canSymbol.for('can.getValue');
    var setValueSymbol = canSymbol.for('can.setValue');
    var isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));
    var observeReader;
    var isPromiseLike = ObservationRecorder.ignore(function isPromiseLike(value) {
        return typeof value === 'object' && value && typeof value.then === 'function';
    });
    var bindName = Function.prototype.bind;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (ObservationRecorder.trapsCount()) {
                ObservationRecorder.addMany(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    var objHasKeyAtIndex = function (obj, reads, index) {
        return !!(reads && reads.length && canReflect.hasKey(obj, reads[index].key));
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = ObservationRecorder.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last, parentHasKey;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || cur === undefined)) {
                    parentHasKey = objHasKeyAtIndex(prev, reads, i - 1);
                    if (options.earlyExit && !parentHasKey) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev,
                        parentHasKey: parentHasKey,
                        foundLastParent: false
                    };
                }
            }
            parentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);
            if (cur === undefined && !parentHasKey) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev,
                parentHasKey: parentHasKey,
                foundLastParent: true
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value) {
                    return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
                        dev.warn('can-stache-key: read() called with `callMethodsOnObservables: true`.');
                        return value.apply(prev, options.args || []);
                    }
                    return options.proxyMethods !== false ? bindName.call(value, prev) : value;
                }
            },
            {
                name: 'isValueLike',
                test: function (value, i, reads, options) {
                    return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads));
                },
                read: function (value, i, reads, options) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return canReflect.getValue(value);
                },
                write: function (base, newVal) {
                    if (base[setValueSymbol]) {
                        base[setValueSymbol](newVal);
                    } else if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function (value) {
                    if (canReflect.isPromise(value) || isPromiseLike(value)) {
                        canReflectPromise(value);
                    }
                    return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
                },
                read: function (value, prop) {
                    var res = canReflect.getKeyValue(value, prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: canReflect.setKeyValue
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop, i, options) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    var propValue = base[prop];
                    if (newVal != null && typeof newVal === 'object' && canReflect.isMapLike(propValue)) {
                        dev.warn('can-stache-key: Merging data into "' + prop + '" because its parent is non-observable');
                        canReflect.update(propValue, newVal);
                    } else if (propValue != null && propValue[setValueSymbol] !== undefined) {
                        canReflect.setValue(propValue, newVal);
                    } else {
                        base[prop] = newVal;
                    }
                }
            }
        ],
        reads: function (keyArg) {
            var key = '' + keyArg;
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            options = options || {};
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            if (!parent) {
                return;
            }
            var keyValue = peek(parent, last.key);
            if (observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.isValueLike.write(keyValue, value, options);
            } else {
                if (observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options)) {
                    parent = parent[getValueSymbol]();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                    if (options.observation) {
                        options.observation.update();
                    }
                }
            }
        }
    };
    observeReader.propertyReaders.forEach(function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    observeReader.valueReaders.forEach(function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-simple-map@4.3.2#can-simple-map*/
define('can-simple-map@4.3.2#can-simple-map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-event-queue/map/map',
    'can-queues',
    'can-observation-recorder',
    'can-reflect',
    'can-log/dev/dev',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var Construct = require('can-construct');
    var eventQueue = require('can-event-queue/map/map');
    var queues = require('can-queues');
    var ObservationRecorder = require('can-observation-recorder');
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var canSymbol = require('can-symbol');
    var ensureMeta = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
    var SimpleMap = Construct.extend('SimpleMap', {
        setup: function (initialData) {
            this._data = {};
            if (initialData && typeof initialData === 'object') {
                this.attr(initialData);
            }
        },
        attr: function (prop, value) {
            var self = this;
            if (arguments.length === 0) {
                ObservationRecorder.add(this, 'can.keys');
                var data = {};
                canReflect.eachKey(this._data, function (value, prop) {
                    ObservationRecorder.add(this, prop);
                    data[prop] = value;
                }, this);
                return data;
            } else if (arguments.length > 1) {
                var had = this._data.hasOwnProperty(prop);
                var old = this._data[prop];
                this._data[prop] = value;
                if (old !== value) {
                    var dispatched = {
                        keyChanged: !had ? prop : undefined,
                        type: prop
                    };
                    this.dispatch(dispatched, [
                        value,
                        old
                    ]);
                }
            } else if (typeof prop === 'object') {
                queues.batch.start();
                canReflect.eachKey(prop, function (value, key) {
                    self.attr(key, value);
                });
                queues.batch.stop();
            } else {
                if (prop !== 'constructor') {
                    ObservationRecorder.add(this, prop);
                    return this._data[prop];
                }
                return this.constructor;
            }
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        },
        get: function () {
            return this.attr.apply(this, arguments);
        },
        set: function () {
            return this.attr.apply(this, arguments);
        },
        log: function (key) {
        }
    });
    eventQueue(SimpleMap.prototype);
    var simpleMapProto = {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': SimpleMap.prototype.get,
        'can.setKeyValue': SimpleMap.prototype.set,
        'can.deleteKeyValue': function (prop) {
            var dispatched;
            if (this._data.hasOwnProperty(prop)) {
                var old = this._data[prop];
                delete this._data[prop];
                dispatched = {
                    keyChanged: prop,
                    type: prop
                };
                this.dispatch(dispatched, [
                    undefined,
                    old
                ]);
            }
        },
        'can.getOwnEnumerableKeys': function () {
            ObservationRecorder.add(this, 'can.keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignMap(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            canReflect.updateMap(this, source);
            queues.batch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return false;
        },
        'can.getKeyDependencies': function (key) {
            return undefined;
        },
        'can.hasOwnKey': function (key) {
            return this._data.hasOwnProperty(key);
        }
    };
    canReflect.assignSymbols(SimpleMap.prototype, simpleMapProto);
    module.exports = SimpleMap;
});
/*can-view-scope@4.13.6#template-context*/
define('can-view-scope@4.13.6#template-context', [
    'require',
    'exports',
    'module',
    'can-simple-map'
], function (require, exports, module) {
    'use strict';
    var SimpleMap = require('can-simple-map');
    var TemplateContext = function (options) {
        options = options || {};
        this.vars = new SimpleMap(options.vars || {});
        this.helpers = new SimpleMap(options.helpers || {});
        this.partials = new SimpleMap(options.partials || {});
        this.tags = new SimpleMap(options.tags || {});
    };
    module.exports = TemplateContext;
});
/*can-cid@1.3.1#can-cid*/
define('can-cid@1.3.1#can-cid', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var _cid = 0;
    var domExpando = 'can' + new Date();
    var cid = function (object, name) {
        var propertyName = object.nodeName ? domExpando : '_cid';
        if (!object[propertyName]) {
            _cid++;
            object[propertyName] = (name || '') + _cid;
        }
        return object[propertyName];
    };
    cid.domExpando = domExpando;
    cid.get = function (object) {
        var type = typeof object;
        var isObject = type !== null && (type === 'object' || type === 'function');
        return isObject ? cid(object) : type + ':' + object;
    };
    if (namespace.cid) {
        throw new Error('You can\'t have two versions of can-cid, check your dependencies');
    } else {
        module.exports = namespace.cid = cid;
    }
});
/*can-single-reference@1.3.0#can-single-reference*/
define('can-single-reference@1.3.0#can-single-reference', [
    'require',
    'exports',
    'module',
    'can-cid'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var CID = require('can-cid');
        var singleReference;
        function getKeyName(key, extraKey) {
            var keyName = extraKey ? CID(key) + ':' + extraKey : CID(key);
            return keyName || key;
        }
        singleReference = {
            set: function (obj, key, value, extraKey) {
                obj[getKeyName(key, extraKey)] = value;
            },
            getAndDelete: function (obj, key, extraKey) {
                var keyName = getKeyName(key, extraKey);
                var value = obj[keyName];
                delete obj[keyName];
                return value;
            }
        };
        module.exports = singleReference;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-scope@4.13.6#make-compute-like*/
define('can-view-scope@4.13.6#make-compute-like', [
    'require',
    'exports',
    'module',
    'can-single-reference',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var singleReference = require('can-single-reference');
    var canReflect = require('can-reflect');
    var Compute = function (newVal) {
        if (arguments.length) {
            return canReflect.setValue(this, newVal);
        } else {
            return canReflect.getValue(this);
        }
    };
    module.exports = function (observable) {
        var compute = Compute.bind(observable);
        compute.on = compute.bind = compute.addEventListener = function (event, handler) {
            var translationHandler = function (newVal, oldVal) {
                handler.call(compute, { type: 'change' }, newVal, oldVal);
            };
            singleReference.set(handler, this, translationHandler);
            observable.on(translationHandler);
        };
        compute.off = compute.unbind = compute.removeEventListener = function (event, handler) {
            observable.off(singleReference.getAndDelete(handler, this));
        };
        canReflect.assignSymbols(compute, {
            'can.getValue': function () {
                return canReflect.getValue(observable);
            },
            'can.setValue': function (newVal) {
                return canReflect.setValue(observable, newVal);
            },
            'can.onValue': function (handler, queue) {
                return canReflect.onValue(observable, handler, queue);
            },
            'can.offValue': function (handler, queue) {
                return canReflect.offValue(observable, handler, queue);
            },
            'can.valueHasDependencies': function () {
                return canReflect.valueHasDependencies(observable);
            },
            'can.getPriority': function () {
                return canReflect.getPriority(observable);
            },
            'can.setPriority': function (newPriority) {
                canReflect.setPriority(observable, newPriority);
            },
            'can.isValueLike': true,
            'can.isFunctionLike': false
        });
        compute.isComputed = true;
        return compute;
    };
});
/*can-stache-helpers@1.2.0#can-stache-helpers*/
define('can-stache-helpers@1.2.0#can-stache-helpers', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    if (namespace.stacheHelpers) {
        throw new Error('You can\'t have two versions of can-stache-helpers, check your dependencies');
    } else {
        module.exports = namespace.stacheHelpers = {};
    }
});
/*can-view-scope@4.13.6#scope-key-data*/
define('can-view-scope@4.13.6#scope-key-data', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-stache-key',
    'can-assign',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    './make-compute-like',
    'can-reflect-dependencies',
    'can-event-queue/value/value',
    'can-stache-helpers',
    'can-simple-observable',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var Observation = require('can-observation');
    var observeReader = require('can-stache-key');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var makeComputeLike = require('./make-compute-like');
    var canReflectDeps = require('can-reflect-dependencies');
    var valueEventBindings = require('can-event-queue/value/value');
    var stacheHelpers = require('can-stache-helpers');
    var SimpleObservable = require('can-simple-observable');
    var dev = require('can-log/dev/dev');
    var dispatchSymbol = canSymbol.for('can.dispatch');
    var setElementSymbol = canSymbol.for('can.setElement');
    var getFastPathRoot = ObservationRecorder.ignore(function (computeData) {
        if (computeData.reads && computeData.reads.length === 1) {
            var root = computeData.root;
            if (root && root[canSymbol.for('can.getValue')]) {
                root = canReflect.getValue(root);
            }
            return root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) && typeof root[computeData.reads[0].key] !== 'function' && root;
        }
        return;
    });
    var isEventObject = function (obj) {
        return obj && typeof obj.batchNum === 'number' && typeof obj.type === 'string';
    };
    function getMutated(scopeKeyData) {
        var value = ObservationRecorder.peekValue(scopeKeyData._thisArg);
        return !canReflect.isPrimitive(value) ? value : scopeKeyData.root;
    }
    function callMutateWithRightArgs(method, mutated, reads, mutator) {
        if (reads.length) {
            method.call(canReflectDeps, mutated, reads[reads.length - 1].key, mutator);
        } else {
            method.call(canReflectDeps, mutated, mutator);
        }
    }
    var warnOnUndefinedProperty;
    var ScopeKeyData = function (scope, key, options) {
        this.startingScope = scope;
        this.key = key;
        this.read = this.read.bind(this);
        this.dispatch = this.dispatch.bind(this);
        if (key === 'debugger') {
            this.startingScope = { _context: stacheHelpers };
            this.read = function () {
                var helperOptions = { scope: scope };
                var debuggerHelper = stacheHelpers['debugger'];
                return debuggerHelper(helperOptions);
            };
        }
        var observation = this.observation = new Observation(this.read, this);
        this.options = assign({ observation: this.observation }, options);
        this.fastPath = undefined;
        this.root = undefined;
        this.reads = undefined;
        this.setRoot = undefined;
        this._thisArg = new SimpleObservable();
        this.parentHasKey = undefined;
        var valueDependencies = new Set();
        valueDependencies.add(observation);
        this.dependencies = { valueDependencies: valueDependencies };
        this._latestValue = undefined;
    };
    valueEventBindings(ScopeKeyData.prototype);
    function fastOnBoundSet_Value() {
        this._value = this.newVal;
    }
    function fastOnBoundSetValue() {
        this.value = this.newVal;
    }
    assign(ScopeKeyData.prototype, {
        constructor: ScopeKeyData,
        dispatch: function dispatch(newVal) {
            var old = this.value;
            this._latestValue = this.value = newVal;
            this[dispatchSymbol].call(this, this.value, old);
        },
        onBound: function onBound() {
            this.bound = true;
            canReflect.onValue(this.observation, this.dispatch, 'notify');
            var fastPathRoot = getFastPathRoot(this);
            if (fastPathRoot) {
                this.toFastPath(fastPathRoot);
            }
            this._latestValue = this.value = ObservationRecorder.peekValue(this.observation);
        },
        onUnbound: function onUnbound() {
            this.bound = false;
            canReflect.offValue(this.observation, this.dispatch, 'notify');
            this.toSlowPath();
        },
        set: function (newVal) {
            var root = this.root || this.setRoot;
            if (root) {
                if (this.reads.length) {
                    observeReader.write(root, this.reads, newVal, this.options);
                } else {
                    canReflect.setValue(root, newVal);
                }
            } else {
                this.startingScope.set(this.key, newVal, this.options);
            }
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    Observation.temporarilyBind(this);
                }
            }
            if (this.bound === true && this.fastPath === true) {
                return this._latestValue;
            } else {
                return ObservationRecorder.peekValue(this.observation);
            }
        },
        toFastPath: function (fastPathRoot) {
            var self = this, observation = this.observation;
            this.fastPath = true;
            observation.dependencyChange = function (target, newVal) {
                if (isEventObject(newVal)) {
                    throw 'no event objects!';
                }
                if (target === fastPathRoot && typeof newVal !== 'function') {
                    self._latestValue = newVal;
                    this.newVal = newVal;
                } else {
                    self.toSlowPath();
                }
                return Observation.prototype.dependencyChange.apply(this, arguments);
            };
            if (observation.hasOwnProperty('_value')) {
                observation.onBound = fastOnBoundSet_Value;
            } else {
                observation.onBound = fastOnBoundSetValue;
            }
        },
        toSlowPath: function () {
            this.observation.dependencyChange = Observation.prototype.dependencyChange;
            this.observation.onBound = Observation.prototype.onBound;
            this.fastPath = false;
        },
        read: function () {
            var data;
            if (this.root) {
                data = observeReader.read(this.root, this.reads, this.options);
                this.thisArg = data.parent;
                return data.value;
            }
            data = this.startingScope.read(this.key, this.options);
            this.scope = data.scope;
            this.reads = data.reads;
            this.root = data.rootObserve;
            this.setRoot = data.setRoot;
            this.thisArg = data.thisArg;
            this.parentHasKey = data.parentHasKey;
            return data.value;
        },
        hasDependencies: function () {
            if (!this.bound) {
                Observation.temporarilyBind(this);
            }
            return canReflect.valueHasDependencies(this.observation);
        }
    });
    Object.defineProperty(ScopeKeyData.prototype, 'thisArg', {
        get: function () {
            return this._thisArg.get();
        },
        set: function (newVal) {
            this._thisArg.set(newVal);
        }
    });
    var scopeKeyDataPrototype = {
        'can.getValue': ScopeKeyData.prototype.get,
        'can.setValue': ScopeKeyData.prototype.set,
        'can.valueHasDependencies': ScopeKeyData.prototype.hasDependencies,
        'can.getValueDependencies': function () {
            return this.dependencies;
        },
        'can.getPriority': function () {
            return canReflect.getPriority(this.observation);
        },
        'can.setPriority': function (newPriority) {
            canReflect.setPriority(this.observation, newPriority);
        },
        'can.setElement': function (element) {
            this.observation[setElementSymbol](element);
        }
    };
    canReflect.assignSymbols(ScopeKeyData.prototype, scopeKeyDataPrototype);
    Object.defineProperty(ScopeKeyData.prototype, 'compute', {
        get: function () {
            var compute = makeComputeLike(this);
            Object.defineProperty(this, 'compute', {
                value: compute,
                writable: false,
                configurable: false
            });
            return compute;
        },
        configurable: true
    });
    Object.defineProperty(ScopeKeyData.prototype, 'initialValue', {
        get: function () {
            if (!this.bound) {
                Observation.temporarilyBind(this);
            }
            return ObservationRecorder.peekValue(this);
        },
        set: function () {
            throw new Error('initialValue should not be set');
        },
        configurable: true
    });
    module.exports = ScopeKeyData;
});
/*can-view-scope@4.13.6#compute_data*/
define('can-view-scope@4.13.6#compute_data', [
    'require',
    'exports',
    'module',
    './scope-key-data'
], function (require, exports, module) {
    'use strict';
    var ScopeKeyData = require('./scope-key-data');
    module.exports = function (scope, key, options) {
        return new ScopeKeyData(scope, key, options || { args: [] });
    };
});
/*can-view-scope@4.13.6#let-context*/
define('can-view-scope@4.13.6#let-context', [
    'require',
    'exports',
    'module',
    'can-simple-map'
], function (require, exports, module) {
    var SimpleMap = require('can-simple-map');
    function objectCreateWithSymbolsAndSpecificProperties(obj, propertiesToKeep) {
        var newObj = {};
        if ('getOwnPropertySymbols' in Object) {
            Object.getOwnPropertySymbols(obj).forEach(function (key) {
                newObj[key] = obj[key];
            });
        }
        Object.getOwnPropertyNames(obj).forEach(function (key) {
            if (propertiesToKeep.indexOf(key) >= 0 || key.indexOf('@@symbol') === 0) {
                newObj[key] = obj[key];
            }
        });
        return Object.create(newObj);
    }
    var LetContext = SimpleMap.extend('LetContext', {});
    LetContext.prototype = objectCreateWithSymbolsAndSpecificProperties(SimpleMap.prototype, [
        'setup',
        'attr',
        'serialize',
        'get',
        'set',
        'log',
        'dispatch',
        'constructorExtends',
        'newInstance',
        '_inherit',
        '_defineProperty',
        '_overwrite',
        'instance',
        'extend',
        'ReturnValue',
        'setup',
        'init'
    ]);
    LetContext.prototype.constructor = LetContext;
    module.exports = LetContext;
});
/*can-view-scope@4.13.6#can-view-scope*/
define('can-view-scope@4.13.6#can-view-scope', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    'can-observation-recorder',
    './template-context',
    './compute_data',
    'can-assign',
    'can-namespace',
    'can-reflect',
    'can-log/dev/dev',
    'can-define-lazy-value',
    'can-stache-helpers',
    './let-context'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var stacheKey = require('can-stache-key');
        var ObservationRecorder = require('can-observation-recorder');
        var TemplateContext = require('./template-context');
        var makeComputeData = require('./compute_data');
        var assign = require('can-assign');
        var namespace = require('can-namespace');
        var canReflect = require('can-reflect');
        var canLog = require('can-log/dev/dev');
        var defineLazyValue = require('can-define-lazy-value');
        var stacheHelpers = require('can-stache-helpers');
        var LetContext = require('./let-context');
        function canHaveProperties(obj) {
            return obj != null;
        }
        function returnFalse() {
            return false;
        }
        function Scope(context, parent, meta) {
            this._context = context;
            this._parent = parent;
            this._meta = meta || {};
            this.__cache = {};
        }
        var parentContextSearch = /(\.\.\/)|(\.\/)|(this[\.@])/g;
        assign(Scope, {
            read: stacheKey.read,
            TemplateContext: TemplateContext,
            keyInfo: function (attr) {
                if (attr === './') {
                    attr = 'this';
                }
                var info = { remainingKey: attr };
                info.isScope = attr === 'scope';
                if (info.isScope) {
                    return info;
                }
                var firstSix = attr.substr(0, 6);
                info.isInScope = firstSix === 'scope.' || firstSix === 'scope@';
                if (info.isInScope) {
                    info.remainingKey = attr.substr(6);
                    return info;
                } else if (firstSix === 'scope/') {
                    info.walkScope = true;
                    info.remainingKey = attr.substr(6);
                    return info;
                } else if (attr.substr(0, 7) === '@scope/') {
                    info.walkScope = true;
                    info.remainingKey = attr.substr(7);
                    return info;
                }
                info.parentContextWalkCount = 0;
                info.remainingKey = attr.replace(parentContextSearch, function (token, parentContext, dotSlash, thisContext, index) {
                    info.isContextBased = true;
                    if (parentContext !== undefined) {
                        info.parentContextWalkCount++;
                    }
                    return '';
                });
                if (info.remainingKey === '..') {
                    info.parentContextWalkCount++;
                    info.remainingKey = 'this';
                } else if (info.remainingKey === '.' || info.remainingKey === '') {
                    info.remainingKey = 'this';
                }
                if (info.remainingKey === 'this') {
                    info.isContextBased = true;
                }
                return info;
            },
            isTemplateContextOrCanNotHaveProperties: function (currentScope) {
                var currentContext = currentScope._context;
                if (currentContext instanceof TemplateContext) {
                    return true;
                } else if (!canHaveProperties(currentContext)) {
                    return true;
                }
                return false;
            },
            shouldSkipIfSpecial: function (currentScope) {
                var isSpecialContext = currentScope._meta.special === true;
                if (isSpecialContext === true) {
                    return true;
                }
                if (Scope.isTemplateContextOrCanNotHaveProperties(currentScope)) {
                    return true;
                }
                return false;
            },
            shouldSkipEverythingButSpecial: function (currentScope) {
                var isSpecialContext = currentScope._meta.special === true;
                if (isSpecialContext === false) {
                    return true;
                }
                if (Scope.isTemplateContextOrCanNotHaveProperties(currentScope)) {
                    return true;
                }
                return false;
            },
            makeShouldExitOnSecondNormalContext: function () {
                var foundNormalContext = false;
                return function shouldExitOnSecondNormalContext(currentScope) {
                    var isNormalContext = !currentScope.isSpecial();
                    var shouldExit = isNormalContext && foundNormalContext;
                    if (isNormalContext) {
                        foundNormalContext = true;
                    }
                    return shouldExit;
                };
            },
            makeShouldExitAfterFirstNormalContext: function () {
                var foundNormalContext = false;
                return function shouldExitAfterFirstNormalContext(currentScope) {
                    if (foundNormalContext) {
                        return true;
                    }
                    var isNormalContext = !currentScope.isSpecial();
                    if (isNormalContext) {
                        foundNormalContext = true;
                    }
                    return false;
                };
            },
            makeShouldSkipSpecialContexts: function (parentContextWalkCount) {
                var walkCount = parentContextWalkCount || 0;
                return function shouldSkipSpecialContexts(currentScope) {
                    if (walkCount < 0 && currentScope._meta.notContext) {
                        return false;
                    }
                    if (currentScope.isSpecial()) {
                        return true;
                    }
                    walkCount--;
                    if (walkCount < 0) {
                        return false;
                    }
                    return true;
                };
            }
        });
        assign(Scope.prototype, {
            add: function (context, meta) {
                if (context !== this._context) {
                    return new this.constructor(context, this, meta);
                } else {
                    return this;
                }
            },
            find: function (attr, options) {
                var keyReads = stacheKey.reads(attr);
                var howToRead = {
                    shouldExit: returnFalse,
                    shouldSkip: Scope.shouldSkipIfSpecial,
                    shouldLookForHelper: true,
                    read: stacheKey.read
                };
                var result = this._walk(keyReads, options, howToRead);
                return result.value;
            },
            readFromSpecialContext: function (key) {
                return this._walk([{
                        key: key,
                        at: false
                    }], { special: true }, {
                    shouldExit: returnFalse,
                    shouldSkip: Scope.shouldSkipEverythingButSpecial,
                    shouldLookForHelper: false,
                    read: stacheKey.read
                });
            },
            readFromTemplateContext: function (key, readOptions) {
                var keyReads = stacheKey.reads(key);
                return stacheKey.read(this.templateContext, keyReads, readOptions);
            },
            read: function (attr, options) {
                options = options || {};
                return this.readKeyInfo(Scope.keyInfo(attr), options || {});
            },
            readKeyInfo: function (keyInfo, options) {
                var readValue, keyReads, howToRead = { read: options.read || stacheKey.read };
                if (keyInfo.isScope) {
                    return { value: this };
                } else if (keyInfo.isInScope) {
                    keyReads = stacheKey.reads(keyInfo.remainingKey);
                    readValue = stacheKey.read(this, keyReads, options);
                    if (typeof readValue.value === 'undefined' && !readValue.parentHasKey) {
                        readValue = this.readFromTemplateContext(keyInfo.remainingKey, options);
                    }
                    return assign(readValue, { thisArg: keyReads.length > 0 ? readValue.parent : undefined });
                } else if (keyInfo.isContextBased) {
                    if (keyInfo.remainingKey !== 'this') {
                        keyReads = stacheKey.reads(keyInfo.remainingKey);
                    } else {
                        keyReads = [];
                    }
                    howToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();
                    howToRead.shouldSkip = Scope.makeShouldSkipSpecialContexts(keyInfo.parentContextWalkCount);
                    howToRead.shouldLookForHelper = true;
                    return this._walk(keyReads, options, howToRead);
                } else if (keyInfo.walkScope) {
                    howToRead.shouldExit = returnFalse;
                    howToRead.shouldSkip = Scope.shouldSkipIfSpecial;
                    howToRead.shouldLookForHelper = true;
                    keyReads = stacheKey.reads(keyInfo.remainingKey);
                    return this._walk(keyReads, options, howToRead);
                } else {
                    keyReads = stacheKey.reads(keyInfo.remainingKey);
                    var isSpecialRead = options && options.special === true;
                    howToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();
                    howToRead.shouldSkip = isSpecialRead ? Scope.shouldSkipEverythingButSpecial : Scope.shouldSkipIfSpecial;
                    howToRead.shouldLookForHelper = isSpecialRead ? false : true;
                    return this._walk(keyReads, options, howToRead);
                }
            },
            _walk: function (keyReads, options, howToRead) {
                var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, readOptions = assign({
                        foundObservable: function (observe, nameIndex) {
                            currentObserve = observe;
                            currentReads = keyReads.slice(nameIndex);
                        },
                        earlyExit: function (parentValue, nameIndex) {
                            var isVariableScope = currentScope._meta.variable === true, updateSetObservable = false;
                            if (isVariableScope === true && nameIndex === 0) {
                                updateSetObservable = canReflect.hasKey(parentValue, keyReads[nameIndex].key);
                            } else {
                                updateSetObservable = nameIndex > setObserveDepth || nameIndex === setObserveDepth && (typeof parentValue === 'object' && canReflect.hasOwnKey(parentValue, keyReads[nameIndex].key));
                            }
                            if (updateSetObservable) {
                                currentSetObserve = currentObserve;
                                currentSetReads = currentReads;
                                setObserveDepth = nameIndex;
                            }
                        }
                    }, options);
                var isRecording = ObservationRecorder.isRecording(), readAContext = false;
                while (currentScope) {
                    if (howToRead.shouldSkip(currentScope) === true) {
                        currentScope = currentScope._parent;
                        continue;
                    }
                    if (howToRead.shouldExit(currentScope) === true) {
                        break;
                    }
                    readAContext = true;
                    currentContext = currentScope._context;
                    var getObserves = ObservationRecorder.trap();
                    var data = howToRead.read(currentContext, keyReads, readOptions);
                    var observes = getObserves();
                    if (data.value !== undefined || data.parentHasKey) {
                        if (!observes.length && isRecording) {
                            currentObserve = data.parent;
                            currentReads = keyReads.slice(keyReads.length - 1);
                        } else {
                            ObservationRecorder.addMany(observes);
                        }
                        return {
                            scope: currentScope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads,
                            thisArg: data.parent,
                            parentHasKey: data.parentHasKey
                        };
                    } else {
                        undefinedObserves.push.apply(undefinedObserves, observes);
                    }
                    currentScope = currentScope._parent;
                }
                if (howToRead.shouldLookForHelper) {
                    var helper = this.getHelperOrPartial(keyReads);
                    if (helper && helper.value) {
                        return { value: helper.value };
                    }
                }
                ObservationRecorder.addMany(undefinedObserves);
                return {
                    setRoot: currentSetObserve,
                    reads: currentSetReads,
                    value: undefined,
                    noContextAvailable: !readAContext
                };
            },
            getDataForScopeSet: function getDataForScopeSet(key, options) {
                var keyInfo = Scope.keyInfo(key);
                var firstSearchedContext;
                var opts = assign({
                    read: function (context, keys) {
                        if (firstSearchedContext === undefined && !(context instanceof LetContext)) {
                            firstSearchedContext = context;
                        }
                        if (keys.length > 1) {
                            var parentKeys = keys.slice(0, keys.length - 1);
                            var parent = stacheKey.read(context, parentKeys, options).value;
                            if (parent != null && canReflect.hasKey(parent, keys[keys.length - 1].key)) {
                                return {
                                    parent: parent,
                                    parentHasKey: true,
                                    value: undefined
                                };
                            } else {
                                return {};
                            }
                        } else if (keys.length === 1) {
                            if (canReflect.hasKey(context, keys[0].key)) {
                                return {
                                    parent: context,
                                    parentHasKey: true,
                                    value: undefined
                                };
                            } else {
                                return {};
                            }
                        } else {
                            return { value: context };
                        }
                    }
                }, options);
                var readData = this.readKeyInfo(keyInfo, opts);
                if (keyInfo.remainingKey === 'this') {
                    return {
                        parent: readData.value,
                        how: 'setValue'
                    };
                }
                var parent;
                var props = keyInfo.remainingKey.split('.');
                var propName = props.pop();
                if (readData.thisArg) {
                    parent = readData.thisArg;
                } else if (firstSearchedContext) {
                    parent = firstSearchedContext;
                }
                if (parent === undefined) {
                    return { error: 'Attempting to set a value at ' + key + ' where the context is undefined.' };
                }
                if (!canReflect.isObservableLike(parent) && canReflect.isObservableLike(parent[propName])) {
                    if (canReflect.isMapLike(parent[propName])) {
                        return {
                            parent: parent,
                            key: propName,
                            how: 'updateDeep',
                            warn: 'can-view-scope: Merging data into "' + propName + '" because its parent is non-observable'
                        };
                    } else if (canReflect.isValueLike(parent[propName])) {
                        return {
                            parent: parent,
                            key: propName,
                            how: 'setValue'
                        };
                    } else {
                        return {
                            parent: parent,
                            how: 'write',
                            key: propName,
                            passOptions: true
                        };
                    }
                } else {
                    return {
                        parent: parent,
                        how: 'write',
                        key: propName,
                        passOptions: true
                    };
                }
            },
            getHelper: function (keyReads) {
                console.warn('.getHelper is deprecated, use .getHelperOrPartial');
                return this.getHelperOrPartial(keyReads);
            },
            getHelperOrPartial: function (keyReads) {
                var scope = this, context, helper;
                while (scope) {
                    context = scope._context;
                    if (context instanceof TemplateContext) {
                        helper = stacheKey.read(context.helpers, keyReads, { proxyMethods: false });
                        if (helper.value !== undefined) {
                            return helper;
                        }
                        helper = stacheKey.read(context.partials, keyReads, { proxyMethods: false });
                        if (helper.value !== undefined) {
                            return helper;
                        }
                    }
                    scope = scope._parent;
                }
                return stacheKey.read(stacheHelpers, keyReads, { proxyMethods: false });
            },
            get: function (key, options) {
                options = assign({ isArgument: true }, options);
                var res = this.read(key, options);
                return res.value;
            },
            peek: ObservationRecorder.ignore(function (key, options) {
                return this.get(key, options);
            }),
            peak: ObservationRecorder.ignore(function (key, options) {
                return this.peek(key, options);
            }),
            getScope: function (tester) {
                var scope = this;
                while (scope) {
                    if (tester(scope)) {
                        return scope;
                    }
                    scope = scope._parent;
                }
            },
            getContext: function (tester) {
                var res = this.getScope(tester);
                return res && res._context;
            },
            getTemplateContext: function () {
                var lastScope;
                var templateContext = this.getScope(function (scope) {
                    lastScope = scope;
                    return scope._context instanceof TemplateContext;
                });
                if (!templateContext) {
                    templateContext = new Scope(new TemplateContext());
                    lastScope._parent = templateContext;
                }
                return templateContext;
            },
            addTemplateContext: function () {
                return this.add(new TemplateContext());
            },
            addLetContext: function (values) {
                return this.add(new LetContext(values || {}), { variable: true });
            },
            getRoot: function () {
                var cur = this, child = this;
                while (cur._parent) {
                    child = cur;
                    cur = cur._parent;
                }
                if (cur._context instanceof TemplateContext) {
                    cur = child;
                }
                return cur._context;
            },
            getViewModel: function () {
                var vmScope = this.getScope(function (scope) {
                    return scope._meta.viewModel;
                });
                return vmScope && vmScope._context;
            },
            getTop: function () {
                var top;
                this.getScope(function (scope) {
                    if (scope._meta.viewModel) {
                        top = scope;
                    }
                    return false;
                });
                return top && top._context;
            },
            getPathsForKey: function getPathsForKey(key) {
            },
            hasKey: function hasKey(key) {
                var reads = stacheKey.reads(key);
                var readValue;
                if (reads[0].key === 'scope') {
                    readValue = stacheKey.read(this, reads.slice(1), key);
                } else {
                    readValue = stacheKey.read(this._context, reads, key);
                }
                return readValue.foundLastParent && readValue.parentHasKey;
            },
            set: function (key, value, options) {
                options = options || {};
                var data = this.getDataForScopeSet(key, options);
                var parent = data.parent;
                if (data.warn) {
                    canLog.warn(data.warn);
                }
                switch (data.how) {
                case 'set':
                    parent.set(data.key, value, data.passOptions ? options : undefined);
                    break;
                case 'write':
                    stacheKey.write(parent, data.key, value, options);
                    break;
                case 'setValue':
                    canReflect.setValue('key' in data ? parent[data.key] : parent, value);
                    break;
                case 'setKeyValue':
                    canReflect.setKeyValue(parent, data.key, value);
                    break;
                case 'updateDeep':
                    canReflect.updateDeep(parent[data.key], value);
                    break;
                }
            },
            attr: ObservationRecorder.ignore(function (key, value, options) {
                canLog.warn('can-view-scope::attr is deprecated, please use peek, get or set');
                options = assign({ isArgument: true }, options);
                if (arguments.length === 2) {
                    return this.set(key, value, options);
                } else {
                    return this.get(key, options);
                }
            }),
            computeData: function (key, options) {
                return makeComputeData(this, key, options);
            },
            compute: function (key, options) {
                return this.computeData(key, options).compute;
            },
            cloneFromRef: function () {
                var scopes = [];
                var scope = this, context, parent;
                while (scope) {
                    context = scope._context;
                    if (context instanceof TemplateContext) {
                        parent = scope._parent;
                        break;
                    }
                    scopes.unshift(scope);
                    scope = scope._parent;
                }
                if (parent) {
                    scopes.forEach(function (scope) {
                        parent = parent.add(scope._context, scope._meta);
                    });
                    return parent;
                } else {
                    return this;
                }
            },
            isSpecial: function () {
                return this._meta.notContext || this._meta.special || this._context instanceof TemplateContext || this._meta.variable;
            }
        });
        Scope.prototype._read = Scope.prototype._walk;
        canReflect.assignSymbols(Scope.prototype, { 'can.hasKey': Scope.prototype.hasKey });
        var templateContextPrimitives = [
            'filename',
            'lineNumber'
        ];
        templateContextPrimitives.forEach(function (key) {
            Object.defineProperty(Scope.prototype, key, {
                get: function () {
                    return this.readFromTemplateContext(key).value;
                },
                set: function (val) {
                    this.templateContext[key] = val;
                }
            });
        });
        defineLazyValue(Scope.prototype, 'templateContext', function () {
            return this.getTemplateContext()._context;
        });
        defineLazyValue(Scope.prototype, 'root', function () {
            canLog.warn('`scope.root` is deprecated. Use either `scope.top`: https://canjs.com/doc/can-stache/keys/scope.html#scope_top or `scope.vm`: https://canjs.com/doc/can-stache/keys/scope.html#scope_vm instead.');
            return this.getRoot();
        });
        defineLazyValue(Scope.prototype, 'vm', function () {
            return this.getViewModel();
        });
        defineLazyValue(Scope.prototype, 'top', function () {
            return this.getTop();
        });
        defineLazyValue(Scope.prototype, 'helpers', function () {
            return stacheHelpers;
        });
        var specialKeywords = [
            'index',
            'key',
            'element',
            'event',
            'viewModel',
            'arguments',
            'helperOptions',
            'args'
        ];
        specialKeywords.forEach(function (key) {
            Object.defineProperty(Scope.prototype, key, {
                get: function () {
                    return this.readFromSpecialContext(key).value;
                }
            });
        });
        namespace.view = namespace.view || {};
        module.exports = namespace.view.Scope = Scope;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.17.21#src/key-observable*/
define('can-stache@4.17.21#src/key-observable', [
    'require',
    'exports',
    'module',
    'can-simple-observable/settable/settable',
    'can-stache-key'
], function (require, exports, module) {
    'use strict';
    var SettableObservable = require('can-simple-observable/settable/settable');
    var stacheKey = require('can-stache-key');
    function KeyObservable(root, key) {
        key = '' + key;
        this.key = key;
        this.root = root;
        SettableObservable.call(this, function () {
            return stacheKey.get(this, key);
        }, root);
    }
    KeyObservable.prototype = Object.create(SettableObservable.prototype);
    KeyObservable.prototype.set = function (newVal) {
        stacheKey.set(this.root, this.key, newVal);
    };
    module.exports = KeyObservable;
});
/*can-stache@4.17.21#src/utils*/
define('can-stache@4.17.21#src/utils', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-observation-recorder',
    'can-stache-key',
    'can-reflect',
    './key-observable',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var Scope = require('can-view-scope');
    var ObservationRecorder = require('can-observation-recorder');
    var observationReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var KeyObservable = require('./key-observable');
    var canSymbol = require('can-symbol');
    var isViewSymbol = canSymbol.for('can.isView');
    var createNoOpRenderer = function (metadata) {
        return function noop() {
            if (metadata) {
                metadata.rendered = true;
            }
        };
    };
    module.exports = {
        last: function (arr) {
            return arr != null && arr[arr.length - 1];
        },
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else {
                return JSON.parse(str);
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        createRenderers: function (helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, isStringOnly) {
            helperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
            helperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
            helperOptions.isSection = !!(truthyRenderer || falseyRenderer);
        },
        makeRendererConvertScopes: function (renderer, parentScope, nodeList, observeObservables, metadata) {
            var convertedRenderer = function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof Scope)) {
                    if (parentScope) {
                        newScope = parentScope.add(newScope);
                    } else {
                        newScope = new Scope(newScope || {});
                    }
                }
                if (metadata) {
                    metadata.rendered = true;
                }
                var result = renderer(newScope || parentScope, parentNodeList || nodeList);
                return result;
            };
            return observeObservables ? convertedRenderer : ObservationRecorder.ignore(convertedRenderer);
        },
        makeView: function (renderer) {
            var view = ObservationRecorder.ignore(function (scope, nodeList) {
                if (!(scope instanceof Scope)) {
                    scope = new Scope(scope);
                }
                return renderer(scope, nodeList);
            });
            view[isViewSymbol] = true;
            return view;
        },
        getItemsStringContent: function (items, isObserveList, helperOptions) {
            var txt = '', len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var item = isObservable ? new KeyObservable(items, i) : items[i];
                txt += helperOptions.fn(item);
            }
            return txt;
        },
        getItemsFragContent: function (items, helperOptions, scope) {
            var result = [], len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items), hashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs, hashOptions;
            if (canReflect.size(hashExprs) > 0) {
                hashOptions = {};
                canReflect.eachKey(hashExprs, function (exprs, key) {
                    hashOptions[exprs.key] = key;
                });
            }
            for (var i = 0; i < len; i++) {
                var aliases = {};
                var item = isObservable ? new KeyObservable(items, i) : items[i];
                if (canReflect.size(hashOptions) > 0) {
                    if (hashOptions.value) {
                        aliases[hashOptions.value] = item;
                    }
                    if (hashOptions.index) {
                        aliases[hashOptions.index] = i;
                    }
                }
                result.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add({ index: i }, { special: true }).add(item)));
            }
            return result;
        }
    };
});
/*can-stache@4.17.21#src/html_section*/
define('can-stache@4.17.21#src/html_section', [
    'require',
    'exports',
    'module',
    'can-view-target',
    './utils',
    'can-globals/document/document',
    'can-assign'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var target = require('can-view-target');
        var utils = require('./utils');
        var getDocument = require('can-globals/document/document');
        var assign = require('can-assign');
        var last = utils.last;
        var decodeHTML = typeof document !== 'undefined' && function () {
            var el = getDocument().createElement('div');
            return function (html) {
                if (html.indexOf('&') === -1) {
                    return html.replace(/\r\n/g, '\n');
                }
                el.innerHTML = html;
                return el.childNodes.length === 0 ? '' : el.childNodes.item(0).nodeValue;
            };
        }();
        var HTMLSectionBuilder = function (filename) {
            if (filename) {
                this.filename = filename;
            }
            this.stack = [new HTMLSection()];
        };
        assign(HTMLSectionBuilder.prototype, utils.mixins);
        assign(HTMLSectionBuilder.prototype, {
            startSubSection: function (process) {
                var newSection = new HTMLSection(process);
                this.stack.push(newSection);
                return newSection;
            },
            endSubSectionAndReturnRenderer: function () {
                if (this.last().isEmpty()) {
                    this.stack.pop();
                    return null;
                } else {
                    var htmlSection = this.endSection();
                    return utils.makeView(htmlSection.compiled.hydrate.bind(htmlSection.compiled));
                }
            },
            startSection: function (process) {
                var newSection = new HTMLSection(process);
                this.last().add(newSection.targetCallback);
                this.stack.push(newSection);
            },
            endSection: function () {
                this.last().compile();
                return this.stack.pop();
            },
            inverse: function () {
                this.last().inverse();
            },
            compile: function () {
                var compiled = this.stack.pop().compile();
                return utils.makeView(compiled.hydrate.bind(compiled));
            },
            push: function (chars) {
                this.last().push(chars);
            },
            pop: function () {
                return this.last().pop();
            },
            removeCurrentNode: function () {
                this.last().removeCurrentNode();
            }
        });
        var HTMLSection = function (process) {
            this.data = 'targetData';
            this.targetData = [];
            this.targetStack = [];
            var self = this;
            this.targetCallback = function (scope, sectionNode) {
                process.call(this, scope, sectionNode, self.compiled.hydrate.bind(self.compiled), self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled));
            };
        };
        assign(HTMLSection.prototype, {
            inverse: function () {
                this.inverseData = [];
                this.data = 'inverseData';
            },
            push: function (data) {
                this.add(data);
                this.targetStack.push(data);
            },
            pop: function () {
                return this.targetStack.pop();
            },
            add: function (data) {
                if (typeof data === 'string') {
                    data = decodeHTML(data);
                }
                if (this.targetStack.length) {
                    last(this.targetStack).children.push(data);
                } else {
                    this[this.data].push(data);
                }
            },
            compile: function () {
                this.compiled = target(this.targetData, getDocument());
                if (this.inverseData) {
                    this.inverseCompiled = target(this.inverseData, getDocument());
                    delete this.inverseData;
                }
                this.targetStack = this.targetData = null;
                return this.compiled;
            },
            removeCurrentNode: function () {
                var children = this.children();
                return children.pop();
            },
            children: function () {
                if (this.targetStack.length) {
                    return last(this.targetStack).children;
                } else {
                    return this[this.data];
                }
            },
            isEmpty: function () {
                return !this.targetData.length;
            }
        });
        HTMLSectionBuilder.HTMLSection = HTMLSection;
        module.exports = HTMLSectionBuilder;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-live@4.2.8#lib/core*/
define('can-view-live@4.2.8#lib/core', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-dom-mutate',
    'can-view-nodelist',
    'can-fragment',
    'can-child-nodes',
    'can-reflect',
    'can-reflect-dependencies'
], function (require, exports, module) {
    'use strict';
    var parser = require('can-view-parser');
    var domMutate = require('can-dom-mutate');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-fragment');
    var childNodes = require('can-child-nodes');
    var canReflect = require('can-reflect');
    var canReflectDeps = require('can-reflect-dependencies');
    function contains(parent, child) {
        if (parent.contains) {
            return parent.contains(child);
        }
        if (parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {
            return contains(parent.documentElement, child);
        } else {
            child = child.parentNode;
            if (child === parent) {
                return true;
            }
            return false;
        }
    }
    var live = {
        setup: function (el, bind, unbind) {
            var tornDown = false, removalDisposal, data, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        if (removalDisposal) {
                            removalDisposal();
                            removalDisposal = undefined;
                        }
                    }
                    return true;
                };
            data = {
                teardownCheck: function (parent) {
                    return parent ? false : teardown();
                }
            };
            removalDisposal = domMutate.onNodeRemoval(el, function () {
                var doc = el.ownerDocument;
                if (!contains(doc, el)) {
                    teardown();
                }
            });
            bind(data);
            return data;
        },
        listen: function (el, compute, change, queueName) {
            return live.setup(el, function bind() {
                canReflect.onValue(compute, change, queueName || 'notify');
            }, function unbind(data) {
                canReflect.offValue(compute, change, queueName || 'notify');
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        },
        getAttributeParts: function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        },
        isNode: function (obj) {
            return obj && obj.nodeType;
        },
        addTextNodeIfNoChildren: function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = makeFrag(val);
            nodeLists.register(nodes, teardown);
            nodeLists.update(nodes, childNodes(frag));
            nodeLists.replace(oldNodes, frag);
            return nodes;
        },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        makeString: function (txt) {
            return txt == null ? '' : '' + txt;
        }
    };
    module.exports = live;
});
/*can-dom-data@1.0.3#can-dom-data*/
define('can-dom-data@1.0.3#can-dom-data', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var isEmptyObject = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
    var data = new WeakMap();
    var deleteNode = function (node) {
        var nodeDeleted = false;
        if (data.has(node)) {
            nodeDeleted = true;
            data.delete(node);
        }
        return nodeDeleted;
    };
    var setData = function (node, name, value) {
        var store = data.get(node);
        if (store === undefined) {
            store = {};
            data.set(node, store);
        }
        if (name !== undefined) {
            store[name] = value;
        }
        return store;
    };
    var domData = {
        _data: data,
        get: function (node, key) {
            var store = data.get(node);
            return key === undefined ? store : store && store[key];
        },
        set: setData,
        clean: function (node, prop) {
            var itemData = data.get(node);
            if (itemData && itemData[prop]) {
                delete itemData[prop];
            }
            if (isEmptyObject(itemData)) {
                deleteNode(node);
            }
        },
        delete: deleteNode
    };
    if (namespace.domData) {
        throw new Error('You can\'t have two versions of can-dom-data, check your dependencies');
    } else {
        module.exports = namespace.domData = domData;
    }
});
/*can-attribute-observable@1.2.7#behaviors*/
define('can-attribute-observable@1.2.7#behaviors', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/global/global',
    'can-dom-data',
    'can-dom-events',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-globals/mutation-observer/mutation-observer',
    'can-diff/list/list',
    'can-queues'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var global = require('can-globals/global/global')();
        var setData = require('can-dom-data');
        var domEvents = require('can-dom-events');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var diff = require('can-diff/list/list');
        var queues = require('can-queues');
        var xmlnsAttrNamespaceURI = 'http://www.w3.org/2000/xmlns/';
        var xlinkHrefAttrNamespaceURI = 'http://www.w3.org/1999/xlink';
        var attrsNamespacesURI = {
            'xmlns': xmlnsAttrNamespaceURI,
            'xlink:href': xlinkHrefAttrNamespaceURI
        };
        var formElements = {
                'INPUT': true,
                'TEXTAREA': true,
                'SELECT': true,
                'BUTTON': true
            }, toString = function (value) {
                if (value == null) {
                    return '';
                } else {
                    return '' + value;
                }
            }, isSVG = function (el) {
                return el.namespaceURI === 'http://www.w3.org/2000/svg';
            }, truthy = function () {
                return true;
            }, getSpecialTest = function (special) {
                return special && special.test || truthy;
            }, propProp = function (prop, obj) {
                obj = obj || {};
                obj.get = function () {
                    return this[prop];
                };
                obj.set = function (value) {
                    if (this[prop] !== value) {
                        this[prop] = value;
                    }
                };
                return obj;
            }, booleanProp = function (prop) {
                return {
                    isBoolean: true,
                    set: function (value) {
                        if (prop in this) {
                            this[prop] = value;
                        } else {
                            domMutateNode.setAttribute.call(this, prop, '');
                        }
                    },
                    remove: function () {
                        this[prop] = false;
                    }
                };
            }, setupMO = function (el, callback) {
                var attrMO = setData.get(el, 'attrMO');
                if (!attrMO) {
                    var onMutation = function () {
                        callback.call(el);
                    };
                    var MO = getMutationObserver();
                    if (MO) {
                        var observer = new MO(onMutation);
                        observer.observe(el, {
                            childList: true,
                            subtree: true
                        });
                        setData.set(el, 'attrMO', observer);
                    } else {
                        setData.set(el, 'attrMO', true);
                        setData.set(el, 'canBindingCallback', { onMutation: onMutation });
                    }
                }
            }, _findOptionToSelect = function (parent, value) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION' && value === child.value) {
                        return child;
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        var groupChild = _findOptionToSelect(child, value);
                        if (groupChild) {
                            return groupChild;
                        }
                    }
                    child = child.nextSibling;
                }
            }, setChildOptions = function (el, value) {
                var option;
                if (value != null) {
                    option = _findOptionToSelect(el, value);
                }
                if (option) {
                    option.selected = true;
                } else {
                    el.selectedIndex = -1;
                }
            }, forEachOption = function (parent, fn) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION') {
                        fn(child);
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        forEachOption(child, fn);
                    }
                    child = child.nextSibling;
                }
            }, collectSelectedOptions = function (parent) {
                var selectedValues = [];
                forEachOption(parent, function (option) {
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                });
                return selectedValues;
            }, markSelectedOptions = function (parent, values) {
                forEachOption(parent, function (option) {
                    option.selected = values.indexOf(option.value) !== -1;
                });
            }, setChildOptionsOnChange = function (select, aEL) {
                var handler = setData.get(select, 'attrSetChildOptions');
                if (handler) {
                    return Function.prototype;
                }
                handler = function () {
                    setChildOptions(select, select.value);
                };
                setData.set(select, 'attrSetChildOptions', handler);
                aEL.call(select, 'change', handler);
                return function (rEL) {
                    setData.clean(select, 'attrSetChildOptions');
                    rEL.call(select, 'change', handler);
                };
            }, behaviorRules = new Map(), isPropWritable = function (el, prop) {
                var desc = Object.getOwnPropertyDescriptor(el, prop);
                if (desc) {
                    return desc.writable || desc.set;
                } else {
                    var proto = Object.getPrototypeOf(el);
                    if (proto) {
                        return isPropWritable(proto, prop);
                    }
                }
                return false;
            }, cacheRule = function (el, attrOrPropName, rule) {
                var rulesForElementType;
                rulesForElementType = behaviorRules.get(el.prototype);
                if (!rulesForElementType) {
                    rulesForElementType = {};
                    behaviorRules.set(el.constructor, rulesForElementType);
                }
                rulesForElementType[attrOrPropName] = rule;
                return rule;
            };
        var specialAttributes = {
            checked: {
                get: function () {
                    return this.checked;
                },
                set: function (val) {
                    var notFalse = !!val || val === '' || arguments.length === 0;
                    this.checked = notFalse;
                    if (notFalse && this.type === 'radio') {
                        this.defaultChecked = true;
                    }
                },
                remove: function () {
                    this.checked = false;
                },
                test: function () {
                    return this.nodeName === 'INPUT';
                }
            },
            'class': {
                get: function () {
                    if (isSVG(this)) {
                        return this.getAttribute('class');
                    }
                    return this.className;
                },
                set: function (val) {
                    val = val || '';
                    if (isSVG(this)) {
                        domMutateNode.setAttribute.call(this, 'class', '' + val);
                    } else {
                        this.className = val;
                    }
                }
            },
            disabled: booleanProp('disabled'),
            focused: {
                get: function () {
                    return this === document.activeElement;
                },
                set: function (val) {
                    var cur = attr.get(this, 'focused');
                    var docEl = this.ownerDocument.documentElement;
                    var element = this;
                    function focusTask() {
                        if (val) {
                            element.focus();
                        } else {
                            element.blur();
                        }
                    }
                    if (cur !== val) {
                        if (!docEl.contains(element)) {
                            var insertionDisposal = domMutate.onNodeInsertion(element, function () {
                                insertionDisposal();
                                focusTask();
                            });
                        } else {
                            queues.enqueueByQueue({ mutate: [focusTask] }, null, []);
                        }
                    }
                    return true;
                },
                addEventListener: function (eventName, handler, aEL) {
                    aEL.call(this, 'focus', handler);
                    aEL.call(this, 'blur', handler);
                    return function (rEL) {
                        rEL.call(this, 'focus', handler);
                        rEL.call(this, 'blur', handler);
                    };
                },
                test: function () {
                    return this.nodeName === 'INPUT';
                }
            },
            'for': propProp('htmlFor'),
            innertext: propProp('innerText'),
            innerhtml: propProp('innerHTML'),
            innerHTML: propProp('innerHTML', {
                addEventListener: function (eventName, handler, aEL) {
                    var handlers = [];
                    var el = this;
                    [
                        'change',
                        'blur'
                    ].forEach(function (eventName) {
                        var localHandler = function () {
                            handler.apply(this, arguments);
                        };
                        domEvents.addEventListener(el, eventName, localHandler);
                        handlers.push([
                            eventName,
                            localHandler
                        ]);
                    });
                    return function (rEL) {
                        handlers.forEach(function (info) {
                            rEL.call(el, info[0], info[1]);
                        });
                    };
                }
            }),
            required: booleanProp('required'),
            readonly: booleanProp('readOnly'),
            selected: {
                get: function () {
                    return this.selected;
                },
                set: function (val) {
                    val = !!val;
                    setData.set(this, 'lastSetValue', val);
                    this.selected = val;
                },
                addEventListener: function (eventName, handler, aEL) {
                    var option = this;
                    var select = this.parentNode;
                    var lastVal = option.selected;
                    var localHandler = function (changeEvent) {
                        var curVal = option.selected;
                        lastVal = setData.get(option, 'lastSetValue') || lastVal;
                        if (curVal !== lastVal) {
                            lastVal = curVal;
                            domEvents.dispatch(option, eventName);
                        }
                    };
                    var removeChangeHandler = setChildOptionsOnChange(select, aEL);
                    domEvents.addEventListener(select, 'change', localHandler);
                    aEL.call(option, eventName, handler);
                    return function (rEL) {
                        removeChangeHandler(rEL);
                        domEvents.removeEventListener(select, 'change', localHandler);
                        rEL.call(option, eventName, handler);
                    };
                },
                test: function () {
                    return this.nodeName === 'OPTION' && this.parentNode && this.parentNode.nodeName === 'SELECT';
                }
            },
            style: {
                set: function () {
                    var el = global.document && getDocument().createElement('div');
                    if (el && el.style && 'cssText' in el.style) {
                        return function (val) {
                            this.style.cssText = val || '';
                        };
                    } else {
                        return function (val) {
                            domMutateNode.setAttribute.call(this, 'style', val);
                        };
                    }
                }()
            },
            textcontent: propProp('textContent'),
            value: {
                get: function () {
                    var value = this.value;
                    if (this.nodeName === 'SELECT') {
                        if ('selectedIndex' in this && this.selectedIndex === -1) {
                            value = undefined;
                        }
                    }
                    return value;
                },
                set: function (value) {
                    var nodeName = this.nodeName.toLowerCase();
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        value = toString(value);
                    }
                    if (this.value !== value || nodeName === 'option') {
                        this.value = value;
                    }
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        this.defaultValue = value;
                    }
                    if (nodeName === 'select') {
                        setData.set(this, 'attrValueLastVal', value);
                        setChildOptions(this, value === null ? value : this.value);
                        var docEl = this.ownerDocument.documentElement;
                        if (!docEl.contains(this)) {
                            var select = this;
                            var insertionDisposal = domMutate.onNodeInsertion(select, function () {
                                insertionDisposal();
                                setChildOptions(select, value === null ? value : select.value);
                            });
                        }
                        setupMO(this, function () {
                            var value = setData.get(this, 'attrValueLastVal');
                            attr.set(this, 'value', value);
                            domEvents.dispatch(this, 'change');
                        });
                    }
                },
                test: function () {
                    return formElements[this.nodeName];
                }
            },
            values: {
                get: function () {
                    return collectSelectedOptions(this);
                },
                set: function (values) {
                    values = values || [];
                    markSelectedOptions(this, values);
                    setData.set(this, 'stickyValues', attr.get(this, 'values'));
                    setupMO(this, function () {
                        var previousValues = setData.get(this, 'stickyValues');
                        attr.set(this, 'values', previousValues);
                        var currentValues = setData.get(this, 'stickyValues');
                        var changes = diff(previousValues.slice().sort(), currentValues.slice().sort());
                        if (changes.length) {
                            domEvents.dispatch(this, 'values');
                        }
                    });
                },
                addEventListener: function (eventName, handler, aEL) {
                    var localHandler = function () {
                        domEvents.dispatch(this, 'values');
                    };
                    domEvents.addEventListener(this, 'change', localHandler);
                    aEL.call(this, eventName, handler);
                    return function (rEL) {
                        domEvents.removeEventListener(this, 'change', localHandler);
                        rEL.call(this, eventName, handler);
                    };
                }
            }
        };
        var attr = {
            rules: behaviorRules,
            specialAttributes: specialAttributes,
            getRule: function (el, attrOrPropName) {
                var special = specialAttributes[attrOrPropName];
                if (special) {
                    return special;
                }
                var rulesForElementType = behaviorRules.get(el.constructor);
                var cached = rulesForElementType && rulesForElementType[attrOrPropName];
                if (cached) {
                    return cached;
                }
                if (!(attrOrPropName in el)) {
                    return this.attribute(attrOrPropName);
                }
                var newRule = isPropWritable(el, attrOrPropName) ? this.property(attrOrPropName) : this.attribute(attrOrPropName);
                return cacheRule(el, attrOrPropName, newRule);
            },
            attribute: function (attrName) {
                return {
                    get: function () {
                        return this.getAttribute(attrName);
                    },
                    set: function (val) {
                        if (attrsNamespacesURI[attrName]) {
                            domMutateNode.setAttributeNS.call(this, attrsNamespacesURI[attrName], attrName, val);
                        } else {
                            domMutateNode.setAttribute.call(this, attrName, val);
                        }
                    }
                };
            },
            property: function (propName) {
                return {
                    get: function () {
                        return this[propName];
                    },
                    set: function (val) {
                        this[propName] = val;
                    }
                };
            },
            findSpecialListener: function (attributeName) {
                return specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;
            },
            setAttrOrProp: function (el, attrName, val) {
                return this.set(el, attrName, val);
            },
            set: function (el, attrName, val) {
                var rule = this.getRule(el, attrName);
                var setter = rule && rule.set;
                if (setter) {
                    return setter.call(el, val);
                }
            },
            get: function (el, attrName) {
                var rule = this.getRule(el, attrName);
                var getter = rule && rule.get;
                if (getter) {
                    return rule.test ? rule.test.call(el) && getter.call(el) : getter.call(el);
                }
            },
            remove: function (el, attrName) {
                attrName = attrName.toLowerCase();
                var special = specialAttributes[attrName];
                var setter = special && special.set;
                var remover = special && special.remove;
                var test = getSpecialTest(special);
                if (typeof remover === 'function' && test.call(el)) {
                    remover.call(el);
                } else if (typeof setter === 'function' && test.call(el)) {
                    setter.call(el, undefined);
                } else {
                    domMutateNode.removeAttribute.call(el, attrName);
                }
            }
        };
        module.exports = attr;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-live@4.2.8#lib/attr*/
define('can-view-live@4.2.8#lib/attr', [
    'require',
    'exports',
    'module',
    './core',
    'can-reflect',
    'can-queues',
    'can-attribute-observable/behaviors'
], function (require, exports, module) {
    'use strict';
    var live = require('./core');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var attr = require('can-attribute-observable/behaviors');
    live.attr = function (el, attributeName, compute) {
        function liveUpdateAttr(newVal) {
            queues.domUIQueue.enqueue(attr.set, attr, [
                el,
                attributeName,
                newVal
            ]);
        }
        live.listen(el, compute, liveUpdateAttr);
        attr.set(el, attributeName, canReflect.getValue(compute));
    };
});
/*can-view-live@4.2.8#lib/attrs*/
define('can-view-live@4.2.8#lib/attrs', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-callbacks',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-reflect',
    'can-reflect-dependencies'
], function (require, exports, module) {
    'use strict';
    var live = require('./core');
    var viewCallbacks = require('can-view-callbacks');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var canReflect = require('can-reflect');
    var canReflectDeps = require('can-reflect-dependencies');
    live.attrs = function (el, compute, scope, options) {
        if (!canReflect.isObservableLike(compute)) {
            var attrs = live.getAttributeParts(compute);
            for (var name in attrs) {
                domMutateNode.setAttribute.call(el, name, attrs[name]);
            }
            return;
        }
        var oldAttrs = {};
        function liveAttrsUpdate(newVal) {
            var newAttrs = live.getAttributeParts(newVal), name;
            for (name in newAttrs) {
                var newValue = newAttrs[name], oldValue = oldAttrs[name];
                if (newValue !== oldValue) {
                    domMutateNode.setAttribute.call(el, name, newValue);
                    var callback = viewCallbacks.attr(name);
                    if (callback) {
                        callback(el, {
                            attributeName: name,
                            scope: scope,
                            options: options
                        });
                    }
                }
                delete oldAttrs[name];
            }
            for (name in oldAttrs) {
                domMutateNode.removeAttribute.call(el, name);
            }
            oldAttrs = newAttrs;
        }
        canReflect.onValue(compute, liveAttrsUpdate, 'domUI');
        var removalDisposal;
        var teardownHandler = function () {
            canReflect.offValue(compute, liveAttrsUpdate, 'domUI');
            if (removalDisposal) {
                removalDisposal();
                removalDisposal = undefined;
            }
        };
        removalDisposal = domMutate.onNodeRemoval(el, function () {
            var doc = el.ownerDocument;
            var ownerNode = doc.contains ? doc : doc.documentElement;
            if (!ownerNode.contains(el)) {
                teardownHandler();
            }
        });
        liveAttrsUpdate(canReflect.getValue(compute));
    };
});
/*can-view-live@4.2.8#lib/html*/
define('can-view-live@4.2.8#lib/html', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-fragment',
    'can-child-nodes',
    'can-reflect',
    'can-symbol',
    'can-queues'
], function (require, exports, module) {
    'use strict';
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-fragment');
    var childNodes = require('can-child-nodes');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var queues = require('can-queues');
    var viewInsertSymbol = canSymbol.for('can.viewInsert');
    function updateNodeList(data, frag, nodeListUpdatedByFn) {
        if (data.nodeList.isUnregistered !== true) {
            var newChildren = canReflect.toArray(childNodes(frag));
            if (!nodeListUpdatedByFn) {
                nodeLists.update(data.nodeList, newChildren, data.oldNodes);
            }
            var oldNodes = data.oldNodes;
            data.oldNodes = newChildren;
            nodeLists.replace(oldNodes, frag);
        }
    }
    live.html = function (el, compute, parentNode, nodeListOrOptions) {
        var data;
        var makeAndPut;
        var nodeList;
        var nodes;
        var options;
        if (nodeListOrOptions !== undefined) {
            if (Array.isArray(nodeListOrOptions)) {
                nodeList = nodeListOrOptions;
            } else {
                nodeList = nodeListOrOptions.nodeList;
                options = nodeListOrOptions;
            }
        }
        var meta = { reasonLog: 'live.html replace::' + canReflect.getName(compute) };
        parentNode = live.getParentNode(el, parentNode);
        function liveHTMLUpdateHTML(newVal) {
            var attached = nodeLists.first(nodes).parentNode;
            if (attached) {
                makeAndPut(newVal, true);
            }
            var pn = nodeLists.first(nodes).parentNode;
            data.teardownCheck(pn);
        }
        data = live.listen(parentNode, compute, liveHTMLUpdateHTML);
        nodes = nodeList || [el];
        makeAndPut = function (val, useQueue) {
            if (val && typeof val[viewInsertSymbol] === 'function') {
                val = val[viewInsertSymbol](options);
            }
            var isFunction = typeof val === 'function';
            var frag = makeFrag(isFunction ? '' : val);
            live.addTextNodeIfNoChildren(frag);
            if (useQueue === true) {
                data.oldNodes = nodeLists.unregisterChildren(nodes, true);
                var nodeListUpdatedByFn = false;
                if (isFunction) {
                    val(frag.firstChild);
                    nodeListUpdatedByFn = nodeLists.first(nodes) === frag.firstChild;
                }
                queues.domUIQueue.enqueue(updateNodeList, null, [
                    data,
                    frag,
                    nodeListUpdatedByFn
                ], meta);
            } else {
                data.oldNodes = nodeLists.update(nodes, childNodes(frag));
                if (isFunction) {
                    val(frag.firstChild);
                }
                nodeLists.replace(data.oldNodes, frag);
            }
        };
        data.nodeList = nodes;
        if (!nodeList) {
            nodeLists.register(nodes, data.teardownCheck);
        } else {
            nodeList.unregistered = data.teardownCheck;
        }
        makeAndPut(canReflect.getValue(compute));
    };
});
/*can-view-live@4.2.8#lib/set-observable*/
define('can-view-live@4.2.8#lib/set-observable', [
    'require',
    'exports',
    'module',
    'can-simple-observable',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    function SetObservable(initialValue, setter) {
        this.setter = setter;
        SimpleObservable.call(this, initialValue);
    }
    SetObservable.prototype = Object.create(SimpleObservable.prototype);
    SetObservable.prototype.constructor = SetObservable;
    SetObservable.prototype.set = function (newVal) {
        this.setter(newVal);
    };
    canReflect.assignSymbols(SetObservable.prototype, { 'can.setValue': SetObservable.prototype.set });
    module.exports = SetObservable;
});
/*can-diff@1.5.0#patcher/patcher*/
define('can-diff@1.5.0#patcher/patcher', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-key-tree',
    'can-symbol',
    '../list/list',
    'can-queues',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var KeyTree = require('can-key-tree');
    var canSymbol = require('can-symbol');
    var diff = require('../list/list');
    var queues = require('can-queues');
    var canSymbol = require('can-symbol');
    var onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue');
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    var Patcher = function (observableOrList, priority) {
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        this.observableOrList = observableOrList;
        this.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);
        if (this.isObservableValue) {
            this.priority = canReflect.getPriority(observableOrList);
        } else {
            this.priority = priority || 0;
        }
        this.onList = this.onList.bind(this);
        this.onPatchesNotify = this.onPatchesNotify.bind(this);
        this.onPatchesDerive = this.onPatchesDerive.bind(this);
        this.patches = [];
    };
    Patcher.prototype = {
        constructor: Patcher,
        setup: function () {
            if (this.observableOrList[onValueSymbol]) {
                canReflect.onValue(this.observableOrList, this.onList, 'notify');
                this.setupList(canReflect.getValue(this.observableOrList));
            } else {
                this.setupList(this.observableOrList);
            }
        },
        teardown: function () {
            if (this.observableOrList[offValueSymbol]) {
                canReflect.offValue(this.observableOrList, this.onList, 'notify');
            }
            if (this.currentList && this.currentList[offPatchesSymbol]) {
                this.currentList[offPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        setupList: function (list) {
            this.currentList = list;
            if (list && list[onPatchesSymbol]) {
                list[onPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        onList: function onList(newList) {
            var current = this.currentList || [];
            newList = newList || [];
            if (current[offPatchesSymbol]) {
                current[offPatchesSymbol](this.onPatchesNotify, 'notify');
            }
            var patches = diff(current, newList);
            this.currentList = newList;
            this.onPatchesNotify(patches);
            if (newList[onPatchesSymbol]) {
                newList[onPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        onPatchesNotify: function onPatchesNotify(patches) {
            this.patches.push.apply(this.patches, patches);
            queues.deriveQueue.enqueue(this.onPatchesDerive, this, [], { priority: this.priority });
        },
        onPatchesDerive: function onPatchesDerive() {
            var patches = this.patches;
            this.patches = [];
            queues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [
                patches,
                this.currentList
            ], null, [
                'Apply patches',
                patches
            ]);
        }
    };
    canReflect.assignSymbols(Patcher.prototype, {
        'can.onPatches': function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        'can.offPatches': function (handler, queue) {
            this.handlers.delete([
                queue || 'mutate',
                handler
            ]);
        }
    });
    module.exports = Patcher;
});
/*can-view-live@4.2.8#lib/list*/
define('can-view-live@4.2.8#lib/list', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-fragment',
    'can-child-nodes',
    'can-dom-mutate/node',
    'can-reflect',
    'can-symbol',
    'can-reflect-dependencies',
    'can-simple-observable',
    './set-observable',
    'can-diff/patcher/patcher'
], function (require, exports, module) {
    'use strict';
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var frag = require('can-fragment');
    var childNodes = require('can-child-nodes');
    var domMutateNode = require('can-dom-mutate/node');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var canReflectDeps = require('can-reflect-dependencies');
    var SimpleObservable = require('can-simple-observable');
    var SetObservable = require('./set-observable');
    var Patcher = require('can-diff/patcher/patcher');
    var splice = [].splice;
    var renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, true, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = frag(itemHTML);
            var children = canReflect.toArray(childNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, children);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(children));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            removedMappings.forEach(function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        };
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    function ListDOMPatcher(el, compute, render, context, parentNode, nodeList, falseyRender) {
        this.patcher = new Patcher(compute);
        parentNode = live.getParentNode(el, parentNode);
        this.value = compute;
        this.render = render;
        this.context = context;
        this.parentNode = parentNode;
        this.falseyRender = falseyRender;
        this.masterNodeList = nodeList || nodeLists.register([el], null, true);
        this.placeholder = el;
        this.indexMap = [];
        this.isValueLike = canReflect.isValueLike(this.value);
        this.isObservableLike = canReflect.isObservableLike(this.value);
        this.onPatches = this.onPatches.bind(this);
        var data = this.data = live.setup(parentNode, this.setupValueBinding.bind(this), this.teardownValueBinding.bind(this));
        this.masterNodeList.unregistered = function () {
            data.teardownCheck();
        };
    }
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    ListDOMPatcher.prototype = {
        setupValueBinding: function () {
            this.patcher[onPatchesSymbol](this.onPatches, 'domUI');
            if (this.patcher.currentList && this.patcher.currentList.length) {
                this.onPatches([{
                        insert: this.patcher.currentList,
                        index: 0,
                        deleteCount: 0
                    }]);
            } else {
                this.addFalseyIfEmpty();
            }
        },
        teardownValueBinding: function () {
            this.patcher[offPatchesSymbol](this.onPatches, 'domUI');
            this.exit = true;
            this.remove({ length: this.patcher.currentList ? this.patcher.currentList.length : 0 }, 0, true);
        },
        onPatches: function ListDOMPatcher_onPatches(patches) {
            if (this.exit) {
                return;
            }
            for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                var patch = patches[i];
                if (patch.type === 'move') {
                    this.move(patch.toIndex, patch.fromIndex);
                } else {
                    if (patch.deleteCount) {
                        this.remove({ length: patch.deleteCount }, patch.index, true);
                    }
                    if (patch.insert && patch.insert.length) {
                        this.add(patch.insert, patch.index);
                    }
                }
            }
        },
        add: function (items, index) {
            var frag = this.placeholder.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [], masterNodeList = this.masterNodeList, render = this.render, context = this.context;
            items.forEach(function (item, key) {
                var itemIndex = new SimpleObservable(key + index), itemCompute = new SetObservable(item, function (newVal) {
                        canReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal);
                    }.bind(this)), itemFrag = renderAndAddToNodeLists(newNodeLists, masterNodeList, render, context, [
                        itemCompute,
                        itemIndex
                    ]);
                frag.appendChild(itemFrag);
                newIndicies.push(itemIndex);
            }, this);
            var masterListIndex = index + 1;
            if (!this.indexMap.length) {
                var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                nodeLists.remove(falseyItemsToRemove);
            }
            if (!masterNodeList[masterListIndex]) {
                nodeLists.after(masterListIndex === 1 ? [this.placeholder] : [nodeLists.last(this.masterNodeList[masterListIndex - 1])], frag);
            } else {
                var el = nodeLists.first(masterNodeList[masterListIndex]);
                domMutateNode.insertBefore.call(el.parentNode, frag, el);
            }
            splice.apply(this.masterNodeList, [
                masterListIndex,
                0
            ].concat(newNodeLists));
            splice.apply(this.indexMap, [
                index,
                0
            ].concat(newIndicies));
            for (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {
                this.indexMap[i].set(i);
            }
        },
        remove: function (items, index) {
            if (index < 0) {
                index = this.indexMap.length + index;
            }
            var itemsToRemove = removeFromNodeList(this.masterNodeList, index, items.length);
            var indexMap = this.indexMap;
            indexMap.splice(index, items.length);
            for (var i = index, len = indexMap.length; i < len; i++) {
                indexMap[i].set(i);
            }
            if (!this.exit) {
                this.addFalseyIfEmpty();
                nodeLists.remove(itemsToRemove);
            } else {
                nodeLists.unregister(this.masterNodeList);
            }
        },
        addFalseyIfEmpty: function () {
            if (this.falseyRender && this.indexMap.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, this.masterNodeList, this.falseyRender, this.currentList, [this.currentList]);
                nodeLists.after([this.masterNodeList[0]], falseyFrag);
                this.masterNodeList.push(falseyNodeLists[0]);
            }
        },
        move: function move(newIndex, currentIndex) {
            newIndex = newIndex + 1;
            currentIndex = currentIndex + 1;
            var masterNodeList = this.masterNodeList, indexMap = this.indexMap;
            var referenceNodeList = masterNodeList[newIndex];
            var movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));
            var referenceElement;
            if (currentIndex < newIndex) {
                referenceElement = nodeLists.last(referenceNodeList).nextSibling;
            } else {
                referenceElement = nodeLists.first(referenceNodeList);
            }
            var parentNode = masterNodeList[0].parentNode;
            parentNode.insertBefore(movedElements, referenceElement);
            var temp = masterNodeList[currentIndex];
            [].splice.apply(masterNodeList, [
                currentIndex,
                1
            ]);
            [].splice.apply(masterNodeList, [
                newIndex,
                0,
                temp
            ]);
            newIndex = newIndex - 1;
            currentIndex = currentIndex - 1;
            var indexCompute = indexMap[currentIndex];
            [].splice.apply(indexMap, [
                currentIndex,
                1
            ]);
            [].splice.apply(indexMap, [
                newIndex,
                0,
                indexCompute
            ]);
            var i = Math.min(currentIndex, newIndex);
            var len = indexMap.length;
            for (i, len; i < len; i++) {
                indexMap[i].set(i);
            }
        },
        set: function (newVal, index) {
            this.remove({ length: 1 }, index, true);
            this.add([newVal], index);
        }
    };
    live.list = function (el, list, render, context, parentNode, nodeList, falseyRender) {
        if (el.nodeType !== Node.TEXT_NODE) {
            var textNode;
            if (!nodeList) {
                textNode = document.createTextNode('');
                el.parentNode.replaceChild(textNode, el);
                el = textNode;
            } else {
                textNode = document.createTextNode('');
                nodeLists.replace(nodeList, textNode);
                nodeLists.update(nodeList, [textNode]);
                el = textNode;
            }
        }
        new ListDOMPatcher(el, list, render, context, parentNode, nodeList, falseyRender);
    };
});
/*can-view-live@4.2.8#lib/text*/
define('can-view-live@4.2.8#lib/text', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var canReflect = require('can-reflect');
    live.text = function (el, compute, parentNode, nodeList) {
        if (el.nodeType !== Node.TEXT_NODE) {
            var textNode;
            if (!nodeList) {
                textNode = document.createTextNode('');
                el.parentNode.replaceChild(textNode, el);
                el = textNode;
            } else {
                textNode = document.createTextNode('');
                nodeLists.replace(nodeList, textNode);
                nodeLists.update(nodeList, [textNode]);
                el = textNode;
            }
        }
        var parent = live.getParentNode(el, parentNode);
        el.nodeValue = live.makeString(canReflect.getValue(compute));
        function liveTextUpdateTextNode(newVal) {
            el.nodeValue = live.makeString(newVal);
        }
        var data = live.listen(parent, compute, liveTextUpdateTextNode, 'domUI');
        if (!nodeList) {
            nodeList = nodeLists.register([el], null, true);
        }
        nodeList.unregistered = data.teardownCheck;
        data.nodeList = nodeList;
    };
});
/*can-view-live@4.2.8#can-view-live*/
define('can-view-live@4.2.8#can-view-live', [
    'require',
    'exports',
    'module',
    './lib/core',
    './lib/attr',
    './lib/attrs',
    './lib/html',
    './lib/list',
    './lib/text'
], function (require, exports, module) {
    'use strict';
    var live = require('./lib/core');
    require('./lib/attr');
    require('./lib/attrs');
    require('./lib/html');
    require('./lib/list');
    require('./lib/text');
    module.exports = live;
});
/*can-stache@4.17.21#src/text_section*/
define('can-stache@4.17.21#src/text_section', [
    'require',
    'exports',
    'module',
    'can-view-live',
    './utils',
    'can-dom-mutate/node',
    'can-assign',
    'can-reflect',
    'can-observation'
], function (require, exports, module) {
    'use strict';
    var live = require('can-view-live');
    var utils = require('./utils');
    var domMutate = require('can-dom-mutate/node');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var noop = function () {
    };
    var TextSectionBuilder = function (filename) {
        if (filename) {
            this.filename = filename;
        }
        this.stack = [new TextSection()];
    };
    assign(TextSectionBuilder.prototype, utils.mixins);
    assign(TextSectionBuilder.prototype, {
        startSection: function (process) {
            var subSection = new TextSection();
            this.last().add({
                process: process,
                truthy: subSection
            });
            this.stack.push(subSection);
        },
        endSection: function () {
            this.stack.pop();
        },
        inverse: function () {
            this.stack.pop();
            var falseySection = new TextSection();
            this.last().last().falsey = falseySection;
            this.stack.push(falseySection);
        },
        compile: function (state) {
            var renderer = this.stack[0].compile();
            return function (scope) {
                function textSectionRender() {
                    return renderer(scope);
                }
                var observation = new Observation(textSectionRender, null, { isObservable: false });
                canReflect.onValue(observation, noop);
                var value = canReflect.getValue(observation);
                if (canReflect.valueHasDependencies(observation)) {
                    if (state.textContentOnly) {
                        live.text(this, observation);
                    } else if (state.attr) {
                        live.attr(this, state.attr, observation);
                    } else {
                        live.attrs(this, observation, scope);
                    }
                    canReflect.offValue(observation, noop);
                } else {
                    if (state.textContentOnly) {
                        this.nodeValue = value;
                    } else if (state.attr) {
                        domMutate.setAttribute.call(this, state.attr, value);
                    } else {
                        live.attrs(this, value);
                    }
                }
            };
        }
    });
    var passTruthyFalsey = function (process, truthy, falsey) {
        return function (scope) {
            return process.call(this, scope, truthy, falsey);
        };
    };
    var TextSection = function () {
        this.values = [];
    };
    assign(TextSection.prototype, {
        add: function (data) {
            this.values.push(data);
        },
        last: function () {
            return this.values[this.values.length - 1];
        },
        compile: function () {
            var values = this.values, len = values.length;
            for (var i = 0; i < len; i++) {
                var value = this.values[i];
                if (typeof value === 'object') {
                    values[i] = passTruthyFalsey(value.process, value.truthy && value.truthy.compile(), value.falsey && value.falsey.compile());
                }
            }
            return function (scope) {
                var txt = '', value;
                for (var i = 0; i < len; i++) {
                    value = values[i];
                    txt += typeof value === 'string' ? value : value.call(this, scope);
                }
                return txt;
            };
        }
    });
    module.exports = TextSectionBuilder;
});
/*can-stache@4.17.21#expressions/arg*/
define('can-stache@4.17.21#expressions/arg', function (require, exports, module) {
    'use strict';
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    module.exports = Arg;
});
/*can-stache@4.17.21#expressions/literal*/
define('can-stache@4.17.21#expressions/literal', function (require, exports, module) {
    'use strict';
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    module.exports = Literal;
});
/*can-simple-observable@2.5.0#setter/setter*/
define('can-simple-observable@2.5.0#setter/setter', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation',
    '../settable/settable',
    'can-event-queue/value/value',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var SettableObservable = require('../settable/settable');
    var valueEventBindings = require('can-event-queue/value/value');
    var canSymbol = require('can-symbol');
    var setElementSymbol = canSymbol.for('can.setElement');
    function SetterObservable(getter, setter) {
        this.setter = setter;
        this.observation = new Observation(getter);
        this.handler = this.handler.bind(this);
    }
    SetterObservable.prototype = Object.create(SettableObservable.prototype);
    SetterObservable.prototype.constructor = SetterObservable;
    SetterObservable.prototype.set = function (newVal) {
        this.setter(newVal);
    };
    SetterObservable.prototype.hasDependencies = function () {
        return canReflect.valueHasDependencies(this.observation);
    };
    canReflect.assignSymbols(SetterObservable.prototype, {
        'can.setValue': SetterObservable.prototype.set,
        'can.valueHasDependencies': SetterObservable.prototype.hasDependencies,
        'can.setElement': function (el) {
            this.observation[setElementSymbol](el);
        }
    });
    module.exports = SetterObservable;
});
/*can-stache@4.17.21#src/expression-helpers*/
define('can-stache@4.17.21#src/expression-helpers', [
    'require',
    'exports',
    'module',
    '../expressions/arg',
    '../expressions/literal',
    'can-reflect',
    'can-stache-key',
    'can-observation',
    'can-observation-recorder',
    'can-view-scope/make-compute-like',
    'can-simple-observable/setter/setter'
], function (require, exports, module) {
    'use strict';
    var Arg = require('../expressions/arg');
    var Literal = require('../expressions/literal');
    var canReflect = require('can-reflect');
    var stacheKey = require('can-stache-key');
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var makeComputeLike = require('can-view-scope/make-compute-like');
    var SetterObservable = require('can-simple-observable/setter/setter');
    function getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {
        var getKeys = function () {
            return stacheKey.reads(('' + canReflect.getValue(key)).replace(/\./g, '\\.'));
        };
        var parentHasKey;
        var computeValue = new SetterObservable(function getDynamicKey() {
            var readData = stacheKey.read(canReflect.getValue(root), getKeys());
            parentHasKey = readData.parentHasKey;
            return readData.value;
        }, function setDynamicKey(newVal) {
            stacheKey.write(canReflect.getValue(root), getKeys(), newVal);
        });
        Observation.temporarilyBind(computeValue);
        computeValue.initialValue = ObservationRecorder.peekValue(computeValue);
        computeValue.parentHasKey = parentHasKey;
        return computeValue;
    }
    function convertToArgExpression(expr) {
        if (!(expr instanceof Arg) && !(expr instanceof Literal)) {
            return new Arg(expr);
        } else {
            return expr;
        }
    }
    function toComputeOrValue(value) {
        if (canReflect.isObservableLike(value)) {
            if (canReflect.isValueLike(value) && canReflect.valueHasDependencies(value) === false) {
                return canReflect.getValue(value);
            }
            if (value.compute) {
                return value.compute;
            } else {
                return makeComputeLike(value);
            }
        }
        return value;
    }
    function toCompute(value) {
        if (value) {
            if (value.isComputed) {
                return value;
            }
            if (value.compute) {
                return value.compute;
            } else {
                return makeComputeLike(value);
            }
        }
        return value;
    }
    module.exports = {
        getObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,
        convertToArgExpression: convertToArgExpression,
        toComputeOrValue: toComputeOrValue,
        toCompute: toCompute
    };
});
/*can-stache@4.17.21#expressions/hashes*/
define('can-stache@4.17.21#expressions/hashes', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation',
    '../src/expression-helpers'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var expressionHelpers = require('../src/expression-helpers');
    var Hashes = function (hashes) {
        this.hashExprs = hashes;
    };
    Hashes.prototype.value = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]), value = val.value.apply(val, arguments);
            hash[prop] = {
                call: !val.modifiers || !val.modifiers.compute,
                value: value
            };
        }
        return new Observation(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? canReflect.getValue(hash[prop].value) : expressionHelpers.toComputeOrValue(hash[prop].value);
            }
            return finalHash;
        });
    };
    module.exports = Hashes;
});
/*can-stache@4.17.21#expressions/bracket*/
define('can-stache@4.17.21#expressions/bracket', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers'
], function (require, exports, module) {
    'use strict';
    var expressionHelpers = require('../src/expression-helpers');
    var Bracket = function (key, root, originalKey) {
        this.root = root;
        this.key = key;
    };
    Bracket.prototype.value = function (scope, helpers) {
        var root = this.root ? this.root.value(scope, helpers) : scope.peek('this');
        return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});
    };
    Bracket.prototype.closingTag = function () {
    };
    module.exports = Bracket;
});
/*can-stache@4.17.21#src/set-identifier*/
define('can-stache@4.17.21#src/set-identifier', function (require, exports, module) {
    'use strict';
    module.exports = function SetIdentifier(value) {
        this.value = value;
    };
});
/*can-stache@4.17.21#expressions/call*/
define('can-stache@4.17.21#expressions/call', [
    'require',
    'exports',
    'module',
    './hashes',
    '../src/set-identifier',
    'can-symbol',
    'can-simple-observable/setter/setter',
    '../src/expression-helpers',
    'can-reflect',
    'can-assign',
    'can-view-scope',
    'can-observation'
], function (require, exports, module) {
    'use strict';
    var Hashes = require('./hashes');
    var SetIdentifier = require('../src/set-identifier');
    var canSymbol = require('can-symbol');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var expressionHelpers = require('../src/expression-helpers');
    var canReflect = require('can-reflect');
    var assign = require('can-assign');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var isViewSymbol = canSymbol.for('can.isView');
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var Call = function (methodExpression, argExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);
    };
    Call.prototype.args = function (scope, ignoreArgLookup) {
        var hashExprs = {};
        var args = [];
        var gotIgnoreFunction = typeof ignoreArgLookup === 'function';
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            if (arg.expr instanceof Hashes) {
                assign(hashExprs, arg.expr.hashExprs);
            }
            if (!gotIgnoreFunction || !ignoreArgLookup(i)) {
                var value = arg.value.apply(arg, arguments);
                args.push({
                    call: !arg.modifiers || !arg.modifiers.compute,
                    value: value
                });
            }
        }
        return function (doNotWrapArguments) {
            var finalArgs = [];
            if (canReflect.size(hashExprs) > 0) {
                finalArgs.hashExprs = hashExprs;
            }
            for (var i = 0, len = args.length; i < len; i++) {
                if (doNotWrapArguments) {
                    finalArgs[i] = args[i].value;
                } else {
                    finalArgs[i] = args[i].call ? canReflect.getValue(args[i].value) : expressionHelpers.toCompute(args[i].value);
                }
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperOptions) {
        var callExpression = this;
        var method = this.methodExpr.value(scope, { proxyMethods: false });
        Observation.temporarilyBind(method);
        var func = canReflect.getValue(method);
        var getArgs = callExpression.args(scope, func && func.ignoreArgLookup);
        var computeFn = function (newVal) {
            var func = canReflect.getValue(method);
            if (typeof func === 'function') {
                if (canReflect.isObservableLike(func)) {
                    func = canReflect.getValue(func);
                }
                var args = getArgs(func.isLiveBound);
                if (func.requiresOptionsArgument) {
                    if (args.hashExprs && helperOptions && helperOptions.exprData) {
                        helperOptions.exprData.hashExprs = args.hashExprs;
                    }
                    if (helperOptions !== undefined) {
                        args.push(helperOptions);
                    }
                }
                if (func[isViewSymbol] === true) {
                    if (!(args[0] instanceof Scope)) {
                        args[0] = scope.getTemplateContext().add(args[0]);
                    }
                    args.push(helperOptions.nodeList);
                }
                if (arguments.length) {
                    args.unshift(new SetIdentifier(newVal));
                }
                return func.apply(method.thisArg || scope.peek('this'), args);
            }
        };
        if (helperOptions && helperOptions.doNotWrapInObservation) {
            return computeFn();
        } else {
            var computeValue = new SetterObservable(computeFn, computeFn);
            return computeValue;
        }
    };
    Call.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    module.exports = Call;
});
/*can-stache@4.17.21#expressions/helper*/
define('can-stache@4.17.21#expressions/helper', [
    'require',
    'exports',
    'module',
    './literal',
    './hashes',
    'can-assign',
    'can-log/dev/dev',
    '../src/expression-helpers',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var Literal = require('./literal');
    var Hashes = require('./hashes');
    var assign = require('can-assign');
    var dev = require('can-log/dev/dev');
    var expressionHelpers = require('../src/expression-helpers');
    var canReflect = require('can-reflect');
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(expressionHelpers.toComputeOrValue(arg.value.apply(arg, arguments)));
        }
        return args;
    };
    Helper.prototype.hash = function (scope) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = expressionHelpers.toComputeOrValue(val.value.apply(val, arguments));
        }
        return hash;
    };
    Helper.prototype.value = function (scope, helperOptions) {
        var methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, helperInstance = this, helperFn = scope.computeData(methodKey, { proxyMethods: false }), initialValue = helperFn && helperFn.initialValue, thisArg = helperFn && helperFn.thisArg;
        if (typeof initialValue === 'function') {
            helperFn = function helperFn() {
                var args = helperInstance.args(scope), helperOptionArg = assign(assign({}, helperOptions), {
                        hash: helperInstance.hash(scope),
                        exprData: helperInstance
                    });
                args.push(helperOptionArg);
                return initialValue.apply(thisArg || scope.peek('this'), args);
            };
        }
        return helperFn;
    };
    Helper.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    module.exports = Helper;
});
/*can-stache@4.17.21#expressions/lookup*/
define('can-stache@4.17.21#expressions/lookup', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers',
    'can-reflect',
    'can-symbol',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var expressionHelpers = require('../src/expression-helpers');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var assign = require('can-assign');
    var Lookup = function (key, root, sourceText) {
        this.key = key;
        this.rootExpr = root;
        canReflect.setKeyValue(this, sourceTextSymbol, sourceText);
    };
    Lookup.prototype.value = function (scope, readOptions) {
        if (this.rootExpr) {
            return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});
        } else {
            return scope.computeData(this.key, assign({ warnOnMissingKey: true }, readOptions));
        }
    };
    module.exports = Lookup;
});
/*can-stache@4.17.21#src/expression*/
define('can-stache@4.17.21#src/expression', [
    'require',
    'exports',
    'module',
    '../expressions/arg',
    '../expressions/literal',
    '../expressions/hashes',
    '../expressions/bracket',
    '../expressions/call',
    '../expressions/helper',
    '../expressions/lookup',
    './set-identifier',
    '../src/expression-helpers',
    './utils',
    'can-assign',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var Arg = require('../expressions/arg');
    var Literal = require('../expressions/literal');
    var Hashes = require('../expressions/hashes');
    var Bracket = require('../expressions/bracket');
    var Call = require('../expressions/call');
    var Helper = require('../expressions/helper');
    var Lookup = require('../expressions/lookup');
    var SetIdentifier = require('./set-identifier');
    var expressionHelpers = require('../src/expression-helpers');
    var utils = require('./utils');
    var assign = require('can-assign');
    var last = utils.last;
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var Hash = function () {
    };
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g, bracketSpaceRegExp = /\]\s+/, literalRegExp = /^('.*?'|".*?"|-?[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    assign(Stack.prototype, {
        top: function () {
            return last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            this.pop();
        },
        pop: function () {
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        first: function (types) {
            var curIndex = this.stack.length - 1;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (types.indexOf(this.top().type) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        push: function (type) {
            this.stack.push(type);
        },
        topLastChild: function () {
            return last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            canReflect.setKeyValue(ast, sourceTextSymbol, ast.key);
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        toComputeOrValue: expressionHelpers.toComputeOrValue,
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        Arg: Arg,
        Hash: Hash,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        Bracket: Bracket,
        SetIdentifier: SetIdentifier,
        tokenize: function (expression) {
            var tokens = [];
            (expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
                if (bracketSpaceRegExp.test(arg)) {
                    tokens.push(arg[0]);
                    tokens.push(arg.slice(1));
                } else {
                    tokens.push(arg);
                }
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                return ast.type === 'Helper' ? Helper : Lookup;
            },
            'method': function (ast, methodType, isArg) {
                return Lookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes;
            if (ast.type === 'Lookup') {
                var LookupRule = options.lookupRule(ast, methodType, isArg);
                var lookup = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol]);
                return lookup;
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Hashes') {
                hashes = {};
                ast.children.forEach(function (hash) {
                    hashes[hash.prop] = this.hydrateAst(hash.children[0], options, methodType, true);
                }, this);
                return new Hashes(hashes);
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                hashes = {};
                var args = [], children = ast.children, ExpressionType = options.methodRule(ast);
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.type === 'Hashes' && ast.type === 'Helper' && ExpressionType !== Call) {
                            child.children.forEach(function (hash) {
                                hashes[hash.prop] = this.hydrateAst(hash.children[0], options, ast.type, true);
                            }, this);
                        } else {
                            args.push(this.hydrateAst(child, options, ast.type, true));
                        }
                    }
                }
                return new ExpressionType(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            } else if (ast.type === 'Bracket') {
                var originalKey;
                return new Bracket(this.hydrateAst(ast.children[0], options), ast.root ? this.hydrateAst(ast.root, options) : undefined, originalKey);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top, firstParent, lastToken;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? last(top.children) : top
                            });
                        }
                    }
                    firstParent = stack.first([
                        'Call',
                        'Helper',
                        'Hashes',
                        'Root'
                    ]);
                    var hash = {
                        type: 'Hash',
                        prop: token
                    };
                    if (firstParent.type === 'Hashes') {
                        stack.addToAndPush(['Hashes'], hash);
                    } else {
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Root'
                        ], {
                            type: 'Hashes',
                            children: [hash]
                        });
                        stack.push(hash);
                    }
                    cursor.index++;
                } else if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (firstParent.type === 'Hash' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else if (firstParent.type === 'Bracket' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    }
                } else if (keyRegExp.test(token)) {
                    lastToken = stack.topLastChild();
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket') && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: lastToken,
                            key: token.slice(1)
                        });
                    } else if (firstParent.type === 'Bracket') {
                        if (!(firstParent.children && firstParent.children.length > 0)) {
                            stack.addToAndPush(['Bracket'], {
                                type: 'Lookup',
                                key: token
                            });
                        } else {
                            if (stack.first([
                                    'Helper',
                                    'Call',
                                    'Hash',
                                    'Arg'
                                ]).type === 'Helper' && token[0] !== '.') {
                                stack.addToAndPush(['Helper'], {
                                    type: 'Lookup',
                                    key: token
                                });
                            } else {
                                stack.replaceTopAndPush({
                                    type: 'Lookup',
                                    key: token.slice(1),
                                    root: firstParent
                                });
                            }
                        }
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg',
                            'Bracket'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else if (lastToken && lastToken.type === 'Call') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: lastToken
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    var call = stack.first(['Call']);
                    if (call.type !== 'Call') {
                        stack.popUntil(['Hash']);
                    } else {
                        stack.popUntil(['Call']);
                    }
                } else if (token === '[') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket')) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Bracket',
                            root: lastToken
                        });
                    } else if (top.type === 'Lookup' || top.type === 'Bracket') {
                        var bracket = {
                            type: 'Bracket',
                            root: top
                        };
                        stack.replaceTopAndPush(bracket);
                    } else if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Bracket' });
                    } else if (top === ' ') {
                        stack.popUntil([
                            'Lookup',
                            'Call'
                        ]);
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash'
                        ], { type: 'Bracket' });
                    } else {
                        stack.replaceTopAndPush({ type: 'Bracket' });
                    }
                } else if (token === ']') {
                    stack.pop();
                } else if (token === ' ') {
                    stack.push(token);
                }
            }
            return stack.root.children[0];
        }
    };
    module.exports = expression;
});
/*can-stache@4.17.21#src/mustache_core*/
define('can-stache@4.17.21#src/mustache_core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    'can-observation',
    'can-observation-recorder',
    './utils',
    './expression',
    'can-fragment',
    'can-dom-mutate',
    'can-symbol',
    'can-reflect',
    'can-log/dev/dev',
    'can-globals/document/document',
    'can-define-lazy-value'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var live = require('can-view-live');
        var nodeLists = require('can-view-nodelist');
        var Observation = require('can-observation');
        var ObservationRecorder = require('can-observation-recorder');
        var utils = require('./utils');
        var expression = require('./expression');
        var frag = require('can-fragment');
        var domMutate = require('can-dom-mutate');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var dev = require('can-log/dev/dev');
        var getDocument = require('can-globals/document/document');
        var defineLazyValue = require('can-define-lazy-value');
        var toDOMSymbol = canSymbol.for('can.toDOM');
        function HelperOptions(scope, nodeList, exprData, stringOnly) {
            this.metadata = { rendered: false };
            this.stringOnly = stringOnly;
            this.scope = scope;
            this.nodeList = nodeList;
            this.exprData = exprData;
        }
        defineLazyValue(HelperOptions.prototype, 'context', function () {
            return this.scope.peek('this');
        });
        var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g, mustacheWhitespaceRegExp = /\s*\{\{--\}\}\s*|\s*(\{\{\{?)-|-(\}\}\}?)\s*/g, k = function () {
            };
        var viewInsertSymbol = canSymbol.for('can.viewInsert');
        function valueShouldBeInsertedAsHTML(value) {
            return value !== null && typeof value === 'object' && (typeof value[toDOMSymbol] === 'function' || typeof value[viewInsertSymbol] === 'function' || typeof value.nodeType === 'number');
        }
        var core = {
            expression: expression,
            makeEvaluator: function (scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
                if (mode === '^') {
                    var temp = truthyRenderer;
                    truthyRenderer = falseyRenderer;
                    falseyRenderer = temp;
                }
                var value, helperOptions = new HelperOptions(scope, nodeList, exprData, stringOnly);
                utils.createRenderers(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                if (exprData instanceof expression.Call) {
                    value = exprData.value(scope, helperOptions);
                } else if (exprData instanceof expression.Bracket) {
                    value = exprData.value(scope);
                } else if (exprData instanceof expression.Lookup) {
                    value = exprData.value(scope);
                } else if (exprData instanceof expression.Literal) {
                    value = exprData.value.bind(exprData);
                } else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
                    value = exprData.methodExpr.value(scope, helperOptions);
                } else {
                    value = exprData.value(scope, helperOptions);
                    if (typeof value === 'function') {
                        return value;
                    }
                }
                if (!mode || helperOptions.metadata.rendered) {
                    return value;
                } else if (mode === '#' || mode === '^') {
                    return function () {
                        var finalValue = canReflect.getValue(value);
                        var result;
                        if (helperOptions.metadata.rendered) {
                            result = finalValue;
                        } else if (typeof finalValue !== 'string' && canReflect.isListLike(finalValue)) {
                            var isObserveList = canReflect.isObservableLike(finalValue) && canReflect.isListLike(finalValue);
                            if (canReflect.getKeyValue(finalValue, 'length')) {
                                if (stringOnly) {
                                    result = utils.getItemsStringContent(finalValue, isObserveList, helperOptions);
                                } else {
                                    result = frag(utils.getItemsFragContent(finalValue, helperOptions, scope));
                                }
                            } else {
                                result = helperOptions.inverse(scope);
                            }
                        } else {
                            result = finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);
                        }
                        helperOptions.metadata.rendered = false;
                        return result;
                    };
                } else {
                }
            },
            makeLiveBindingPartialRenderer: function (expressionString, state) {
                expressionString = expressionString.trim();
                var exprData, partialName = expressionString.split(/\s+/).shift();
                if (partialName !== expressionString) {
                    exprData = core.expression.parse(expressionString);
                }
                return function (scope, parentSectionNodeList) {
                    var nodeList = [this];
                    nodeList.expression = '>' + partialName;
                    nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                    var partialFrag = new Observation(function () {
                        var localPartialName = partialName;
                        var partialScope = scope;
                        if (exprData && exprData.argExprs.length === 1) {
                            var newContext = canReflect.getValue(exprData.argExprs[0].value(scope));
                            if (typeof newContext === 'undefined') {
                            } else {
                                partialScope = scope.add(newContext);
                            }
                        }
                        var partial = canReflect.getKeyValue(partialScope.templateContext.partials, localPartialName);
                        var renderer;
                        if (partial) {
                            renderer = function () {
                                return partial.render ? partial.render(partialScope, nodeList) : partial(partialScope);
                            };
                        } else {
                            var scopePartialName = partialScope.read(localPartialName, { isArgument: true }).value;
                            if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
                                return frag('');
                            }
                            if (scopePartialName) {
                                localPartialName = scopePartialName;
                            }
                            renderer = function () {
                                if (typeof localPartialName === 'function') {
                                    return localPartialName(partialScope, {}, nodeList);
                                } else {
                                    var domRenderer = core.getTemplateById(localPartialName);
                                    return domRenderer ? domRenderer(partialScope, {}, nodeList) : getDocument().createDocumentFragment();
                                }
                            };
                        }
                        var res = ObservationRecorder.ignore(renderer)();
                        return frag(res);
                    });
                    canReflect.setPriority(partialFrag, nodeList.nesting);
                    live.html(this, partialFrag, this.parentNode, nodeList);
                };
            },
            makeStringBranchRenderer: function (mode, expressionString, state) {
                var exprData = core.expression.parse(expressionString), fullExpression = mode + expressionString;
                var branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer) {
                    var evaluator = scope.__cache[fullExpression];
                    if (mode || !evaluator) {
                        evaluator = makeEvaluator(scope, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                        if (!mode) {
                            scope.__cache[fullExpression] = evaluator;
                        }
                    }
                    var gotObservableValue = evaluator[canSymbol.for('can.onValue')], res;
                    if (gotObservableValue) {
                        res = canReflect.getValue(evaluator);
                    } else {
                        res = evaluator();
                    }
                    if (res == null) {
                        return '';
                    }
                    return res.nodeType === 11 ? res.textContent : '' + res;
                };
                branchRenderer.exprData = exprData;
                return branchRenderer;
            },
            makeLiveBindingBranchRenderer: function (mode, expressionString, state) {
                var exprData = core.expression.parse(expressionString);
                var branchRenderer = function branchRenderer(scope, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                    var stringOnly = state.tag;
                    var nodeList = [this];
                    nodeList.expression = expressionString;
                    nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                    var evaluator = makeEvaluator(scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly);
                    var gotObservableValue = evaluator[canSymbol.for('can.onValue')];
                    var observable;
                    if (gotObservableValue) {
                        observable = evaluator;
                    } else {
                        observable = new Observation(evaluator, null, { isObservable: false });
                    }
                    if (canReflect.setPriority(observable, nodeList.nesting) === false) {
                        throw new Error('can-stache unable to set priority on observable');
                    }
                    canReflect.onValue(observable, k);
                    var value = canReflect.getValue(observable);
                    if (typeof value === 'function' && !(exprData instanceof expression.Lookup)) {
                        ObservationRecorder.ignore(value)(this);
                    } else if (canReflect.valueHasDependencies(observable)) {
                        if (state.attr) {
                            live.attr(this, state.attr, observable);
                        } else if (state.tag) {
                            live.attrs(this, observable);
                        } else if (state.text && !valueShouldBeInsertedAsHTML(value)) {
                            live.text(this, observable, this.parentNode, nodeList);
                        } else {
                            live.html(this, observable, this.parentNode, { nodeList: nodeList });
                        }
                    } else {
                        if (state.attr) {
                            domMutate.setAttribute(this, state.attr, value);
                        } else if (state.tag) {
                            live.attrs(this, value);
                        } else if (state.text && !valueShouldBeInsertedAsHTML(value)) {
                            this.nodeValue = live.makeString(value);
                        } else if (value != null) {
                            if (typeof value[viewInsertSymbol] === 'function') {
                                var insert = value[viewInsertSymbol]({ nodeList: nodeList });
                                var oldNodes = nodeLists.update(nodeList, [insert]);
                                nodeLists.replace(oldNodes, insert);
                            } else {
                                nodeLists.replace([this], frag(value, this.ownerDocument));
                            }
                        }
                    }
                    canReflect.offValue(observable, k);
                };
                branchRenderer.exprData = exprData;
                return branchRenderer;
            },
            splitModeFromExpression: function (expression, state) {
                expression = expression.trim();
                var mode = expression.charAt(0);
                if ('#/{&^>!<'.indexOf(mode) >= 0) {
                    expression = expression.substr(1).trim();
                } else {
                    mode = null;
                }
                if (mode === '{' && state.node) {
                    mode = null;
                }
                return {
                    mode: mode,
                    expression: expression
                };
            },
            cleanLineEndings: function (template) {
                return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                    spaceAfter = spaceAfter || '';
                    returnBefore = returnBefore || '';
                    spaceBefore = spaceBefore || '';
                    var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                    if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                        return whole;
                    } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                        spaceBefore = returnBefore + spaceBefore && ' ';
                        return spaceBefore + special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                    } else {
                        return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                    }
                });
            },
            cleanWhitespaceControl: function (template) {
                return template.replace(mustacheWhitespaceRegExp, '$1$2');
            },
            getTemplateById: function () {
            }
        };
        var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
        module.exports = core;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#base-url/base-url*/
define('can-globals@1.2.2#base-url/base-url', [
    'require',
    'exports',
    'module',
    '../can-globals-instance',
    '../global/global',
    '../document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('../can-globals-instance');
        require('../global/global');
        require('../document/document');
        globals.define('base-url', function () {
            var global = globals.getKeyValue('global');
            var domDocument = globals.getKeyValue('document');
            if (domDocument && 'baseURI' in domDocument) {
                return domDocument.baseURI;
            } else if (global.location) {
                var href = global.location.href;
                var lastSlash = href.lastIndexOf('/');
                return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
            } else if (typeof process !== 'undefined') {
                return process.cwd();
            }
        });
        module.exports = globals.makeExport('base-url');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-parse-uri@1.2.2#can-parse-uri*/
define('can-parse-uri@1.2.2#can-parse-uri', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.parseURI = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
});
/*can-join-uris@1.2.0#can-join-uris*/
define('can-join-uris@1.2.0#can-join-uris', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-parse-uri'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var parseURI = require('can-parse-uri');
    module.exports = namespace.joinURIs = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
});
/*can-stache@4.17.21#helpers/-debugger*/
define('can-stache@4.17.21#helpers/-debugger', [
    'require',
    'exports',
    'module',
    'can-log'
], function (require, exports, module) {
    'use strict';
    var canLog = require('can-log');
    function noop() {
    }
    var resolveValue = noop;
    var evaluateArgs = noop;
    var __testing = {};
    function debuggerHelper(left, right) {
        canLog.warn('Forgotten {{debugger}} helper');
    }
    debuggerHelper.requiresOptionsArgument = true;
    module.exports = {
        helper: debuggerHelper,
        evaluateArgs: evaluateArgs,
        resolveValue: resolveValue,
        __testing: __testing
    };
});
/*can-stache@4.17.21#src/truthy-observable*/
define('can-stache@4.17.21#src/truthy-observable', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    module.exports = function (observable) {
        return new Observation(function truthyObservation() {
            var val = canReflect.getValue(observable);
            return !!val;
        });
    };
});
/*can-stache@4.17.21#helpers/converter*/
define('can-stache@4.17.21#helpers/converter', [
    'require',
    'exports',
    'module',
    '../src/set-identifier',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var SetIdentifier = require('../src/set-identifier');
    var canReflect = require('can-reflect');
    function makeConverter(getterSetter) {
        getterSetter = getterSetter || {};
        return function (newVal, source) {
            var args = canReflect.toArray(arguments);
            if (newVal instanceof SetIdentifier) {
                return typeof getterSetter.set === 'function' ? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) : source(newVal.value);
            } else {
                return typeof getterSetter.get === 'function' ? getterSetter.get.apply(this, args) : args[0];
            }
        };
    }
    module.exports = makeConverter;
});
/*can-stache@4.17.21#helpers/-for-of*/
define('can-stache@4.17.21#helpers/-for-of', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation',
    'can-view-live',
    'can-view-nodelist',
    '../src/expression',
    '../src/key-observable'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var expression = require('../src/expression');
    var KeyObservable = require('../src/key-observable');
    var bindAndRead = function (value) {
        if (value && canReflect.isValueLike(value)) {
            Observation.temporarilyBind(value);
            return canReflect.getValue(value);
        } else {
            return value;
        }
    };
    function forOfObject(object, variableName, options) {
        var result = [];
        canReflect.each(object, function (val, key) {
            var value = new KeyObservable(object, key.replace(/\./g, '\\.'));
            var variableScope = {};
            if (variableName !== undefined) {
                variableScope[variableName] = value;
            }
            result.push(options.fn(options.scope.add({ key: key }, { special: true }).addLetContext(variableScope)));
        });
        return options.stringOnly ? result.join('') : result;
    }
    var forHelper = function (helperOptions) {
        if (helperOptions.exprData.argExprs.length !== 1) {
            throw new Error('for(of) broken syntax');
        }
        var helperExpr = helperOptions.exprData.argExprs[0].expr;
        var variableName, valueLookup, valueObservable;
        if (helperExpr instanceof expression.Lookup) {
            valueObservable = helperExpr.value(helperOptions.scope);
        } else if (helperExpr instanceof expression.Helper) {
            var inLookup = helperExpr.argExprs[0];
            if (inLookup.key !== 'of') {
                throw new Error('for(of) broken syntax');
            }
            variableName = helperExpr.methodExpr.key;
            valueLookup = helperExpr.argExprs[1];
            valueObservable = valueLookup.value(helperOptions.scope);
        }
        var items = valueObservable;
        var args = [].slice.call(arguments), options = args.pop(), resolved = bindAndRead(items);
        if (resolved && !canReflect.isListLike(resolved)) {
            return forOfObject(resolved, variableName, helperOptions);
        }
        if (options.stringOnly) {
            var parts = [];
            canReflect.eachIndex(resolved, function (value, index) {
                var variableScope = {};
                if (variableName !== undefined) {
                    variableScope[variableName] = value;
                }
                parts.push(helperOptions.fn(options.scope.add({ index: index }, { special: true }).addLetContext(variableScope)));
            });
            return parts.join('');
        } else {
            options.metadata.rendered = true;
            return function (el) {
                var nodeList = [el];
                nodeList.expression = 'live.list';
                nodeLists.register(nodeList, null, options.nodeList, true);
                nodeLists.update(options.nodeList, [el]);
                var cb = function (item, index, parentNodeList) {
                    var variableScope = {};
                    if (variableName !== undefined) {
                        variableScope[variableName] = item;
                    }
                    return options.fn(options.scope.add({ index: index }, { special: true }).addLetContext(variableScope), options.options, parentNodeList);
                };
                live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                    return options.inverse(options.scope, options.options, parentNodeList);
                });
            };
        }
    };
    forHelper.isLiveBound = true;
    forHelper.requiresOptionsArgument = true;
    forHelper.ignoreArgLookup = function ignoreArgLookup(index) {
        return index === 0;
    };
    module.exports = forHelper;
});
/*can-stache@4.17.21#helpers/-let*/
define('can-stache@4.17.21#helpers/-let', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation-recorder'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    function isVariable(scope) {
        return scope._meta.variable === true;
    }
    var letHelper = ObservationRecorder.ignore(function (options) {
        if (options.isSection) {
            return options.fn(options.scope.addLetContext(options.hash));
        }
        var variableScope = options.scope.getScope(isVariable);
        if (!variableScope) {
            throw new Error('There is no variable scope!');
        }
        canReflect.assignMap(variableScope._context, options.hash);
        return document.createTextNode('');
    });
    module.exports = letHelper;
});
/*can-stache@4.17.21#helpers/-portal*/
define('can-stache@4.17.21#helpers/-portal', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-view-live',
    'can-view-nodelist',
    'can-observation',
    'can-globals/document/document',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-symbol'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var canReflect = require('can-reflect');
        var live = require('can-view-live');
        var nodeLists = require('can-view-nodelist');
        var Observation = require('can-observation');
        var getDocument = require('can-globals/document/document');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var canSymbol = require('can-symbol');
        var keepNodeSymbol = canSymbol.for('done.keepNode');
        function portalHelper(elementObservable, options) {
            function evaluator() {
                var frag = options.fn(options.scope.addLetContext({}), options.options);
                var child = frag.firstChild;
                while (child) {
                    child[keepNodeSymbol] = true;
                    child = child.nextSibling;
                }
                return frag;
            }
            var el, nodeList, removeNodeRemovalListener;
            function teardown() {
                var root = el;
                if (removeNodeRemovalListener) {
                    removeNodeRemovalListener();
                    removeNodeRemovalListener = null;
                }
                if (el) {
                    canReflect.offValue(elementObservable, getElementAndRender);
                    el = null;
                }
                if (nodeList) {
                    canReflect.eachListLike(nodeList, function (node) {
                        if (root === node.parentNode) {
                            domMutateNode.removeChild.call(root, node);
                        }
                    });
                    nodeList = null;
                }
            }
            function getElementAndRender() {
                teardown();
                el = canReflect.getValue(elementObservable);
                if (el) {
                    var node = getDocument().createTextNode('');
                    domMutateNode.appendChild.call(el, node);
                    nodeList = [node];
                    nodeList.expression = 'live.html';
                    nodeLists.register(nodeList, null, null, true);
                    var observable = new Observation(evaluator, null, { isObservable: false });
                    live.html(node, observable, el, nodeList);
                    removeNodeRemovalListener = domMutate.onNodeRemoval(el, teardown);
                } else {
                    options.metadata.rendered = true;
                }
                canReflect.onValue(elementObservable, getElementAndRender);
            }
            getElementAndRender();
            return function (el) {
                var doc = getDocument();
                var comment = doc.createComment('portal(' + canReflect.getName(elementObservable) + ')');
                var frag = doc.createDocumentFragment();
                domMutateNode.appendChild.call(frag, comment);
                nodeLists.replace([el], frag);
                var nodeList = [comment];
                nodeList.expression = 'portal';
                nodeLists.register(nodeList, teardown, options.nodeList, true);
                nodeLists.update(options.nodeList, [comment]);
            };
        }
        portalHelper.isLiveBound = true;
        portalHelper.requiresOptionsArgument = true;
        module.exports = portalHelper;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.17.21#helpers/core*/
define('can-stache@4.17.21#helpers/core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    '../src/utils',
    'can-globals/base-url/base-url',
    'can-join-uris',
    'can-assign',
    'can-log/dev/dev',
    'can-reflect',
    './-debugger',
    '../src/key-observable',
    'can-observation',
    '../src/truthy-observable',
    'can-stache-helpers',
    './converter',
    'can-dom-data',
    './-for-of',
    './-let',
    './-portal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var live = require('can-view-live');
        var nodeLists = require('can-view-nodelist');
        var utils = require('../src/utils');
        var getBaseURL = require('can-globals/base-url/base-url');
        var joinURIs = require('can-join-uris');
        var assign = require('can-assign');
        var dev = require('can-log/dev/dev');
        var canReflect = require('can-reflect');
        var debuggerHelper = require('./-debugger').helper;
        var KeyObservable = require('../src/key-observable');
        var Observation = require('can-observation');
        var TruthyObservable = require('../src/truthy-observable');
        var helpers = require('can-stache-helpers');
        var makeConverter = require('./converter');
        var domData = require('can-dom-data');
        var forHelper = require('./-for-of');
        var letHelper = require('./-let');
        var portalHelper = require('./-portal');
        var builtInHelpers = {};
        var builtInConverters = {};
        var converterPackages = new WeakMap();
        var helpersCore = {
            looksLikeOptions: function (options) {
                return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
            },
            resolve: function (value) {
                if (value && canReflect.isValueLike(value)) {
                    return canReflect.getValue(value);
                } else {
                    return value;
                }
            },
            resolveHash: function (hash) {
                var params = {};
                for (var prop in hash) {
                    params[prop] = helpersCore.resolve(hash[prop]);
                }
                return params;
            },
            bindAndRead: function (value) {
                if (value && canReflect.isValueLike(value)) {
                    Observation.temporarilyBind(value);
                    return canReflect.getValue(value);
                } else {
                    return value;
                }
            },
            registerHelper: function (name, callback) {
                callback.requiresOptionsArgument = true;
                helpers[name] = callback;
            },
            registerHelpers: function (helpers) {
                var name, callback;
                for (name in helpers) {
                    callback = helpers[name];
                    helpersCore.registerHelper(name, helpersCore.makeSimpleHelper(callback));
                }
            },
            registerConverter: function (name, getterSetter) {
                helpersCore.registerHelper(name, makeConverter(getterSetter));
            },
            makeSimpleHelper: function (fn) {
                return function () {
                    var realArgs = [];
                    canReflect.eachIndex(arguments, function (val) {
                        realArgs.push(helpersCore.resolve(val));
                    });
                    return fn.apply(this, realArgs);
                };
            },
            addHelper: function (name, callback) {
                if (typeof name === 'object') {
                    return helpersCore.registerHelpers(name);
                }
                return helpersCore.registerHelper(name, helpersCore.makeSimpleHelper(callback));
            },
            addConverter: function (name, getterSetter) {
                if (typeof name === 'object') {
                    if (!converterPackages.has(name)) {
                        converterPackages.set(name, true);
                        canReflect.eachKey(name, function (getterSetter, name) {
                            helpersCore.addConverter(name, getterSetter);
                        });
                    }
                    return;
                }
                var helper = makeConverter(getterSetter);
                helper.isLiveBound = true;
                helpersCore.registerHelper(name, helper);
            },
            addLiveHelper: function (name, callback) {
                callback.isLiveBound = true;
                return helpersCore.registerHelper(name, callback);
            },
            getHelper: function (name, scope) {
                var helper = scope && scope.getHelper(name);
                if (!helper) {
                    helper = helpers[name];
                }
                return helper;
            },
            __resetHelpers: function () {
                for (var helper in helpers) {
                    delete helpers[helper];
                }
                converterPackages.delete(builtInConverters);
                helpersCore.addBuiltInHelpers();
                helpersCore.addBuiltInConverters();
            },
            addBuiltInHelpers: function () {
                canReflect.each(builtInHelpers, function (helper, helperName) {
                    helpers[helperName] = helper;
                });
            },
            addBuiltInConverters: function () {
                helpersCore.addConverter(builtInConverters);
            },
            _makeLogicHelper: function (name, logic) {
                var logicHelper = assign(function () {
                    var args = Array.prototype.slice.call(arguments, 0), options;
                    if (helpersCore.looksLikeOptions(args[args.length - 1])) {
                        options = args.pop();
                    }
                    function callLogic() {
                        if (options) {
                            return logic(args) ? true : false;
                        } else {
                            return logic(args);
                        }
                    }
                    var callFn = new Observation(callLogic);
                    if (options) {
                        return callFn.get() ? options.fn() : options.inverse();
                    } else {
                        return callFn.get();
                    }
                }, {
                    requiresOptionsArgument: true,
                    isLiveBound: true
                });
                return logicHelper;
            }
        };
        var ifHelper = assign(function ifHelper(expr, options) {
            var value;
            if (expr && canReflect.isValueLike(expr)) {
                value = canReflect.getValue(new TruthyObservable(expr));
            } else {
                value = !!helpersCore.resolve(expr);
            }
            if (options) {
                return value ? options.fn(options.scope || this) : options.inverse(options.scope || this);
            }
            return !!value;
        }, {
            requiresOptionsArgument: true,
            isLiveBound: true
        });
        var isHelper = helpersCore._makeLogicHelper('eq', function eqHelper(args) {
            var curValue, lastValue;
            for (var i = 0; i < args.length; i++) {
                curValue = helpersCore.resolve(args[i]);
                curValue = typeof curValue === 'function' ? curValue() : curValue;
                if (i > 0) {
                    if (curValue !== lastValue) {
                        return false;
                    }
                }
                lastValue = curValue;
            }
            return true;
        });
        var andHelper = helpersCore._makeLogicHelper('and', function andHelper(args) {
            if (args.length === 0) {
                return false;
            }
            var last;
            for (var i = 0, len = args.length; i < len; i++) {
                last = helpersCore.resolve(args[i]);
                if (!last) {
                    return last;
                }
            }
            return last;
        });
        var orHelper = helpersCore._makeLogicHelper('or', function orHelper(args) {
            if (args.length === 0) {
                return false;
            }
            var last;
            for (var i = 0, len = args.length; i < len; i++) {
                last = helpersCore.resolve(args[i]);
                if (last) {
                    return last;
                }
            }
            return last;
        });
        var switchHelper = function (expression, options) {
            helpersCore.resolve(expression);
            var found = false;
            var caseHelper = function (value, options) {
                if (!found && helpersCore.resolve(expression) === helpersCore.resolve(value)) {
                    found = true;
                    return options.fn(options.scope);
                }
            };
            caseHelper.requiresOptionsArgument = true;
            var defaultHelper = function (options) {
                if (!found) {
                    return options ? options.scope.peek('this') : true;
                }
            };
            defaultHelper.requiresOptionsArgument = true;
            canReflect.assignSymbols(defaultHelper, {
                'can.isValueLike': true,
                'can.isFunctionLike': false,
                'can.getValue': function () {
                    return this(options);
                }
            });
            var newScope = options.scope.add({
                case: caseHelper,
                default: defaultHelper
            }, { notContext: true });
            return options.fn(newScope, options);
        };
        switchHelper.requiresOptionsArgument = true;
        var domDataHelper = function (attr, value) {
            var data = (helpersCore.looksLikeOptions(value) ? value.context : value) || this;
            return function setDomData(el) {
                domData.set(el, attr, data);
            };
        };
        var joinBaseHelper = function (firstExpr) {
            var args = [].slice.call(arguments);
            var options = args.pop();
            var moduleReference = args.map(function (expr) {
                var value = helpersCore.resolve(expr);
                return typeof value === 'function' ? value() : value;
            }).join('');
            var templateModule = canReflect.getKeyValue(options.scope.templateContext.helpers, 'module');
            var parentAddress = templateModule ? templateModule.uri : undefined;
            var isRelative = moduleReference[0] === '.';
            if (isRelative && parentAddress) {
                return joinURIs(parentAddress, moduleReference);
            } else {
                var baseURL = typeof System !== 'undefined' && (System.renderingBaseURL || System.baseURL) || getBaseURL();
                if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                    baseURL += '/';
                }
                return joinURIs(baseURL, moduleReference);
            }
        };
        joinBaseHelper.requiresOptionsArgument = true;
        var eachHelper = function (items) {
            var args = [].slice.call(arguments), options = args.pop(), hashExprs = options.exprData.hashExprs, resolved = helpersCore.bindAndRead(items), hashOptions, aliases;
            if (canReflect.size(hashExprs) > 0) {
                hashOptions = {};
                canReflect.eachKey(hashExprs, function (exprs, key) {
                    hashOptions[exprs.key] = key;
                });
            }
            if ((canReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) || canReflect.isListLike(resolved) && canReflect.isValueLike(items)) && !options.stringOnly) {
                options.metadata.rendered = true;
                return function (el) {
                    var nodeList = [el];
                    nodeList.expression = 'live.list';
                    nodeLists.register(nodeList, null, options.nodeList, true);
                    nodeLists.update(options.nodeList, [el]);
                    var cb = function (item, index, parentNodeList) {
                        var aliases = {};
                        if (canReflect.size(hashOptions) > 0) {
                            if (hashOptions.value) {
                                aliases[hashOptions.value] = item;
                            }
                            if (hashOptions.index) {
                                aliases[hashOptions.index] = index;
                            }
                        }
                        return options.fn(options.scope.add(aliases, { notContext: true }).add({ index: index }, { special: true }).add(item), options.options, parentNodeList);
                    };
                    live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                        return options.inverse(options.scope.add(list), options.options, parentNodeList);
                    });
                };
            }
            var expr = helpersCore.resolve(items), result;
            if (!!expr && canReflect.isListLike(expr)) {
                result = utils.getItemsFragContent(expr, options, options.scope);
                return options.stringOnly ? result.join('') : result;
            } else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr) || expr instanceof Object) {
                result = [];
                canReflect.each(expr, function (val, key) {
                    var value = new KeyObservable(expr, key);
                    aliases = {};
                    if (canReflect.size(hashOptions) > 0) {
                        if (hashOptions.value) {
                            aliases[hashOptions.value] = value;
                        }
                        if (hashOptions.key) {
                            aliases[hashOptions.key] = key;
                        }
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add({ key: key }, { special: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            }
        };
        eachHelper.isLiveBound = true;
        eachHelper.requiresOptionsArgument = true;
        eachHelper.ignoreArgLookup = function ignoreArgLookup(index) {
            return index === 1;
        };
        var indexHelper = assign(function indexHelper(offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.peek('scope.index');
            return '' + ((typeof index === 'function' ? index() : index) + offset);
        }, { requiresOptionsArgument: true });
        var withHelper = function (expr, options) {
            var ctx = expr;
            if (!options) {
                options = expr;
                expr = true;
                ctx = options.hash;
            } else {
                expr = helpersCore.resolve(expr);
                if (options.hash && canReflect.size(options.hash) > 0) {
                    ctx = options.scope.add(options.hash, { notContext: true }).add(ctx);
                }
            }
            return options.fn(ctx || {});
        };
        withHelper.requiresOptionsArgument = true;
        var dataHelper = function (attr, value) {
            var data = (helpersCore.looksLikeOptions(value) ? value.context : value) || this;
            return function setData(el) {
                domData.set(el, attr, data);
            };
        };
        var unlessHelper = function (expr, options) {
            if (!options) {
                return !ifHelper.apply(this, [expr]);
            }
            return ifHelper.apply(this, [
                expr,
                assign(assign({}, options), {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        };
        unlessHelper.requiresOptionsArgument = true;
        unlessHelper.isLiveBound = true;
        var notConverter = {
            get: function (obs, options) {
                if (helpersCore.looksLikeOptions(options)) {
                    return canReflect.getValue(obs) ? options.inverse() : options.fn();
                } else {
                    return !canReflect.getValue(obs);
                }
            },
            set: function (newVal, obs) {
                canReflect.setValue(obs, !newVal);
            }
        };
        assign(builtInHelpers, {
            'debugger': debuggerHelper,
            each: eachHelper,
            eachOf: eachHelper,
            index: indexHelper,
            'if': ifHelper,
            is: isHelper,
            eq: isHelper,
            unless: unlessHelper,
            'with': withHelper,
            console: console,
            data: dataHelper,
            domData: domDataHelper,
            'switch': switchHelper,
            joinBase: joinBaseHelper,
            and: andHelper,
            or: orHelper,
            'let': letHelper,
            'for': forHelper,
            portal: portalHelper
        });
        assign(builtInConverters, { 'not': notConverter });
        helpersCore.addBuiltInHelpers();
        helpersCore.addBuiltInConverters();
        module.exports = helpersCore;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-ast@1.1.0#controls*/
define('can-stache-ast@1.1.0#controls', function (require, exports, module) {
    'use strict';
    var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g, mustacheWhitespaceRegExp = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g;
    function splitModeFromExpression(expression, state) {
        expression = expression.trim();
        var mode = expression.charAt(0);
        if ('#/{&^>!<'.indexOf(mode) >= 0) {
            expression = expression.substr(1).trim();
        } else {
            mode = null;
        }
        if (mode === '{' && state.node) {
            mode = null;
        }
        return {
            mode: mode,
            expression: expression
        };
    }
    function cleanLineEndings(template) {
        return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
            spaceAfter = spaceAfter || '';
            returnBefore = returnBefore || '';
            spaceBefore = spaceBefore || '';
            var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
            if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                return whole;
            } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                spaceBefore = returnBefore + spaceBefore && ' ';
                return spaceBefore + special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
            } else {
                return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
            }
        });
    }
    function whiteSpaceReplacement(whole, spaceBefore, bracketBefore, controlBefore, expression, controlAfter, bracketAfter, spaceAfter) {
        if (controlBefore === '-') {
            spaceBefore = '';
        }
        if (controlAfter === '-') {
            spaceAfter = '';
        }
        return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;
    }
    function cleanWhitespaceControl(template) {
        return template.replace(mustacheWhitespaceRegExp, whiteSpaceReplacement);
    }
    exports.cleanLineEndings = cleanLineEndings;
    exports.cleanWhitespaceControl = cleanWhitespaceControl;
});
/*can-stache-ast@1.1.0#can-stache-ast*/
define('can-stache-ast@1.1.0#can-stache-ast', [
    'require',
    'exports',
    'module',
    './controls',
    'can-view-parser'
], function (require, exports, module) {
    'use strict';
    var controls = require('./controls');
    var parser = require('can-view-parser');
    exports.parse = function (filename, source) {
        if (arguments.length === 1) {
            source = arguments[0];
            filename = undefined;
        }
        var template = source;
        template = controls.cleanWhitespaceControl(template);
        template = controls.cleanLineEndings(template);
        var imports = [], dynamicImports = [], importDeclarations = [], ases = {}, attributes = new Map(), inImport = false, inFrom = false, inAs = false, isUnary = false, importIsDynamic = false, currentAs = '', currentFrom = '', currentAttrName = null;
        function processImport(line) {
            if (currentAs) {
                ases[currentAs] = currentFrom;
                currentAs = '';
            }
            if (importIsDynamic) {
                dynamicImports.push(currentFrom);
            } else {
                imports.push(currentFrom);
            }
            importDeclarations.push({
                specifier: currentFrom,
                loc: { line: line },
                attributes: attributes
            });
            attributes = new Map();
        }
        var program = parser(template, {
            filename: filename,
            start: function (tagName, unary) {
                if (tagName === 'can-import') {
                    isUnary = unary;
                    importIsDynamic = false;
                    inImport = true;
                } else if (tagName === 'can-dynamic-import') {
                    isUnary = unary;
                    importIsDynamic = true;
                    inImport = true;
                } else if (inImport) {
                    importIsDynamic = true;
                    inImport = false;
                }
            },
            attrStart: function (attrName) {
                currentAttrName = attrName;
                attributes.set(currentAttrName, true);
                if (attrName === 'from') {
                    inFrom = true;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = true;
                }
            },
            attrEnd: function (attrName) {
                if (attrName === 'from') {
                    inFrom = false;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = false;
                }
            },
            attrValue: function (value) {
                if (inImport) {
                    attributes.set(currentAttrName, value);
                }
                if (inFrom && inImport) {
                    currentFrom = value;
                } else if (inAs && inImport) {
                    currentAs = value;
                }
            },
            end: function (tagName, unary, line) {
                if ((tagName === 'can-import' || tagName === 'can-dynamic-import') && isUnary) {
                    processImport(line);
                }
            },
            close: function (tagName, unary, line) {
                if (tagName === 'can-import' || tagName === 'can-dynamic-import') {
                    processImport(line);
                }
            },
            chars: function (text) {
                if (text.trim().length > 0) {
                    importIsDynamic = true;
                }
            },
            special: function () {
                importIsDynamic = true;
            }
        }, true);
        return {
            intermediate: program,
            program: program,
            imports: imports,
            dynamicImports: dynamicImports,
            importDeclarations: importDeclarations,
            ases: ases,
            exports: ases
        };
    };
});
/*can-import-module@1.2.0#can-import-module*/
define('can-import-module@1.2.0#can-import-module', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getGlobal = require('can-globals/global/global');
        var namespace = require('can-namespace');
        module.exports = namespace.import = function (moduleName, parentName) {
            return new Promise(function (resolve, reject) {
                try {
                    var global = getGlobal();
                    if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                        global.System['import'](moduleName, { name: parentName }).then(resolve, reject);
                    } else if (global.define && global.define.amd) {
                        global.require([moduleName], function (value) {
                            resolve(value);
                        });
                    } else if (global.require) {
                        resolve(global.require(moduleName));
                    } else {
                        if (typeof stealRequire !== 'undefined') {
                            steal.import(moduleName, { name: parentName }).then(resolve, reject);
                        } else {
                            resolve();
                        }
                    }
                } catch (err) {
                    reject(err);
                }
            });
        };
        function isFunction(fn) {
            return typeof fn === 'function';
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.17.21#can-stache*/
define('can-stache@4.17.21#can-stache', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-view-callbacks',
    './src/html_section',
    './src/text_section',
    './src/mustache_core',
    './helpers/core',
    'can-stache-ast',
    './src/utils',
    'can-attribute-encoder',
    'can-log/dev/dev',
    'can-namespace',
    'can-globals/document/document',
    'can-assign',
    'can-import-module',
    'can-reflect',
    'can-view-scope',
    'can-view-scope/template-context',
    'can-observation-recorder',
    'can-symbol',
    'can-view-target',
    'can-view-nodelist'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var parser = require('can-view-parser');
        var viewCallbacks = require('can-view-callbacks');
        var HTMLSectionBuilder = require('./src/html_section');
        var TextSectionBuilder = require('./src/text_section');
        var mustacheCore = require('./src/mustache_core');
        var mustacheHelpers = require('./helpers/core');
        var getIntermediateAndImports = require('can-stache-ast').parse;
        var utils = require('./src/utils');
        var makeRendererConvertScopes = utils.makeRendererConvertScopes;
        var last = utils.last;
        var attributeEncoder = require('can-attribute-encoder');
        var dev = require('can-log/dev/dev');
        var namespace = require('can-namespace');
        var DOCUMENT = require('can-globals/document/document');
        var assign = require('can-assign');
        var importer = require('can-import-module');
        var canReflect = require('can-reflect');
        var Scope = require('can-view-scope');
        var TemplateContext = require('can-view-scope/template-context');
        var ObservationRecorder = require('can-observation-recorder');
        var canSymbol = require('can-symbol');
        require('can-view-target');
        require('can-view-nodelist');
        if (!viewCallbacks.tag('content')) {
            viewCallbacks.tag('content', function (el, tagData) {
                return tagData.scope;
            });
        }
        var isViewSymbol = canSymbol.for('can.isView');
        var wrappedAttrPattern = /[{(].*[)}]/;
        var colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;
        var svgNamespace = 'http://www.w3.org/2000/svg', xmlnsAttrNamespaceURI = 'http://www.w3.org/2000/xmlns/', xlinkHrefAttrNamespaceURI = 'http://www.w3.org/1999/xlink';
        var namespaces = {
                'svg': svgNamespace,
                'g': svgNamespace,
                'defs': svgNamespace,
                'path': svgNamespace,
                'filter': svgNamespace,
                'feMorphology': svgNamespace,
                'feGaussianBlur': svgNamespace,
                'feOffset': svgNamespace,
                'feComposite': svgNamespace,
                'feColorMatrix': svgNamespace,
                'use': svgNamespace
            }, attrsNamespacesURI = {
                'xmlns': xmlnsAttrNamespaceURI,
                'xlink:href': xlinkHrefAttrNamespaceURI
            }, textContentOnlyTag = {
                style: true,
                script: true
            };
        function stache(filename, template) {
            if (arguments.length === 1) {
                template = arguments[0];
                filename = undefined;
            }
            var inlinePartials = {};
            if (typeof template === 'string') {
                template = mustacheCore.cleanWhitespaceControl(template);
                template = mustacheCore.cleanLineEndings(template);
            }
            var section = new HTMLSectionBuilder(filename), state = {
                    node: null,
                    attr: null,
                    sectionElementStack: [],
                    text: false,
                    namespaceStack: [],
                    textContentOnly: null
                }, makeRendererAndUpdateSection = function (section, mode, stache, lineNo) {
                    if (mode === '>') {
                        section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({
                            filename: section.filename,
                            lineNo: lineNo
                        })));
                    } else if (mode === '/') {
                        var createdSection = section.last();
                        if (createdSection.startedWith === '<') {
                            inlinePartials[stache] = section.endSubSectionAndReturnRenderer();
                            section.removeCurrentNode();
                        } else {
                            section.endSection();
                        }
                        if (section instanceof HTMLSectionBuilder) {
                            state.sectionElementStack.pop();
                        }
                    } else if (mode === 'else') {
                        section.inverse();
                    } else {
                        var makeRenderer = section instanceof HTMLSectionBuilder ? mustacheCore.makeLiveBindingBranchRenderer : mustacheCore.makeStringBranchRenderer;
                        if (mode === '{' || mode === '&') {
                            section.add(makeRenderer(null, stache, copyState({
                                filename: section.filename,
                                lineNo: lineNo
                            })));
                        } else if (mode === '#' || mode === '^' || mode === '<') {
                            var renderer = makeRenderer(mode, stache, copyState({
                                filename: section.filename,
                                lineNo: lineNo
                            }));
                            var sectionItem = { type: 'section' };
                            section.startSection(renderer);
                            section.last().startedWith = mode;
                            if (section instanceof HTMLSectionBuilder) {
                                state.sectionElementStack.push(sectionItem);
                            }
                        } else {
                            section.add(makeRenderer(null, stache, copyState({
                                text: true,
                                filename: section.filename,
                                lineNo: lineNo
                            })));
                        }
                    }
                }, isDirectlyNested = function () {
                    var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
                    return state.sectionElementStack.length ? lastElement.type === 'section' || lastElement.type === 'custom' : true;
                }, copyState = function (overwrites) {
                    var cur = {
                        tag: state.node && state.node.tag,
                        attr: state.attr && state.attr.name,
                        directlyNested: isDirectlyNested(),
                        textContentOnly: !!state.textContentOnly
                    };
                    return overwrites ? assign(cur, overwrites) : cur;
                }, addAttributesCallback = function (node, callback) {
                    if (!node.attributes) {
                        node.attributes = [];
                    }
                    node.attributes.unshift(callback);
                };
            parser(template, {
                filename: filename,
                start: function (tagName, unary, lineNo) {
                    var matchedNamespace = namespaces[tagName];
                    if (matchedNamespace && !unary) {
                        state.namespaceStack.push(matchedNamespace);
                    }
                    state.node = {
                        tag: tagName,
                        children: [],
                        namespace: matchedNamespace || last(state.namespaceStack)
                    };
                },
                end: function (tagName, unary, lineNo) {
                    var isCustomTag = viewCallbacks.tag(tagName);
                    var directlyNested = isDirectlyNested();
                    if (unary) {
                        section.add(state.node);
                        if (isCustomTag) {
                            addAttributesCallback(state.node, function (scope, parentNodeList) {
                                viewCallbacks.tagHandler(this, tagName, {
                                    scope: scope,
                                    subtemplate: null,
                                    templateType: 'stache',
                                    parentNodeList: parentNodeList,
                                    directlyNested: directlyNested
                                });
                            });
                        }
                    } else {
                        section.push(state.node);
                        state.sectionElementStack.push({
                            type: isCustomTag ? 'custom' : null,
                            tag: isCustomTag ? null : tagName,
                            templates: {},
                            directlyNested: directlyNested
                        });
                        if (isCustomTag) {
                            section.startSubSection();
                        } else if (textContentOnlyTag[tagName]) {
                            state.textContentOnly = new TextSectionBuilder(filename);
                        }
                    }
                    state.node = null;
                },
                close: function (tagName, lineNo) {
                    var matchedNamespace = namespaces[tagName];
                    if (matchedNamespace) {
                        state.namespaceStack.pop();
                    }
                    var isCustomTag = viewCallbacks.tag(tagName), renderer;
                    if (isCustomTag) {
                        renderer = section.endSubSectionAndReturnRenderer();
                    }
                    if (textContentOnlyTag[tagName]) {
                        section.last().add(state.textContentOnly.compile(copyState()));
                        state.textContentOnly = null;
                    }
                    var oldNode = section.pop();
                    if (isCustomTag) {
                        if (tagName === 'can-template') {
                            var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
                            if (renderer) {
                                parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
                            }
                            section.removeCurrentNode();
                        } else {
                            var current = state.sectionElementStack[state.sectionElementStack.length - 1];
                            addAttributesCallback(oldNode, function (scope, parentNodeList) {
                                viewCallbacks.tagHandler(this, tagName, {
                                    scope: scope,
                                    subtemplate: renderer ? makeRendererConvertScopes(renderer) : renderer,
                                    templateType: 'stache',
                                    parentNodeList: parentNodeList,
                                    templates: current.templates,
                                    directlyNested: current.directlyNested
                                });
                            });
                        }
                    }
                    state.sectionElementStack.pop();
                },
                attrStart: function (attrName, lineNo) {
                    if (state.node.section) {
                        state.node.section.add(attrName + '="');
                    } else {
                        state.attr = {
                            name: attrName,
                            value: ''
                        };
                    }
                },
                attrEnd: function (attrName, lineNo) {
                    var matchedAttrNamespacesURI = attrsNamespacesURI[attrName];
                    if (state.node.section) {
                        state.node.section.add('" ');
                    } else {
                        if (!state.node.attrs) {
                            state.node.attrs = {};
                        }
                        if (state.attr.section) {
                            state.node.attrs[state.attr.name] = state.attr.section.compile(copyState());
                        } else if (matchedAttrNamespacesURI) {
                            state.node.attrs[state.attr.name] = {
                                value: state.attr.value,
                                namespaceURI: attrsNamespacesURI[attrName]
                            };
                        } else {
                            state.node.attrs[state.attr.name] = state.attr.value;
                        }
                        var attrCallback = viewCallbacks.attr(attrName);
                        if (attrCallback) {
                            if (!state.node.attributes) {
                                state.node.attributes = [];
                            }
                            state.node.attributes.push(function (scope, nodeList) {
                                attrCallback(this, {
                                    attributeName: attrName,
                                    scope: scope,
                                    nodeList: nodeList
                                });
                            });
                        }
                        state.attr = null;
                    }
                },
                attrValue: function (value, lineNo) {
                    var section = state.node.section || state.attr.section;
                    if (section) {
                        section.add(value);
                    } else {
                        state.attr.value += value;
                    }
                },
                chars: function (text, lineNo) {
                    (state.textContentOnly || section).add(text);
                },
                special: function (text, lineNo) {
                    var firstAndText = mustacheCore.splitModeFromExpression(text, state), mode = firstAndText.mode, expression = firstAndText.expression;
                    if (expression === 'else') {
                        var inverseSection;
                        if (state.attr && state.attr.section) {
                            inverseSection = state.attr.section;
                        } else if (state.node && state.node.section) {
                            inverseSection = state.node.section;
                        } else {
                            inverseSection = state.textContentOnly || section;
                        }
                        inverseSection.inverse();
                        return;
                    }
                    if (mode === '!') {
                        return;
                    }
                    if (state.node && state.node.section) {
                        makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
                        if (state.node.section.subSectionDepth() === 0) {
                            state.node.attributes.push(state.node.section.compile(copyState()));
                            delete state.node.section;
                        }
                    } else if (state.attr) {
                        if (!state.attr.section) {
                            state.attr.section = new TextSectionBuilder(filename);
                            if (state.attr.value) {
                                state.attr.section.add(state.attr.value);
                            }
                        }
                        makeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);
                    } else if (state.node) {
                        if (!state.node.attributes) {
                            state.node.attributes = [];
                        }
                        if (!mode) {
                            state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({
                                filename: section.filename,
                                lineNo: lineNo
                            })));
                        } else if (mode === '#' || mode === '^') {
                            if (!state.node.section) {
                                state.node.section = new TextSectionBuilder(filename);
                            }
                            makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
                        } else {
                            throw new Error(mode + ' is currently not supported within a tag.');
                        }
                    } else {
                        makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);
                    }
                },
                comment: function (text) {
                    section.add({ comment: text });
                },
                done: function (lineNo) {
                }
            });
            var renderer = section.compile();
            var scopifiedRenderer = ObservationRecorder.ignore(function (scope, options, nodeList) {
                if (nodeList === undefined && canReflect.isListLike(options)) {
                    nodeList = options;
                    options = undefined;
                }
                if (options && !options.helpers && !options.partials && !options.tags) {
                    options = { helpers: options };
                }
                canReflect.eachKey(options && options.helpers, function (helperValue) {
                    helperValue.requiresOptionsArgument = true;
                });
                var templateContext = new TemplateContext(options);
                canReflect.eachKey(inlinePartials, function (partial, partialName) {
                    canReflect.setKeyValue(templateContext.partials, partialName, partial);
                });
                canReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);
                if (!(scope instanceof Scope)) {
                    scope = new Scope(templateContext).add(scope);
                } else {
                    var templateContextScope = new Scope(templateContext);
                    templateContextScope._parent = scope._parent;
                    scope._parent = templateContextScope;
                }
                return renderer(scope.addLetContext(), nodeList);
            });
            scopifiedRenderer[isViewSymbol] = true;
            return scopifiedRenderer;
        }
        assign(stache, mustacheHelpers);
        stache.safeString = function (text) {
            return canReflect.assignSymbols({}, {
                'can.toDOM': function () {
                    return text;
                }
            });
        };
        stache.async = function (source) {
            var iAi = getIntermediateAndImports(source);
            var importPromises = iAi.imports.map(function (moduleName) {
                return importer(moduleName);
            });
            return Promise.all(importPromises).then(function () {
                return stache(iAi.intermediate);
            });
        };
        var templates = {};
        stache.from = mustacheCore.getTemplateById = function (id) {
            if (!templates[id]) {
                var el = DOCUMENT().getElementById(id);
                if (el) {
                    templates[id] = stache('#' + id, el.innerHTML);
                }
            }
            return templates[id];
        };
        stache.registerPartial = function (id, partial) {
            templates[id] = typeof partial === 'string' ? stache(partial) : partial;
        };
        stache.addBindings = viewCallbacks.attrs;
        module.exports = namespace.stache = stache;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-model@4.0.3#can-view-model*/
define('can-view-model@4.0.3#can-view-model', [
    'require',
    'exports',
    'module',
    'can-simple-map',
    'can-namespace',
    'can-globals/document/document',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var SimpleMap = require('can-simple-map');
        var ns = require('can-namespace');
        var getDocument = require('can-globals/document/document');
        var canReflect = require('can-reflect');
        var canSymbol = require('can-symbol');
        var viewModelSymbol = canSymbol.for('can.viewModel');
        module.exports = ns.viewModel = function (el, attr, val) {
            if (typeof el === 'string') {
                el = getDocument().querySelector(el);
            } else if (canReflect.isListLike(el) && !el.nodeType) {
                el = el[0];
            }
            if (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {
                el[viewModelSymbol] = attr;
                return;
            }
            var scope = el[viewModelSymbol];
            if (!scope) {
                scope = new SimpleMap();
                el[viewModelSymbol] = scope;
            }
            switch (arguments.length) {
            case 0:
            case 1:
                return scope;
            case 2:
                return canReflect.getKeyValue(scope, attr);
            default:
                canReflect.setKeyValue(scope, attr, val);
                return el;
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-attribute-observable@1.2.7#event*/
define('can-attribute-observable@1.2.7#event', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-dom-events',
    'can-dom-events/helpers/util'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var domEvents = require('can-dom-events');
    var isDomEventTarget = require('can-dom-events/helpers/util').isDomEventTarget;
    var canEvent = {
        on: function on(eventName, handler, queue) {
            if (isDomEventTarget(this)) {
                domEvents.addEventListener(this, eventName, handler, queue);
            } else {
                canReflect.onKeyValue(this, eventName, handler, queue);
            }
        },
        off: function off(eventName, handler, queue) {
            if (isDomEventTarget(this)) {
                domEvents.removeEventListener(this, eventName, handler, queue);
            } else {
                canReflect.offKeyValue(this, eventName, handler, queue);
            }
        },
        one: function one(event, handler, queue) {
            var one = function () {
                canEvent.off.call(this, event, one, queue);
                return handler.apply(this, arguments);
            };
            canEvent.on.call(this, event, one, queue);
            return this;
        }
    };
    module.exports = canEvent;
});
/*can-attribute-observable@1.2.7#get-event-name*/
define('can-attribute-observable@1.2.7#get-event-name', [
    'require',
    'exports',
    'module',
    './behaviors'
], function (require, exports, module) {
    'use strict';
    var attr = require('./behaviors');
    var isRadioInput = function isRadioInput(el) {
        return el.nodeName.toLowerCase() === 'input' && el.type === 'radio';
    };
    module.exports = function getEventName(el, prop) {
        var event = 'change';
        if (isRadioInput(el) && prop === 'checked') {
            event = 'can-attribute-observable-radiochange';
        }
        if (attr.findSpecialListener(prop)) {
            event = prop;
        }
        return event;
    };
});
/*can-event-dom-radiochange@2.2.1#can-event-dom-radiochange*/
define('can-event-dom-radiochange@2.2.1#can-event-dom-radiochange', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var namespace = require('can-namespace');
        function getRoot() {
            return getDocument().documentElement;
        }
        function findParentForm(el) {
            while (el) {
                if (el.nodeName === 'FORM') {
                    break;
                }
                el = el.parentNode;
            }
            return el;
        }
        function shouldReceiveEventFromRadio(source, dest) {
            var name = source.getAttribute('name');
            return name && name === dest.getAttribute('name') && findParentForm(source) === findParentForm(dest);
        }
        function isRadioInput(el) {
            return el.nodeName === 'INPUT' && el.type === 'radio';
        }
        function attachRootListener(domEvents, eventTypeTargets) {
            var root = getRoot();
            var newListener = function (event) {
                var target = event.target;
                if (!isRadioInput(target)) {
                    return;
                }
                for (var eventType in eventTypeTargets) {
                    var newEvent = { type: eventType };
                    var listeningNodes = eventTypeTargets[eventType];
                    listeningNodes.forEach(function (el) {
                        if (shouldReceiveEventFromRadio(target, el)) {
                            domEvents.dispatch(el, newEvent, false);
                        }
                    });
                }
            };
            domEvents.addEventListener(root, 'change', newListener);
            return newListener;
        }
        function detachRootListener(domEvents, listener) {
            var root = getRoot();
            domEvents.removeEventListener(root, 'change', listener);
        }
        var radioChangeEvent = {
            defaultEventType: 'radiochange',
            addEventListener: function (target, eventType, handler) {
                if (!isRadioInput(target)) {
                    throw new Error('Listeners for ' + eventType + ' must be radio inputs');
                }
                var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
                if (!eventTypeTrackedRadios) {
                    eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios = {};
                    if (!radioChangeEvent._rootListener) {
                        radioChangeEvent._rootListener = attachRootListener(this, eventTypeTrackedRadios);
                    }
                }
                var trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType];
                if (!trackedRadios) {
                    trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType] = new Set();
                }
                trackedRadios.add(target);
                target.addEventListener(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                target.removeEventListener(eventType, handler);
                var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
                if (!eventTypeTrackedRadios) {
                    return;
                }
                var trackedRadios = eventTypeTrackedRadios[eventType];
                if (!trackedRadios) {
                    return;
                }
                trackedRadios.delete(target);
                if (trackedRadios.size === 0) {
                    delete eventTypeTrackedRadios[eventType];
                    for (var key in eventTypeTrackedRadios) {
                        if (eventTypeTrackedRadios.hasOwnProperty(key)) {
                            return;
                        }
                    }
                    delete radioChangeEvent._eventTypeTrackedRadios;
                    detachRootListener(this, radioChangeEvent._rootListener);
                    delete radioChangeEvent._rootListener;
                }
            }
        };
        module.exports = namespace.domEventRadioChange = radioChangeEvent;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-attribute-observable@1.2.7#can-attribute-observable*/
define('can-attribute-observable@1.2.7#can-attribute-observable', [
    'require',
    'exports',
    'module',
    'can-queues',
    './event',
    'can-reflect',
    'can-observation',
    './behaviors',
    './get-event-name',
    'can-reflect-dependencies',
    'can-observation-recorder',
    'can-simple-observable/settable/settable',
    'can-assign',
    'can-symbol',
    'can-dom-events',
    'can-event-dom-radiochange'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var queues = require('can-queues');
        var canEvent = require('./event');
        var canReflect = require('can-reflect');
        var Observation = require('can-observation');
        var attr = require('./behaviors');
        var getEventName = require('./get-event-name');
        var canReflectDeps = require('can-reflect-dependencies');
        var ObservationRecorder = require('can-observation-recorder');
        var SettableObservable = require('can-simple-observable/settable/settable');
        var canAssign = require('can-assign');
        var canSymbol = require('can-symbol');
        var onValueSymbol = canSymbol.for('can.onValue');
        var offValueSymbol = canSymbol.for('can.offValue');
        var onEmitSymbol = canSymbol.for('can.onEmit');
        var offEmitSymbol = canSymbol.for('can.offEmit');
        var domEvents = require('can-dom-events');
        var radioChangeEvent = require('can-event-dom-radiochange');
        var internalRadioChangeEventType = 'can-attribute-observable-radiochange';
        domEvents.addEvent(radioChangeEvent, internalRadioChangeEventType);
        var isSelect = function isSelect(el) {
            return el.nodeName.toLowerCase() === 'select';
        };
        var isMultipleSelect = function isMultipleSelect(el, prop) {
            return isSelect(el) && prop === 'value' && el.multiple;
        };
        var slice = Array.prototype.slice;
        function canUtilAEL() {
            var args = slice.call(arguments, 0);
            args.unshift(this);
            return domEvents.addEventListener.apply(null, args);
        }
        function canUtilREL() {
            var args = slice.call(arguments, 0);
            args.unshift(this);
            return domEvents.removeEventListener.apply(null, args);
        }
        function AttributeObservable(el, prop, bindingData, event) {
            if (typeof bindingData === 'string') {
                event = bindingData;
                bindingData = undefined;
            }
            this.el = el;
            this.bound = false;
            this.prop = isMultipleSelect(el, prop) ? 'values' : prop;
            this.event = event || getEventName(el, prop);
            this.handler = this.handler.bind(this);
            if (event !== undefined) {
                this[onValueSymbol] = null;
                this[offValueSymbol] = null;
                this[onEmitSymbol] = AttributeObservable.prototype.on;
                this[offEmitSymbol] = AttributeObservable.prototype.off;
            }
        }
        AttributeObservable.prototype = Object.create(SettableObservable.prototype);
        canAssign(AttributeObservable.prototype, {
            constructor: AttributeObservable,
            get: function get() {
                if (ObservationRecorder.isRecording()) {
                    ObservationRecorder.add(this);
                    if (!this.bound) {
                        Observation.temporarilyBind(this);
                    }
                }
                var value = attr.get(this.el, this.prop);
                if (typeof value === 'function') {
                    value = value.bind(this.el);
                }
                return value;
            },
            set: function set(newVal) {
                var setterDispatchedEvents = attr.setAttrOrProp(this.el, this.prop, newVal);
                if (!setterDispatchedEvents) {
                    this._value = newVal;
                }
                return newVal;
            },
            handler: function handler(newVal, event) {
                var old = this._value;
                var queuesArgs = [];
                this._value = attr.get(this.el, this.prop);
                if (event !== undefined || this._value !== old) {
                    queuesArgs = [
                        this.handlers.getNode([]),
                        this,
                        [
                            newVal,
                            old
                        ]
                    ];
                    queues.enqueueByQueue.apply(queues, queuesArgs);
                }
            },
            onBound: function onBound() {
                var observable = this;
                observable.bound = true;
                observable._handler = function (event) {
                    observable.handler(attr.get(observable.el, observable.prop), event);
                };
                if (observable.event === internalRadioChangeEventType) {
                    canEvent.on.call(observable.el, 'change', observable._handler);
                }
                var specialBinding = attr.findSpecialListener(observable.prop);
                if (specialBinding) {
                    observable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);
                }
                canEvent.on.call(observable.el, observable.event, observable._handler);
                this._value = attr.get(this.el, this.prop);
            },
            onUnbound: function onUnbound() {
                var observable = this;
                observable.bound = false;
                if (observable.event === internalRadioChangeEventType) {
                    canEvent.off.call(observable.el, 'change', observable._handler);
                }
                if (observable._specialDisposal) {
                    observable._specialDisposal.call(observable.el, canUtilREL);
                    observable._specialDisposal = null;
                }
                canEvent.off.call(observable.el, observable.event, observable._handler);
            },
            valueHasDependencies: function valueHasDependencies() {
                return true;
            },
            getValueDependencies: function getValueDependencies() {
                var m = new Map();
                var s = new Set();
                s.add(this.prop);
                m.set(this.el, s);
                return { keyDependencies: m };
            }
        });
        canReflect.assignSymbols(AttributeObservable.prototype, {
            'can.isMapLike': false,
            'can.getValue': AttributeObservable.prototype.get,
            'can.setValue': AttributeObservable.prototype.set,
            'can.onValue': AttributeObservable.prototype.on,
            'can.offValue': AttributeObservable.prototype.off,
            'can.valueHasDependencies': AttributeObservable.prototype.hasDependencies,
            'can.getValueDependencies': AttributeObservable.prototype.getValueDependencies
        });
        module.exports = AttributeObservable;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.10.9#can-stache-bindings*/
define('can-stache-bindings@4.10.9#can-stache-bindings', [
    'require',
    'exports',
    'module',
    'can-bind',
    'can-stache/src/expression',
    'can-view-callbacks',
    'can-view-model',
    'can-stache-key',
    'can-observation-recorder',
    'can-simple-observable',
    'can-view-scope',
    'can-assign',
    'can-log/dev/dev',
    'can-dom-mutate',
    'can-dom-data',
    'can-symbol',
    'can-reflect',
    'can-reflect-dependencies',
    'can-attribute-encoder',
    'can-queues',
    'can-simple-observable/setter/setter',
    'can-attribute-observable',
    'can-view-scope/make-compute-like',
    'can-view-nodelist',
    'can-event-queue/map/map'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Bind = require('can-bind');
        var expression = require('can-stache/src/expression');
        var viewCallbacks = require('can-view-callbacks');
        var canViewModel = require('can-view-model');
        var stacheKey = require('can-stache-key');
        var ObservationRecorder = require('can-observation-recorder');
        var SimpleObservable = require('can-simple-observable');
        var Scope = require('can-view-scope');
        var assign = require('can-assign');
        var dev = require('can-log/dev/dev');
        var domMutate = require('can-dom-mutate');
        var domData = require('can-dom-data');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var canReflectDeps = require('can-reflect-dependencies');
        var encoder = require('can-attribute-encoder');
        var queues = require('can-queues');
        var SettableObservable = require('can-simple-observable/setter/setter');
        var AttributeObservable = require('can-attribute-observable');
        var makeCompute = require('can-view-scope/make-compute-like');
        var ViewNodeList = require('can-view-nodelist');
        var canEventQueue = require('can-event-queue/map/map');
        var bindings = new Map();
        var onMatchStr = 'on:', vmMatchStr = 'vm:', elMatchStr = 'el:', byMatchStr = ':by:', toMatchStr = ':to', fromMatchStr = ':from', bindMatchStr = ':bind', viewModelBindingStr = 'viewModel', attributeBindingStr = 'attribute', scopeBindingStr = 'scope', viewModelOrAttributeBindingStr = 'viewModelOrAttribute', viewModelSymbol = canSymbol.for('can.viewModel');
        var throwOnlyOneTypeOfBindingError = function () {
            throw new Error('can-stache-bindings - you can not have contextual bindings ( this:from=\'value\' ) and key bindings ( prop:from=\'value\' ) on one element.');
        };
        var checkBindingState = function (bindingState, siblingBindingData) {
            var isSettingOnViewModel = siblingBindingData.parent.exports && siblingBindingData.child.source === viewModelBindingStr;
            if (isSettingOnViewModel) {
                var bindingName = siblingBindingData.child.name;
                var isSettingViewModel = isSettingOnViewModel && (bindingName === 'this' || bindingName === '.');
                if (isSettingViewModel) {
                    if (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
                        throwOnlyOneTypeOfBindingError();
                    } else {
                        return {
                            isSettingViewModel: true,
                            initialViewModelData: undefined
                        };
                    }
                } else {
                    if (bindingState.isSettingViewModel) {
                        throwOnlyOneTypeOfBindingError();
                    } else {
                        return {
                            isSettingOnViewModel: true,
                            initialViewModelData: bindingState.initialViewModelData
                        };
                    }
                }
            } else {
                return bindingState;
            }
        };
        var getEventBindingData = function (attributeName, el, scope) {
            var bindingCode = attributeName.substr(onMatchStr.length);
            var viewModel = el && el[viewModelSymbol];
            var elUsed = startsWith.call(bindingCode, elMatchStr);
            var vmUsed = startsWith.call(bindingCode, vmMatchStr);
            var byUsed = bindingCode.indexOf(byMatchStr) > -1;
            var scopeUsed;
            var bindingContext;
            var eventName;
            var bindingContextObservable;
            var shortBindingCode = '';
            if (vmUsed) {
                shortBindingCode = 'vm';
                bindingCode = bindingCode.substr(vmMatchStr.length);
            } else if (elUsed) {
                shortBindingCode = 'el';
                bindingCode = bindingCode.substr(elMatchStr.length);
            } else if (!vmUsed && !elUsed) {
                if (byUsed) {
                    scopeUsed = true;
                } else if (viewModel) {
                    vmUsed = true;
                } else {
                    elUsed = true;
                }
            }
            var bindingContextKey;
            if (byUsed) {
                var byIndex = bindingCode.indexOf(byMatchStr);
                bindingContextKey = bindingCode.substr(byIndex + byMatchStr.length);
                bindingCode = bindingCode.substr(0, byIndex);
            }
            eventName = bindingCode;
            if (elUsed) {
                if (byUsed) {
                    throw new Error('binding with :by in element scope is not currently supported');
                } else {
                    bindingContext = el;
                }
            } else if (vmUsed) {
                bindingContext = viewModel;
                if (byUsed) {
                    bindingContext = viewModel.get(bindingContextKey);
                    bindingContextObservable = new Scope(viewModel).computeData(bindingContextKey);
                }
            } else if (scopeUsed) {
                bindingContext = scope;
                if (byUsed) {
                    bindingContext = bindingContext.get(bindingContextKey);
                    bindingContextObservable = scope.computeData(bindingContextKey);
                }
            }
            return {
                bindingContext: bindingContext,
                bindingContextObservable: bindingContextObservable,
                eventName: eventName,
                bindingCode: shortBindingCode
            };
        };
        var onKeyValueSymbol = canSymbol.for('can.onKeyValue');
        var makeScopeFromEvent = function (element, event, viewModel, args, data, bindingContext) {
            var shiftArgumentsForLegacyArguments = bindingContext && bindingContext[onKeyValueSymbol] !== undefined;
            var specialValues = {
                element: element,
                event: event,
                viewModel: viewModel,
                arguments: shiftArgumentsForLegacyArguments ? Array.prototype.slice.call(args, 1) : args,
                args: args
            };
            return data.scope.add(specialValues, { special: true });
        };
        var runEventCallback = function (el, ev, data, scope, expr, attributeName, attrVal) {
            var updateFn = function () {
                var value = expr.value(scope, { doNotWrapInObservation: true });
                value = canReflect.isValueLike(value) ? canReflect.getValue(value) : value;
                return typeof value === 'function' ? value(el) : value;
            };
            queues.batch.start();
            var mutateQueueArgs = [];
            mutateQueueArgs = [
                updateFn,
                null,
                null,
                {}
            ];
            queues.mutateQueue.enqueue.apply(queues.mutateQueue, mutateQueueArgs);
            queues.batch.stop();
        };
        var behaviors = {
            initializeViewModel: function (bindings, initialViewModelData, makeViewModel, bindingContext) {
                var onCompleteBindings = [], onTeardowns = {};
                var bindingsState = {
                    isSettingOnViewModel: false,
                    isSettingViewModel: false,
                    initialViewModelData: initialViewModelData || {}
                };
                bindings.forEach(function (dataBinding) {
                    dataBinding.binding.startParent();
                    var siblingBindingData = dataBinding.siblingBindingData;
                    bindingsState = checkBindingState(bindingsState, siblingBindingData);
                    if (siblingBindingData.parent.exports) {
                        var parentValue = siblingBindingData.child.setCompute ? makeCompute(dataBinding.binding.parent) : dataBinding.binding.parentValue;
                        if (parentValue !== undefined) {
                            if (bindingsState.isSettingViewModel) {
                                bindingsState.initialViewModelData = parentValue;
                            } else {
                                bindingsState.initialViewModelData[cleanVMName(siblingBindingData.child.name, bindingContext.scope)] = parentValue;
                            }
                        }
                    }
                    onCompleteBindings.push(dataBinding.binding.start.bind(dataBinding.binding));
                    onTeardowns[siblingBindingData.bindingAttributeName] = dataBinding.binding.stop.bind(dataBinding.binding);
                });
                var viewModel = makeViewModel(bindingsState.initialViewModelData, bindings.length > 0, bindingsState);
                for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                    onCompleteBindings[i]();
                }
                return {
                    viewModel: viewModel,
                    onTeardowns: onTeardowns,
                    bindingsState: bindingsState
                };
            },
            viewModel: function (el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {
                var attributeViewModelBindings = assign({}, initialViewModelData), bindingContext = assign({
                        element: el,
                        viewModel: undefined
                    }, tagData), bindingSettings = {
                        attributeViewModelBindings: attributeViewModelBindings,
                        alreadyUpdatedChild: true,
                        favorViewModel: true
                    }, dataBindings = [];
                canReflect.eachListLike(el.attributes || [], function (node) {
                    var dataBinding = makeDataBinding(node, bindingContext, bindingSettings);
                    if (dataBinding) {
                        dataBindings.push(dataBinding);
                    }
                });
                if (staticDataBindingsOnly && dataBindings.length === 0) {
                    return;
                }
                var completedData = behaviors.initializeViewModel(dataBindings, initialViewModelData, function () {
                        bindingContext.viewModel = makeViewModel.apply(this, arguments);
                    }, bindingContext), onTeardowns = completedData.onTeardowns, bindingsState = completedData.bindingsState, siblingBindingDatas = {};
                var attributeDisposal;
                if (!bindingsState.isSettingViewModel) {
                    bindingSettings.alreadyUpdatedChild = false;
                    attributeDisposal = domMutate.onNodeAttributeChange(el, function (ev) {
                        var attrName = ev.attributeName, value = el.getAttribute(attrName);
                        if (onTeardowns[attrName]) {
                            onTeardowns[attrName]();
                        }
                        var parentBindingWasAttribute = siblingBindingDatas[attrName] && siblingBindingDatas[attrName].parent.source === attributeBindingStr;
                        if (value !== null || parentBindingWasAttribute) {
                            var dataBinding = makeDataBinding({
                                name: attrName,
                                value: value
                            }, bindingContext, bindingSettings);
                            if (dataBinding) {
                                dataBinding.binding.start();
                                siblingBindingDatas[attrName] = dataBinding.siblingBindingData;
                                onTeardowns[attrName] = dataBinding.binding.stop.bind(dataBinding.binding);
                            }
                        }
                    });
                }
                return function () {
                    if (attributeDisposal) {
                        attributeDisposal();
                        attributeDisposal = undefined;
                    }
                    for (var attrName in onTeardowns) {
                        onTeardowns[attrName]();
                    }
                };
            },
            data: function (el, attrData) {
                if (domData.get(el, 'preventDataBindings')) {
                    return;
                }
                var viewModel, getViewModel = ObservationRecorder.ignore(function () {
                        return viewModel || (viewModel = canViewModel(el));
                    }), teardown, attributeDisposal, removedDisposal, bindingContext = {
                        element: el,
                        templateType: attrData.templateType,
                        scope: attrData.scope,
                        parentNodeList: attrData.nodeList,
                        get viewModel() {
                            return getViewModel();
                        }
                    };
                var dataBinding = makeDataBinding({
                    name: attrData.attributeName,
                    value: el.getAttribute(attrData.attributeName)
                }, bindingContext, { syncChildWithParent: false });
                dataBinding.binding.start();
                var attributeListener = function (ev) {
                    var attrName = ev.attributeName, value = el.getAttribute(attrName);
                    if (attrName === attrData.attributeName) {
                        if (teardown) {
                            teardown();
                        }
                        if (value !== null) {
                            var dataBinding = makeDataBinding({
                                name: attrName,
                                value: value
                            }, bindingContext, { syncChildWithParent: false });
                            if (dataBinding) {
                                dataBinding.binding.start();
                                teardown = dataBinding.binding.stop.bind(dataBinding.binding);
                            }
                            teardown = dataBinding.onTeardown;
                        }
                    }
                };
                var tearItAllDown = function () {
                    if (teardown) {
                        teardown();
                        teardown = undefined;
                    }
                    if (removedDisposal) {
                        removedDisposal();
                        removedDisposal = undefined;
                    }
                    if (attributeDisposal) {
                        attributeDisposal();
                        attributeDisposal = undefined;
                    }
                };
                if (attrData.nodeList) {
                    ViewNodeList.register([], tearItAllDown, attrData.nodeList, false);
                }
                teardown = dataBinding.binding.stop.bind(dataBinding.binding);
                attributeDisposal = domMutate.onNodeAttributeChange(el, attributeListener);
                removedDisposal = domMutate.onNodeRemoval(el, function () {
                    var doc = el.ownerDocument;
                    var ownerNode = doc.contains ? doc : doc.documentElement;
                    if (!ownerNode || ownerNode.contains(el) === false) {
                        tearItAllDown();
                    }
                });
            },
            event: function (el, data) {
                var eventBindingData;
                var attributeName = encoder.decode(data.attributeName), event, bindingContext, bindingContextObservable;
                if (attributeName.indexOf(toMatchStr + ':') !== -1 || attributeName.indexOf(fromMatchStr + ':') !== -1 || attributeName.indexOf(bindMatchStr + ':') !== -1) {
                    return this.data(el, data);
                }
                if (startsWith.call(attributeName, onMatchStr)) {
                    eventBindingData = getEventBindingData(attributeName, el, data.scope);
                    event = eventBindingData.eventName;
                    bindingContext = eventBindingData.bindingContext;
                    bindingContextObservable = eventBindingData.bindingContextObservable;
                } else {
                    throw new Error('can-stache-bindings - unsupported event bindings ' + attributeName);
                }
                var handler = function (ev) {
                    var attrVal = el.getAttribute(encoder.encode(attributeName));
                    if (!attrVal) {
                        return;
                    }
                    var viewModel = el[viewModelSymbol];
                    var expr = expression.parse(attrVal, {
                        lookupRule: function () {
                            return expression.Lookup;
                        },
                        methodRule: 'call'
                    });
                    var runScope = makeScopeFromEvent(el, ev, viewModel, arguments, data, bindingContext);
                    if (expr instanceof expression.Hashes) {
                        var hashExprs = expr.hashExprs;
                        var key = Object.keys(hashExprs)[0];
                        var value = expr.hashExprs[key].value(runScope);
                        var isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);
                        runScope.set(key, isObservableValue ? canReflect.getValue(value) : value);
                    } else if (expr instanceof expression.Call) {
                        runEventCallback(el, ev, data, runScope, expr, attributeName, attrVal);
                    } else {
                        throw new Error('can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in ' + data.attributeName + '=' + JSON.stringify(attrVal));
                    }
                };
                var attributesDisposal, removalDisposal, removeObservation, currentContext;
                var attributesHandler = function (ev) {
                    var isEventAttribute = ev.attributeName === attributeName;
                    var isRemoved = !el.getAttribute(attributeName);
                    var isEventAttributeRemoved = isEventAttribute && isRemoved;
                    if (isEventAttributeRemoved) {
                        unbindEvent();
                    }
                };
                var removalHandler = function () {
                    var doc = el.ownerDocument;
                    var ownerNode = doc.contains ? doc : doc.documentElement;
                    if (!ownerNode || !ownerNode.contains(el)) {
                        unbindEvent();
                    }
                };
                var unbindEvent = function () {
                    if (bindingContext) {
                        canEventQueue.off.call(bindingContext, event, handler);
                    }
                    if (attributesDisposal) {
                        attributesDisposal();
                        attributesDisposal = undefined;
                    }
                    if (removalDisposal) {
                        removalDisposal();
                        removalDisposal = undefined;
                    }
                    if (removeObservation) {
                        removeObservation();
                        removeObservation = undefined;
                    }
                };
                function updateListener(newVal, oldVal) {
                    if (oldVal) {
                        canEventQueue.off.call(oldVal, event, handler);
                    }
                    if (newVal) {
                        canEventQueue.on.call(newVal, event, handler);
                        currentContext = newVal;
                    }
                }
                attributesDisposal = domMutate.onNodeAttributeChange(el, attributesHandler);
                removalDisposal = domMutate.onNodeRemoval(el, removalHandler);
                if (!bindingContext && bindingContextObservable) {
                    removeObservation = function () {
                        if (currentContext) {
                            canEventQueue.off.call(currentContext, event, handler);
                        }
                        canReflect.offValue(bindingContextObservable, updateListener);
                    };
                    canReflect.onValue(bindingContextObservable, updateListener);
                } else {
                    canEventQueue.on.call(bindingContext, event, handler);
                }
            }
        };
        bindings.set(/[\w\.:]+:to$/, behaviors.data);
        bindings.set(/[\w\.:]+:from$/, behaviors.data);
        bindings.set(/[\w\.:]+:bind$/, behaviors.data);
        bindings.set(/[\w\.:]+:raw$/, behaviors.data);
        bindings.set(/[\w\.:]+:to:on:[\w\.:]+/, behaviors.data);
        bindings.set(/[\w\.:]+:from:on:[\w\.:]+/, behaviors.data);
        bindings.set(/[\w\.:]+:bind:on:[\w\.:]+/, behaviors.data);
        bindings.set(/on:[\w\.:]+/, behaviors.event);
        var getObservableFrom = {
            viewModelOrAttribute: function (bindingData, bindingContext) {
                var viewModel = bindingContext.element[viewModelSymbol];
                if (viewModel) {
                    return this.viewModel.apply(this, arguments);
                } else {
                    return this.attribute.apply(this, arguments);
                }
            },
            scope: function (bindingData, bindingContext) {
                var scope = bindingContext.scope, scopeProp = bindingData.name, mustBeGettable = bindingData.exports;
                if (!scopeProp) {
                    return new SimpleObservable();
                } else {
                    if (mustBeGettable || scopeProp.indexOf('(') >= 0 || scopeProp.indexOf('=') >= 0) {
                        var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                        if (parentExpression instanceof expression.Hashes) {
                            return new SimpleObservable(function () {
                                var hashExprs = parentExpression.hashExprs;
                                var key = Object.keys(hashExprs)[0];
                                var value = parentExpression.hashExprs[key].value(scope);
                                var isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);
                                scope.set(key, isObservableValue ? canReflect.getValue(value) : value);
                            });
                        } else {
                            return parentExpression.value(scope);
                        }
                    } else {
                        var observation = {};
                        canReflect.assignSymbols(observation, {
                            'can.getValue': function getValue() {
                            },
                            'can.valueHasDependencies': function hasValueDependencies() {
                                return false;
                            },
                            'can.setValue': function setValue(newVal) {
                                var expr = expression.parse(cleanVMName(scopeProp, scope), { baseMethodType: 'Call' });
                                var value = expr.value(scope);
                                canReflect.setValue(value, newVal);
                            },
                            'can.getWhatIChange': function getWhatIChange() {
                                var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
                                var m = new Map();
                                var s = new Set();
                                s.add(data.key);
                                m.set(data.parent, s);
                                return { mutate: { keyDependencies: m } };
                            },
                            'can.getName': function getName() {
                            }
                        });
                        var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
                        if (data.parent && data.key) {
                            canReflectDeps.addMutatedBy(data.parent, data.key, observation);
                        }
                        return observation;
                    }
                }
            },
            viewModel: function (bindingData, bindingContext) {
                var scope = bindingContext.scope, vmName = bindingData.name, setCompute = bindingData.setCompute;
                var setName = cleanVMName(vmName, scope);
                var isBoundToContext = vmName === '.' || vmName === 'this';
                var keysToRead = isBoundToContext ? [] : stacheKey.reads(vmName);
                function getViewModelProperty() {
                    var viewModel = bindingContext.viewModel;
                    return stacheKey.read(viewModel, keysToRead, {}).value;
                }
                var observation = new SettableObservable(getViewModelProperty, function setViewModelProperty(newVal) {
                    var viewModel = bindingContext.viewModel;
                    if (setCompute) {
                        var oldValue = canReflect.getKeyValue(viewModel, setName);
                        if (canReflect.isObservableLike(oldValue)) {
                            canReflect.setValue(oldValue, newVal);
                        } else {
                            canReflect.setKeyValue(viewModel, setName, new SimpleObservable(canReflect.getValue(newVal)));
                        }
                    } else {
                        if (isBoundToContext) {
                            canReflect.setValue(viewModel, newVal);
                        } else {
                            stacheKey.write(viewModel, keysToRead, newVal);
                        }
                    }
                });
                return observation;
            },
            attribute: function (bindingData, bindingContext) {
                if (bindingData.name === 'this') {
                    return canReflect.assignSymbols({}, {
                        'can.getValue': function () {
                            return bindingContext.element;
                        },
                        'can.valueHasDependencies': function () {
                            return false;
                        },
                        'can.getName': function getName() {
                        }
                    });
                } else {
                    return new AttributeObservable(bindingContext.element, bindingData.name, {}, bindingData.event);
                }
            }
        };
        var startsWith = String.prototype.startsWith || function (text) {
            return this.indexOf(text) === 0;
        };
        function getEventName(result) {
            if (result.special.on !== undefined) {
                return result.tokens[result.special.on + 1];
            }
        }
        var siblingBindingRules = {
            to: {
                child: {
                    exports: true,
                    syncSibling: false
                },
                parent: {
                    exports: false,
                    syncSibling: false
                }
            },
            from: {
                child: {
                    exports: false,
                    syncSibling: false
                },
                parent: {
                    exports: true,
                    syncSibling: false
                }
            },
            bind: {
                child: {
                    exports: true,
                    syncSibling: false
                },
                parent: {
                    exports: true,
                    syncSibling: true
                }
            },
            raw: {
                child: {
                    exports: false,
                    syncSibling: false
                },
                parent: {
                    exports: true,
                    syncSibling: false
                }
            }
        };
        var bindingNames = [];
        var special = {
            vm: true,
            on: true
        };
        canReflect.eachKey(siblingBindingRules, function (value, key) {
            bindingNames.push(key);
            special[key] = true;
        });
        function tokenize(source) {
            var splitByColon = source.split(':');
            var result = {
                tokens: [],
                special: {}
            };
            splitByColon.forEach(function (token) {
                if (special[token]) {
                    result.special[token] = result.tokens.push(token) - 1;
                } else {
                    result.tokens.push(token);
                }
            });
            return result;
        }
        var getChildBindingStr = function (tokens, favorViewModel) {
            if (tokens.indexOf('vm') >= 0) {
                return viewModelBindingStr;
            } else if (tokens.indexOf('el') >= 0) {
                return attributeBindingStr;
            } else {
                return favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;
            }
        };
        function getSiblingBindingData(node, bindingSettings) {
            var siblingBindingData, attributeName = encoder.decode(node.name), attributeValue = node.value || '';
            var result = tokenize(attributeName), dataBindingName, specialIndex;
            bindingNames.forEach(function (name) {
                if (result.special[name] !== undefined && result.special[name] > 0) {
                    dataBindingName = name;
                    specialIndex = result.special[name];
                    return false;
                }
            });
            if (dataBindingName) {
                var childEventName = getEventName(result);
                var initializeValues = childEventName && dataBindingName !== 'bind' ? false : true;
                siblingBindingData = {
                    parent: assign({
                        source: scopeBindingStr,
                        name: result.special.raw ? '"' + attributeValue + '"' : attributeValue
                    }, siblingBindingRules[dataBindingName].parent),
                    child: assign({
                        source: getChildBindingStr(result.tokens, bindingSettings && bindingSettings.favorViewModel),
                        name: result.tokens[specialIndex - 1],
                        event: childEventName
                    }, siblingBindingRules[dataBindingName].child),
                    bindingAttributeName: attributeName,
                    initializeValues: initializeValues
                };
                if (attributeValue.trim().charAt(0) === '~') {
                    siblingBindingData.child.setCompute = true;
                }
                return siblingBindingData;
            }
        }
        var makeDataBinding = function (node, bindingContext, bindingSettings) {
            var siblingBindingData = getSiblingBindingData(node, bindingSettings);
            if (!siblingBindingData) {
                return;
            }
            var parentObservable = getObservableFrom[siblingBindingData.parent.source](siblingBindingData.parent, bindingContext, bindingSettings), childObservable = getObservableFrom[siblingBindingData.child.source](siblingBindingData.child, bindingContext, bindingSettings, parentObservable);
            var childToParent = !!siblingBindingData.child.exports;
            var parentToChild = !!siblingBindingData.parent.exports;
            var bindingOptions = {
                child: childObservable,
                childToParent: childToParent,
                cycles: childToParent === true && parentToChild === true ? 0 : 100,
                onInitDoNotUpdateChild: bindingSettings.alreadyUpdatedChild || siblingBindingData.initializeValues === false,
                onInitDoNotUpdateParent: siblingBindingData.initializeValues === false,
                onInitSetUndefinedParentIfChildIsDefined: true,
                parent: parentObservable,
                parentToChild: parentToChild,
                priority: bindingContext.parentNodeList ? bindingContext.parentNodeList.nesting + 1 : undefined,
                queue: 'domUI',
                sticky: siblingBindingData.parent.syncSibling ? 'childSticksToParent' : undefined
            };
            var canBinding = new Bind(bindingOptions);
            return {
                siblingBindingData: siblingBindingData,
                binding: canBinding
            };
        };
        var cleanVMName = function (name, scope) {
            return name.replace(/@/g, '');
        };
        var canStacheBindings = {
            behaviors: behaviors,
            getSiblingBindingData: getSiblingBindingData,
            bindings: bindings,
            getObservableFrom: getObservableFrom,
            makeDataBinding: makeDataBinding
        };
        canStacheBindings[canSymbol.for('can.callbackMap')] = bindings;
        viewCallbacks.attrs(canStacheBindings);
        module.exports = canStacheBindings;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-key@1.2.1#utils*/
define('can-key@1.2.1#utils', function (require, exports, module) {
    'use strict';
    var utils = {
        isContainer: function (current) {
            var type = typeof current;
            return current && (type === 'object' || type === 'function');
        },
        strReplacer: /\{([^\}]+)\}/g,
        parts: function (name) {
            if (Array.isArray(name)) {
                return name;
            } else {
                return typeof name !== 'undefined' ? (name + '').replace(/\[/g, '.').replace(/]/g, '').split('.') : [];
            }
        }
    };
    module.exports = utils;
});
/*can-key@1.2.1#get/get*/
define('can-key@1.2.1#get/get', [
    'require',
    'exports',
    'module',
    'can-reflect',
    '../utils'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var utils = require('../utils');
    function get(obj, name) {
        var parts = utils.parts(name);
        var length = parts.length, current, i, container;
        if (!length) {
            return obj;
        }
        current = obj;
        for (i = 0; i < length && utils.isContainer(current) && current !== null; i++) {
            container = current;
            current = canReflect.getKeyValue(container, parts[i]);
        }
        return current;
    }
    module.exports = get;
});
/*can-control@4.4.3#can-control*/
define('can-control@4.4.3#can-control', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-namespace',
    'can-assign',
    'can-stache-key',
    'can-reflect',
    'can-observation',
    'can-event-queue/map/map',
    'can-log/dev/dev',
    'can-string',
    'can-key/get/get',
    'can-dom-mutate',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var Construct = require('can-construct');
    var namespace = require('can-namespace');
    var assign = require('can-assign');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var canEvent = require('can-event-queue/map/map');
    var dev = require('can-log/dev/dev');
    var string = require('can-string');
    var get = require('can-key/get/get');
    var domMutate = require('can-dom-mutate');
    var canSymbol = require('can-symbol');
    var controlsSymbol = canSymbol.for('can.controls');
    var processors;
    var bind = function (el, ev, callback, queue) {
            canEvent.on.call(el, ev, callback, queue);
            return function () {
                canEvent.off.call(el, ev, callback, queue);
            };
        }, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, delegate = function (el, selector, ev, callback) {
            canEvent.on.call(el, ev, selector, callback);
            return function () {
                canEvent.off.call(el, ev, selector, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, selector.trim(), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = Construct.extend('Control', {
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (typeof method !== 'function') {
                method = context[method];
            }
            var Control = this;
            function controlMethod() {
                var wrapped = Control.wrapElement(this);
                context.called = name;
                return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
            }
            return controlMethod;
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && typeof this.prototype[val] === 'function') && !!(Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options, controlInstance) {
            var readyCompute, unableToBind;
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                var controlActionData = function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value, parent;
                        if (this._isDelegate(options, key)) {
                            delegate = this._getDelegate(options, key);
                            return '';
                        }
                        key = this._removeDelegateFromKey(key);
                        parent = this._lookup(options)[0];
                        value = observeReader.read(parent, observeReader.reads(key), { readCompute: false }).value;
                        if (value === undefined && typeof window !== 'undefined') {
                            value = get(window, key);
                        }
                        if (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {
                            unableToBind = true;
                            return null;
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    }.bind(this));
                    name = name.trim();
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || basicProcessor,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                };
                readyCompute = new Observation(controlActionData, this);
                if (controlInstance) {
                    var handler = function (actionData) {
                        controlInstance._bindings.control[methodName](controlInstance.element);
                        controlInstance._bindings.control[methodName] = actionData.processor(actionData.delegate || controlInstance.element, actionData.parts[2], actionData.parts[1], methodName, controlInstance);
                    };
                    canReflect.onValue(readyCompute, handler, 'mutate');
                    controlInstance._bindings.readyComputes[methodName] = {
                        compute: readyCompute,
                        handler: handler
                    };
                }
                return readyCompute.get();
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key;
        },
        _isDelegate: function (options, key) {
            return key === 'element';
        },
        _getDelegate: function (options, key) {
            return undefined;
        },
        processors: {},
        defaults: {},
        convertElement: function (element) {
            element = typeof element === 'string' ? document.querySelector(element) : element;
            return this.wrapElement(element);
        },
        wrapElement: function (el) {
            return el;
        },
        unwrapElement: function (el) {
            return el;
        },
        isSpecial: function (eventName) {
            return eventName === 'inserted' || eventName === 'removed';
        }
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls.shortName, arr;
            if (!element) {
                throw new Error('Creating an instance of a named control without passing an element');
            }
            this.element = cls.convertElement(element);
            if (pluginname && pluginname !== 'Control' && this.element.classList) {
                this.element.classList.add(pluginname);
            }
            arr = this.element[controlsSymbol];
            if (!arr) {
                arr = [];
                this.element[controlsSymbol] = arr;
            }
            arr.push(this);
            if (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {
                for (var prop in cls.defaults) {
                    if (!options.hasOwnProperty(prop)) {
                        observeReader.set(options, prop, cls.defaults[prop]);
                    }
                }
                this.options = options;
            } else {
                this.options = assign(assign({}, cls.defaults), options);
            }
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = this.constructor.unwrapElement(this.element), destroyCB = Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                var removalDisposal = domMutate.onNodeRemoval(element, function () {
                    var doc = element.ownerDocument;
                    var ownerNode = doc.contains ? doc : doc.documentElement;
                    if (!ownerNode || ownerNode.contains(element) === false) {
                        destroyCB();
                    }
                });
                bindings.user.push(function () {
                    if (removalDisposal) {
                        removalDisposal();
                        removalDisposal = undefined;
                    }
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = this.constructor.unwrapElement(this.element), bindings = this._bindings;
            if (bindings) {
                (bindings.user || []).forEach(function (value) {
                    value(el);
                });
                canReflect.eachKey(bindings.control || {}, function (value) {
                    value(el);
                });
                canReflect.eachKey(bindings.readyComputes || {}, function (value) {
                    canReflect.offValue(value.compute, value.handler, 'mutate');
                });
            }
            this._bindings = {
                user: [],
                control: {},
                readyComputes: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class.shortName && string.underscore(Class.shortName), controls;
            this.off();
            if (pluginName && pluginName !== 'can_control' && this.element.classList) {
                this.element.classList.remove(pluginName);
            }
            controls = this.element[controlsSymbol];
            if (controls) {
                controls.splice(controls.indexOf(this), 1);
            }
            this.element = null;
        }
    });
    processors = Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, Control._shifter(control, methodName), selector);
    };
    [
        'beforeremove',
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ].forEach(function (v) {
        processors[v] = basicProcessor;
    });
    module.exports = namespace.Control = Control;
});
/*can-component@4.6.2#control/control*/
define('can-component@4.6.2#control/control', [
    'require',
    'exports',
    'module',
    'can-control',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var Control = require('can-control');
    var canReflect = require('can-reflect');
    var paramReplacer = /\{([^\}]+)\}/g;
    var ComponentControl = Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key.replace(/^(scope|^viewModel)\./, '');
        },
        _isDelegate: function (options, key) {
            return key === 'scope' || key === 'viewModel';
        },
        _getDelegate: function (options, key) {
            return options[key];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else {
                return Control._action.apply(this, arguments);
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                canReflect.eachKey(this._bindings.readyComputes || {}, function (value) {
                    canReflect.offValue(value.compute, value.handler);
                });
            }
            Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    module.exports = ComponentControl;
});
/*can-define@2.8.0#list/list*/
define('can-define@2.8.0#list/list', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    'can-queues',
    'can-event-queue/type/type',
    'can-observation-recorder',
    'can-log',
    'can-log/dev/dev',
    '../define-helpers/define-helpers',
    'can-assign',
    'can-diff/list/list',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-single-reference'
], function (require, exports, module) {
    'use strict';
    var Construct = require('can-construct');
    var define = require('can-define');
    var make = define.make;
    var queues = require('can-queues');
    var addTypeEvents = require('can-event-queue/type/type');
    var ObservationRecorder = require('can-observation-recorder');
    var canLog = require('can-log');
    var canLogDev = require('can-log/dev/dev');
    var defineHelpers = require('../define-helpers/define-helpers');
    var assign = require('can-assign');
    var diff = require('can-diff/list/list');
    var ns = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var singleReference = require('can-single-reference');
    var splice = [].splice;
    var runningNative = false;
    var identity = function (x) {
        return x;
    };
    var localOnPatchesSymbol = 'can.patches';
    var makeFilterCallback = function (props) {
        return function (item) {
            for (var prop in props) {
                if (item[prop] !== props[prop]) {
                    return false;
                }
            }
            return true;
        };
    };
    var onKeyValue = define.eventsProto[canSymbol.for('can.onKeyValue')];
    var offKeyValue = define.eventsProto[canSymbol.for('can.offKeyValue')];
    var getSchemaSymbol = canSymbol.for('can.getSchema');
    var inSetupSymbol = canSymbol.for('can.initializing');
    function getSchema() {
        var definitions = this.prototype._define.definitions;
        var schema = {
            type: 'list',
            keys: {}
        };
        schema = define.updateSchemaKeys(schema, definitions);
        if (schema.keys['#']) {
            schema.values = definitions['#'].Type;
            delete schema.keys['#'];
        }
        return schema;
    }
    var DefineList = Construct.extend('DefineList', {
        setup: function (base) {
            if (DefineList) {
                addTypeEvents(this);
                var prototype = this.prototype;
                var result = define(prototype, prototype, base.prototype._define);
                define.makeDefineInstanceKey(this, result);
                var itemsDefinition = result.definitions['#'] || result.defaultDefinition;
                if (itemsDefinition) {
                    if (itemsDefinition.Type) {
                        this.prototype.__type = make.set.Type('*', itemsDefinition.Type, identity);
                    } else if (itemsDefinition.type) {
                        this.prototype.__type = make.set.type('*', itemsDefinition.type, identity);
                    }
                }
                this[getSchemaSymbol] = getSchema;
            }
        }
    }, {
        setup: function (items) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: {
                        definitions: {
                            length: { type: 'number' },
                            _length: { type: 'number' }
                        }
                    }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, {}, false);
            Object.defineProperty(this, '_length', {
                enumerable: false,
                configurable: true,
                writable: true,
                value: 0
            });
            if (items) {
                this.splice.apply(this, [
                    0,
                    0
                ].concat(canReflect.toArray(items)));
            }
        },
        __type: define.types.observable,
        _triggerChange: function (attr, how, newVal, oldVal) {
            var index = +attr;
            if (!isNaN(index)) {
                var itemsDefinition = this._define.definitions['#'];
                var patches, dispatched;
                if (how === 'add') {
                    if (itemsDefinition && typeof itemsDefinition.added === 'function') {
                        ObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);
                    }
                    patches = [{
                            type: 'splice',
                            insert: newVal,
                            index: index,
                            deleteCount: 0
                        }];
                    dispatched = {
                        type: how,
                        action: 'splice',
                        insert: newVal,
                        index: index,
                        deleteCount: 0,
                        patches: patches
                    };
                    this.dispatch(dispatched, [
                        newVal,
                        index
                    ]);
                } else if (how === 'remove') {
                    if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
                        ObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);
                    }
                    patches = [{
                            type: 'splice',
                            index: index,
                            deleteCount: oldVal.length
                        }];
                    dispatched = {
                        type: how,
                        patches: patches,
                        action: 'splice',
                        index: index,
                        deleteCount: oldVal.length,
                        target: this
                    };
                    this.dispatch(dispatched, [
                        oldVal,
                        index
                    ]);
                } else {
                    this.dispatch(how, [
                        newVal,
                        index
                    ]);
                }
            } else {
                this.dispatch({
                    type: '' + attr,
                    target: this
                }, [
                    newVal,
                    oldVal
                ]);
            }
        },
        get: function (index) {
            if (arguments.length) {
                if (isNaN(index)) {
                    ObservationRecorder.add(this, index);
                } else {
                    ObservationRecorder.add(this, 'length');
                }
                return this[index];
            } else {
                return canReflect.unwrap(this, Map);
            }
        },
        set: function (prop, value) {
            if (typeof prop !== 'object') {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (typeof prop === 'number' && prop > this._length - 1) {
                        var newArr = new Array(prop + 1 - this._length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    }
                    this.splice(prop, 1, value);
                } else {
                    var defined = defineHelpers.defineExpando(this, prop, value);
                    if (!defined) {
                        this[prop] = value;
                    }
                }
            } else {
                if (canReflect.isListLike(prop)) {
                    if (value) {
                        this.replace(prop);
                    } else {
                        canReflect.assignList(this, prop);
                    }
                } else {
                    canReflect.assignMap(this, prop);
                }
            }
            return this;
        },
        assign: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignList(this, prop);
            } else {
                canReflect.assignMap(this, prop);
            }
            return this;
        },
        update: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateList(this, prop);
            } else {
                canReflect.updateMap(this, prop);
            }
            return this;
        },
        assignDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignDeepList(this, prop);
            } else {
                canReflect.assignDeepMap(this, prop);
            }
            return this;
        },
        updateDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateDeepList(this, prop);
            } else {
                canReflect.updateDeepMap(this, prop);
            }
            return this;
        },
        _items: function () {
            var arr = [];
            this._each(function (item) {
                arr.push(item);
            });
            return arr;
        },
        _each: function (callback) {
            for (var i = 0, len = this._length; i < len; i++) {
                callback(this[i], i);
            }
        },
        splice: function (index, howMany) {
            var args = canReflect.toArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2, oldLength = this._length;
            index = index || 0;
            for (i = 0, len = args.length - 2; i < len; i++) {
                listIndex = i + 2;
                args[listIndex] = this.__type(args[listIndex], listIndex);
                added.push(args[listIndex]);
                if (this[i + index] !== args[listIndex]) {
                    allSame = false;
                }
            }
            if (allSame && this._length <= added.length) {
                return added;
            }
            if (howMany === undefined) {
                howMany = args[1] = this._length - index;
            }
            runningNative = true;
            var removed = splice.apply(this, args);
            runningNative = false;
            queues.batch.start();
            if (howMany > 0) {
                this._triggerChange('' + index, 'remove', undefined, removed);
            }
            if (args.length > 2) {
                this._triggerChange('' + index, 'add', added, removed);
            }
            this.dispatch('length', [
                this._length,
                oldLength
            ]);
            queues.batch.stop();
            return removed;
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        }
    });
    for (var prop in define.eventsProto) {
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineList.prototype, sym, {
            configurable: true,
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    var getArgs = function (args) {
        return args[0] && Array.isArray(args[0]) ? args[0] : canReflect.toArray(args);
    };
    canReflect.eachKey({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            var args = [], len = where ? this._length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = this.__type(val, i);
            }
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            if (!this.comparator || args.length) {
                queues.batch.start();
                this._triggerChange('' + len, 'add', args, undefined);
                this.dispatch('length', [
                    this._length,
                    len
                ]);
                queues.batch.stop();
            }
            return res;
        };
    });
    canReflect.eachKey({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            if (!this._length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this._length ? this._length - 1 : 0, oldLength = this._length ? this._length : 0, res;
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            queues.batch.start();
            this._triggerChange('' + len, 'remove', undefined, [res]);
            this.dispatch('length', [
                this._length,
                oldLength
            ]);
            queues.batch.stop();
            return res;
        };
    });
    canReflect.eachKey({
        'map': 3,
        'filter': 3,
        'reduce': 4,
        'reduceRight': 4,
        'every': 3,
        'some': 3
    }, function a(fnLength, fnName) {
        DefineList.prototype[fnName] = function () {
            var self = this;
            var args = [].slice.call(arguments, 0);
            var callback = args[0];
            var thisArg = args[fnLength - 1] || self;
            if (typeof callback === 'object') {
                callback = makeFilterCallback(callback);
            }
            args[0] = function () {
                var cbArgs = [].slice.call(arguments, 0);
                cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
                return callback.apply(thisArg, cbArgs);
            };
            var ret = Array.prototype[fnName].apply(this, args);
            if (fnName === 'map') {
                return new DefineList(ret);
            } else if (fnName === 'filter') {
                return new self.constructor(ret);
            } else {
                return ret;
            }
        };
    });
    assign(DefineList.prototype, {
        includes: function () {
            var arrayIncludes = Array.prototype.includes;
            if (arrayIncludes) {
                return function includes() {
                    return arrayIncludes.apply(this, arguments);
                };
            } else {
                return function includes() {
                    throw new Error('DefineList.prototype.includes must have Array.prototype.includes available. Please add a polyfill to this environment.');
                };
            }
        }(),
        indexOf: function (item, fromIndex) {
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        lastIndexOf: function (item, fromIndex) {
            fromIndex = typeof fromIndex === 'undefined' ? this.length - 1 : fromIndex;
            for (var i = fromIndex; i >= 0; i--) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            ObservationRecorder.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(this._items());
            return this.replace(list);
        },
        slice: function () {
            ObservationRecorder.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            canReflect.eachIndex(arguments, function (arg) {
                if (canReflect.isListLike(arg)) {
                    var arr = Array.isArray(arg) ? arg : canReflect.toArray(arg);
                    arr.forEach(function (innerArg) {
                        args.push(this.__type(innerArg));
                    }, this);
                } else {
                    args.push(this.__type(arg));
                }
            }, this);
            return new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.length; i < len; i++) {
                item = this.get(i);
                if (cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            var patches = diff(this, newList);
            queues.batch.start();
            for (var i = 0, len = patches.length; i < len; i++) {
                this.splice.apply(this, [
                    patches[i].index,
                    patches[i].deleteCount
                ].concat(patches[i].insert));
            }
            queues.batch.stop();
            return this;
        },
        sort: function (compareFunction) {
            var sorting = Array.prototype.slice.call(this);
            Array.prototype.sort.call(sorting, compareFunction);
            this.splice.apply(this, [
                0,
                sorting.length
            ].concat(sorting));
            return this;
        }
    });
    for (var prop in define.eventsProto) {
        DefineList[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    Object.defineProperty(DefineList.prototype, 'length', {
        get: function () {
            if (!this[inSetupSymbol]) {
                ObservationRecorder.add(this, 'length');
            }
            return this._length;
        },
        set: function (newVal) {
            if (runningNative) {
                this._length = newVal;
                return;
            }
            if (newVal == null || isNaN(+newVal) || newVal === this._length) {
                return;
            }
            if (newVal > this._length - 1) {
                var newArr = new Array(newVal - this._length);
                this.push.apply(this, newArr);
            } else {
                this.splice(newVal);
            }
        },
        enumerable: true
    });
    DefineList.prototype.attr = function (prop, value) {
        canLog.warn('DefineMap::attr shouldn\'t be called');
        if (arguments.length === 0) {
            return this.get();
        } else if (prop && typeof prop === 'object') {
            return this.set.apply(this, arguments);
        } else if (arguments.length === 1) {
            return this.get(prop);
        } else {
            return this.set(prop, value);
        }
    };
    DefineList.prototype.item = function (index, value) {
        if (arguments.length === 1) {
            return this.get(index);
        } else {
            return this.set(index, value);
        }
    };
    DefineList.prototype.items = function () {
        canLog.warn('DefineList::get should should be used instead of DefineList::items');
        return this.get();
    };
    var defineListProto = {
        'can.isMoreListLikeThanMapLike': true,
        'can.isMapLike': true,
        'can.isListLike': true,
        'can.isValueLike': false,
        'can.getKeyValue': DefineList.prototype.get,
        'can.setKeyValue': DefineList.prototype.set,
        'can.onKeyValue': function (key, handler, queue) {
            var translationHandler;
            if (isNaN(key)) {
                return onKeyValue.apply(this, arguments);
            } else {
                translationHandler = function () {
                    handler(this[key]);
                };
                singleReference.set(handler, this, translationHandler, key);
                return onKeyValue.call(this, 'length', translationHandler, queue);
            }
        },
        'can.offKeyValue': function (key, handler, queue) {
            var translationHandler;
            if (isNaN(key)) {
                return offKeyValue.apply(this, arguments);
            } else {
                translationHandler = singleReference.getAndDelete(handler, this, key);
                return offKeyValue.call(this, 'length', translationHandler, queue);
            }
        },
        'can.deleteKeyValue': function (prop) {
            prop = isNaN(+prop) || prop % 1 ? prop : +prop;
            if (typeof prop === 'number') {
                this.splice(prop, 1);
            } else if (prop === 'length' || prop === '_length') {
                return;
            } else {
                this.set(prop, undefined);
            }
            return this;
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignList(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            this.replace(source);
            queues.batch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new Set();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        },
        'can.onPatches': function (handler, queue) {
            this[canSymbol.for('can.onKeyValue')](localOnPatchesSymbol, handler, queue);
        },
        'can.offPatches': function (handler, queue) {
            this[canSymbol.for('can.offKeyValue')](localOnPatchesSymbol, handler, queue);
        }
    };
    canReflect.assignSymbols(DefineList.prototype, defineListProto);
    canReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function () {
        var index = -1;
        if (typeof this.length !== 'number') {
            this.length = 0;
        }
        return {
            next: function () {
                index++;
                return {
                    value: this[index],
                    done: index >= this.length
                };
            }.bind(this)
        };
    });
    define.DefineList = DefineList;
    module.exports = ns.DefineList = DefineList;
});
/*can-component@4.6.2#can-component*/
define('can-component@4.6.2#can-component', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-bind',
    'can-construct',
    'can-stache',
    'can-stache-bindings',
    'can-view-scope',
    'can-view-callbacks',
    'can-view-nodelist',
    'can-reflect',
    'can-simple-observable',
    'can-simple-map',
    'can-define/map/map',
    'can-log',
    'can-log/dev/dev',
    'can-assign',
    'can-observation-recorder',
    'can-queues',
    'can-dom-data',
    'can-child-nodes',
    'can-string',
    'can-dom-events',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-symbol',
    'can-globals/document/document',
    './control/control',
    'can-view-model',
    'can-define/list/list'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Bind = require('can-bind');
        var Construct = require('can-construct');
        var stache = require('can-stache');
        var stacheBindings = require('can-stache-bindings');
        var Scope = require('can-view-scope');
        var viewCallbacks = require('can-view-callbacks');
        var nodeLists = require('can-view-nodelist');
        var canReflect = require('can-reflect');
        var SimpleObservable = require('can-simple-observable');
        var SimpleMap = require('can-simple-map');
        var DefineMap = require('can-define/map/map');
        var canLog = require('can-log');
        var canDev = require('can-log/dev/dev');
        var assign = require('can-assign');
        var ObservationRecorder = require('can-observation-recorder');
        var queues = require('can-queues');
        var domData = require('can-dom-data');
        var getChildNodes = require('can-child-nodes');
        var string = require('can-string');
        var domEvents = require('can-dom-events');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var canSymbol = require('can-symbol');
        var DOCUMENT = require('can-globals/document/document');
        var ComponentControl = require('./control/control');
        require('can-view-model');
        require('can-define/list/list');
        stache.addBindings(stacheBindings);
        var createdByCanComponentSymbol = canSymbol('can.createdByCanComponent');
        var getValueSymbol = canSymbol.for('can.getValue');
        var setValueSymbol = canSymbol.for('can.setValue');
        var viewInsertSymbol = canSymbol.for('can.viewInsert');
        var viewModelSymbol = canSymbol.for('can.viewModel');
        var noop = function () {
        };
        function addContext(el, tagData, insertionElementTagData) {
            var vm, newScope;
            domData.set(el, 'preventDataBindings', true);
            var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function createViewModel(initialData, hasDataBinding, bindingState) {
                if (bindingState && bindingState.isSettingOnViewModel === true) {
                    newScope = tagData.scope.addLetContext(initialData);
                    return newScope._context;
                } else {
                    return vm = new SimpleObservable(initialData);
                }
            }, undefined, true);
            if (!teardown) {
                return tagData;
            } else {
                return assign(assign({}, tagData), {
                    teardown: teardown,
                    scope: newScope || tagData.scope.add(vm)
                });
            }
        }
        function makeReplacementTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {
            var options = shadowTagData.options;
            return function replacementTag(el, insertionElementTagData) {
                var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate, renderingLightContent = template !== insertionElementTagData.subtemplate;
                if (template) {
                    delete options.tags[tagName];
                    var tagData;
                    if (renderingLightContent) {
                        if (leakScope.toLightContent) {
                            tagData = addContext(el, {
                                scope: insertionElementTagData.scope.cloneFromRef(),
                                options: insertionElementTagData.options
                            }, insertionElementTagData);
                        } else {
                            tagData = addContext(el, componentTagData, insertionElementTagData);
                        }
                    } else {
                        tagData = addContext(el, insertionElementTagData, insertionElementTagData);
                    }
                    var nodeList = nodeLists.register([el], tagData.teardown || noop, insertionElementTagData.parentNodeList || true, insertionElementTagData.directlyNested);
                    nodeList.expression = '<can-slot name=\'' + el.getAttribute('name') + '\'/>';
                    var frag = template(tagData.scope, tagData.options, nodeList);
                    var newNodes = canReflect.toArray(getChildNodes(frag));
                    var oldNodes = nodeLists.update(nodeList, newNodes);
                    nodeLists.replace(oldNodes, frag);
                    options.tags[tagName] = replacementTag;
                }
            };
        }
        function getSetupFunctionForComponentVM(componentInitVM) {
            return ObservationRecorder.ignore(function (el, componentTagData, makeViewModel, initialVMData) {
                var bindingContext = {
                    element: el,
                    scope: componentTagData.scope,
                    parentNodeList: componentTagData.parentNodeList,
                    viewModel: undefined
                };
                var bindingSettings = {};
                var bindings = [];
                canReflect.eachKey(componentInitVM, function (parent, propName) {
                    var canGetParentValue = parent != null && !!parent[getValueSymbol];
                    var canSetParentValue = parent != null && !!parent[setValueSymbol];
                    if (canGetParentValue === true || canSetParentValue) {
                        var child = stacheBindings.getObservableFrom.viewModel({ name: propName }, bindingContext, bindingSettings);
                        var canBinding = new Bind({
                            child: child,
                            parent: parent,
                            queue: 'domUI'
                        });
                        bindings.push({
                            binding: canBinding,
                            siblingBindingData: {
                                parent: {
                                    source: 'scope',
                                    exports: canGetParentValue
                                },
                                child: {
                                    source: 'viewModel',
                                    exports: canSetParentValue,
                                    name: propName
                                }
                            }
                        });
                    } else {
                        initialVMData[propName] = parent;
                    }
                });
                var initializeData = stacheBindings.behaviors.initializeViewModel(bindings, initialVMData, function (properties) {
                    return bindingContext.viewModel = makeViewModel(properties);
                }, bindingContext);
                return function () {
                    for (var attrName in initializeData.onTeardowns) {
                        initializeData.onTeardowns[attrName]();
                    }
                };
            });
        }
        var Component = Construct.extend({
            setup: function () {
                Construct.setup.apply(this, arguments);
                if (Component) {
                    var self = this;
                    if (this.prototype.events !== undefined && canReflect.size(this.prototype.events) !== 0) {
                        this.Control = ComponentControl.extend(this.prototype.events);
                    }
                    var protoViewModel = this.prototype.viewModel || this.prototype.scope;
                    if (protoViewModel && this.prototype.ViewModel) {
                        throw new Error('Cannot provide both a ViewModel and a viewModel property');
                    }
                    var vmName = string.capitalize(string.camelize(this.prototype.tag)) + 'VM';
                    if (this.prototype.ViewModel) {
                        if (typeof this.prototype.ViewModel === 'function') {
                            this.ViewModel = this.prototype.ViewModel;
                        } else {
                            this.ViewModel = DefineMap.extend(vmName, {}, this.prototype.ViewModel);
                        }
                    } else {
                        if (protoViewModel) {
                            if (typeof protoViewModel === 'function') {
                                if (canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {
                                    this.ViewModel = protoViewModel;
                                } else {
                                    this.viewModelHandler = protoViewModel;
                                }
                            } else {
                                if (canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {
                                    this.viewModelInstance = protoViewModel;
                                } else {
                                    canLog.warn('can-component: ' + this.prototype.tag + ' is extending the viewModel into a can-simple-map');
                                    this.ViewModel = SimpleMap.extend(vmName, {}, protoViewModel);
                                }
                            }
                        } else {
                            this.ViewModel = SimpleMap.extend(vmName, {}, {});
                        }
                    }
                    if (this.prototype.template) {
                        this.view = this.prototype.template;
                    }
                    if (this.prototype.view) {
                        this.view = this.prototype.view;
                    }
                    if (typeof this.view === 'string') {
                        var viewName = string.capitalize(string.camelize(this.prototype.tag)) + 'View';
                        this.view = stache(viewName, this.view);
                    }
                    this.renderer = this.view;
                    var renderComponent = function (el, tagData) {
                        if (el[createdByCanComponentSymbol] === undefined) {
                            new self(el, tagData);
                        }
                    };
                    viewCallbacks.tag(this.prototype.tag, renderComponent);
                }
            }
        }, {
            setup: function (el, componentTagData) {
                this._initialArgs = [
                    el,
                    componentTagData
                ];
                var component = this;
                var options = {
                    helpers: {},
                    tags: {}
                };
                if (componentTagData === undefined) {
                    if (el === undefined) {
                        componentTagData = {};
                    } else {
                        componentTagData = el;
                        el = undefined;
                    }
                }
                if (el === undefined) {
                    el = DOCUMENT().createElement(this.tag);
                    el[createdByCanComponentSymbol] = true;
                }
                this.element = el;
                if (componentTagData.initializeBindings === false && !this._skippedSetup) {
                    this._skippedSetup = this._torndown = true;
                    this.viewModel = Object.create(null);
                    return;
                }
                var componentContent = componentTagData.content;
                if (componentContent !== undefined) {
                    if (typeof componentContent === 'function') {
                        componentTagData.subtemplate = componentContent;
                    } else if (typeof componentContent === 'string') {
                        componentTagData.subtemplate = stache(componentContent);
                    }
                }
                var componentScope = componentTagData.scope;
                if (componentScope !== undefined && componentScope instanceof Scope === false) {
                    componentTagData.scope = new Scope(componentScope);
                }
                var componentTemplates = componentTagData.templates;
                if (componentTemplates !== undefined) {
                    canReflect.eachKey(componentTemplates, function (template, name) {
                        if (typeof template === 'string') {
                            var debugName = name + ' template';
                            componentTemplates[name] = stache(debugName, template);
                        }
                    });
                }
                var viewModel;
                var initialViewModelData = {};
                var preventDataBindings = domData.get(el, 'preventDataBindings');
                var teardownBindings;
                if (preventDataBindings) {
                    viewModel = el[viewModelSymbol];
                } else {
                    var setupFn;
                    if (componentTagData.setupBindings) {
                        setupFn = function (el, componentTagData, callback, initialViewModelData) {
                            return componentTagData.setupBindings(el, callback, initialViewModelData);
                        };
                    } else if (componentTagData.viewModel) {
                        setupFn = getSetupFunctionForComponentVM(componentTagData.viewModel);
                    } else {
                        setupFn = stacheBindings.behaviors.viewModel;
                    }
                    teardownBindings = setupFn(el, componentTagData, function (initialViewModelData) {
                        var ViewModel = component.constructor.ViewModel, viewModelHandler = component.constructor.viewModelHandler, viewModelInstance = component.constructor.viewModelInstance;
                        if (viewModelHandler) {
                            var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
                            if (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult)) {
                                viewModelInstance = scopeResult;
                            } else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {
                                ViewModel = scopeResult;
                            } else {
                                ViewModel = SimpleMap.extend(scopeResult);
                            }
                        }
                        if (ViewModel) {
                            viewModelInstance = new ViewModel(initialViewModelData);
                        }
                        viewModel = viewModelInstance;
                        return viewModelInstance;
                    }, initialViewModelData);
                }
                this.viewModel = viewModel;
                el[viewModelSymbol] = viewModel;
                el.viewModel = viewModel;
                domData.set(el, 'preventDataBindings', true);
                var teardownFunctions = [];
                var callTeardownFunctions = function () {
                    for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                        teardownFunctions[i]();
                    }
                };
                if (this.helpers !== undefined) {
                    canReflect.eachKey(this.helpers, function (val, prop) {
                        if (typeof val === 'function') {
                            options.helpers[prop] = val.bind(viewModel);
                        }
                    });
                }
                if (this.constructor.Control) {
                    this._control = new this.constructor.Control(el, {
                        scope: this.viewModel,
                        viewModel: this.viewModel,
                        destroy: callTeardownFunctions
                    });
                } else {
                    var removalDisposal = domMutate.onNodeRemoval(el, function () {
                        var doc = el.ownerDocument;
                        var rootNode = doc.contains ? doc : doc.documentElement;
                        if (!rootNode || !rootNode.contains(el)) {
                            if (removalDisposal) {
                                nodeRemoved = true;
                                removalDisposal();
                                callTeardownFunctions();
                                removalDisposal = null;
                                callTeardownFunctions = null;
                            }
                        }
                    });
                }
                var leakScope = {
                    toLightContent: this.leakScope === true,
                    intoShadowContent: this.leakScope === true
                };
                var hasShadowView = !!this.constructor.view;
                var shadowFragment;
                var betweenTagsView;
                var betweenTagsTagData;
                if (hasShadowView) {
                    var shadowTagData;
                    if (leakScope.intoShadowContent) {
                        shadowTagData = {
                            scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
                            options: options
                        };
                    } else {
                        shadowTagData = {
                            scope: new Scope(this.viewModel, null, { viewModel: true }),
                            options: options
                        };
                    }
                    options.tags['can-slot'] = makeReplacementTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function (el) {
                        var templates = componentTagData.templates;
                        if (templates) {
                            return templates[el.getAttribute('name')];
                        }
                    });
                    options.tags.content = makeReplacementTagCallback('content', componentTagData, shadowTagData, leakScope, function () {
                        return componentTagData.subtemplate;
                    });
                    betweenTagsView = this.constructor.view;
                    betweenTagsTagData = shadowTagData;
                } else {
                    var lightTemplateTagData = {
                        scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
                        options: options
                    };
                    betweenTagsTagData = lightTemplateTagData;
                    betweenTagsView = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
                }
                var viewModelDisconnectedCallback, insertionDisposal, componentInPage, nodeRemoved;
                var nodeList = nodeLists.register([], function () {
                    if (removalDisposal && !nodeRemoved) {
                        removalDisposal();
                        callTeardownFunctions();
                        removalDisposal = null;
                        callTeardownFunctions = null;
                    }
                    component._torndown = true;
                    domEvents.dispatch(el, 'beforeremove', false);
                    if (teardownBindings) {
                        teardownBindings();
                    }
                    if (viewModelDisconnectedCallback) {
                        viewModelDisconnectedCallback(el);
                    } else if (typeof viewModel.stopListening === 'function') {
                        viewModel.stopListening();
                    }
                    if (insertionDisposal) {
                        insertionDisposal();
                        insertionDisposal = null;
                    }
                }, componentTagData.parentNodeList || true, false);
                nodeList.expression = '<' + this.tag + '>';
                teardownFunctions.push(function () {
                    nodeLists.unregister(nodeList);
                });
                this.nodeList = nodeList;
                shadowFragment = betweenTagsView(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);
                domMutateNode.appendChild.call(el, shadowFragment);
                nodeLists.update(nodeList, getChildNodes(el));
                if (viewModel && viewModel.connectedCallback) {
                    var body = DOCUMENT().body;
                    componentInPage = body && body.contains(el);
                    if (componentInPage) {
                        viewModelDisconnectedCallback = viewModel.connectedCallback(el);
                    } else {
                        insertionDisposal = domMutate.onNodeInsertion(el, function () {
                            insertionDisposal();
                            insertionDisposal = null;
                            viewModelDisconnectedCallback = viewModel.connectedCallback(el);
                        });
                    }
                }
                component._torndown = false;
            }
        });
        Component.prototype[viewInsertSymbol] = function (viewData) {
            if (this._torndown) {
                this.setup.apply(this, this._initialArgs);
            }
            viewData.nodeList.newDeepChildren.push(this.nodeList);
            return this.element;
        };
        module.exports = namespace.Component = Component;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*bitovians-pto@1.0.0#models/api-info*/
define('bitovians-pto@1.0.0#models/api-info', [
    'exports',
    'can-define@2.8.0#map/map',
    'can@5.33.3#enable-can-debug',
    'can-component@4.6.2#can-component'
], function (exports, _map) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var STORAGE_PROP = 'bitovians/api/token';
    var APIInfo = _map2.default.extend('APIInfo', {
        get isValid() {
            return this.isValidToken(this.token) && this.url ? this.url.includes('freshbooks') || this.url.includes('billingarm') : false;
        },
        token: {
            default: function _default() {
                return window.localStorage.getItem(STORAGE_PROP);
            },
            set: function set(token) {
                if (token) {
                    window.localStorage.setItem(STORAGE_PROP, token);
                    return token;
                }
                window.localStorage.removeItem(STORAGE_PROP);
            }
        },
        url: { default: 'https://bitovi.freshbooks.com/api/2.1/xml-in' },
        isValidToken: function isValidToken(token) {
            var TOKEN_VALIDATE = /\b[0-9a-f]{5,40}\b/;
            return token && TOKEN_VALIDATE.test(token);
        }
    });
    exports.default = APIInfo;
});
/*xml-js@1.6.11#dist/xml-js*/
define('xml-js@1.6.11#dist/xml-js', [
    'module',
    '@loader',
    'require'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: []
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __webpack_require__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__webpack_require__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__webpack_require__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, {\r\n/******/ \t\t\t\tconfigurable: false,\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tget: getter\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__webpack_require__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__webpack_require__.p = "";\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// a duplex stream is just a stream that is both readable and writable.\r\n// Since JS doesn\'t have multiple prototypal inheritance, this class\r\n// prototypally inherits from Readable, and then parasitically from\r\n// Writable.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar processNextTick = __webpack_require__(6);\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar objectKeys = Object.keys || function (obj) {\r\n  var keys = [];\r\n  for (var key in obj) {\r\n    keys.push(key);\r\n  }return keys;\r\n};\r\n/*</replacement>*/\r\n\r\nmodule.exports = Duplex;\r\n\r\n/*<replacement>*/\r\nvar util = __webpack_require__(3);\r\nutil.inherits = __webpack_require__(1);\r\n/*</replacement>*/\r\n\r\nvar Readable = __webpack_require__(16);\r\nvar Writable = __webpack_require__(10);\r\n\r\nutil.inherits(Duplex, Readable);\r\n\r\nvar keys = objectKeys(Writable.prototype);\r\nfor (var v = 0; v < keys.length; v++) {\r\n  var method = keys[v];\r\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\r\n}\r\n\r\nfunction Duplex(options) {\r\n  if (!(this instanceof Duplex)) return new Duplex(options);\r\n\r\n  Readable.call(this, options);\r\n  Writable.call(this, options);\r\n\r\n  if (options && options.readable === false) this.readable = false;\r\n\r\n  if (options && options.writable === false) this.writable = false;\r\n\r\n  this.allowHalfOpen = true;\r\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\r\n\r\n  this.once(\'end\', onend);\r\n}\r\n\r\n// the no-half-open enforcer\r\nfunction onend() {\r\n  // if we allow half-open state, or if the writable side ended,\r\n  // then we\'re ok.\r\n  if (this.allowHalfOpen || this._writableState.ended) return;\r\n\r\n  // no more data can be written.\r\n  // But allow more writes to happen in this tick.\r\n  processNextTick(onEndNT, this);\r\n}\r\n\r\nfunction onEndNT(self) {\r\n  self.end();\r\n}\r\n\r\nObject.defineProperty(Duplex.prototype, \'destroyed\', {\r\n  get: function () {\r\n    if (this._readableState === undefined || this._writableState === undefined) {\r\n      return false;\r\n    }\r\n    return this._readableState.destroyed && this._writableState.destroyed;\r\n  },\r\n  set: function (value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (this._readableState === undefined || this._writableState === undefined) {\r\n      return;\r\n    }\r\n\r\n    // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n    this._readableState.destroyed = value;\r\n    this._writableState.destroyed = value;\r\n  }\r\n});\r\n\r\nDuplex.prototype._destroy = function (err, cb) {\r\n  this.push(null);\r\n  this.end();\r\n\r\n  processNextTick(cb, err);\r\n};\r\n\r\nfunction forEach(xs, f) {\r\n  for (var i = 0, l = xs.length; i < l; i++) {\r\n    f(xs[i], i);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports) {\r\n\r\nif (typeof Object.create === \'function\') {\r\n  // implementation from standard node.js \'util\' module\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    ctor.super_ = superCtor\r\n    ctor.prototype = Object.create(superCtor.prototype, {\r\n      constructor: {\r\n        value: ctor,\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n  };\r\n} else {\r\n  // old school shim for old browsers\r\n  module.exports = function inherits(ctor, superCtor) {\r\n    ctor.super_ = superCtor\r\n    var TempCtor = function () {}\r\n    TempCtor.prototype = superCtor.prototype\r\n    ctor.prototype = new TempCtor()\r\n    ctor.prototype.constructor = ctor\r\n  }\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports) {\r\n\r\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// NOTE: These type checking functions intentionally don\'t use `instanceof`\r\n// because it is fragile and can be easily faked with `Object.create()`.\r\n\r\nfunction isArray(arg) {\r\n  if (Array.isArray) {\r\n    return Array.isArray(arg);\r\n  }\r\n  return objectToString(arg) === \'[object Array]\';\r\n}\r\nexports.isArray = isArray;\r\n\r\nfunction isBoolean(arg) {\r\n  return typeof arg === \'boolean\';\r\n}\r\nexports.isBoolean = isBoolean;\r\n\r\nfunction isNull(arg) {\r\n  return arg === null;\r\n}\r\nexports.isNull = isNull;\r\n\r\nfunction isNullOrUndefined(arg) {\r\n  return arg == null;\r\n}\r\nexports.isNullOrUndefined = isNullOrUndefined;\r\n\r\nfunction isNumber(arg) {\r\n  return typeof arg === \'number\';\r\n}\r\nexports.isNumber = isNumber;\r\n\r\nfunction isString(arg) {\r\n  return typeof arg === \'string\';\r\n}\r\nexports.isString = isString;\r\n\r\nfunction isSymbol(arg) {\r\n  return typeof arg === \'symbol\';\r\n}\r\nexports.isSymbol = isSymbol;\r\n\r\nfunction isUndefined(arg) {\r\n  return arg === void 0;\r\n}\r\nexports.isUndefined = isUndefined;\r\n\r\nfunction isRegExp(re) {\r\n  return objectToString(re) === \'[object RegExp]\';\r\n}\r\nexports.isRegExp = isRegExp;\r\n\r\nfunction isObject(arg) {\r\n  return typeof arg === \'object\' && arg !== null;\r\n}\r\nexports.isObject = isObject;\r\n\r\nfunction isDate(d) {\r\n  return objectToString(d) === \'[object Date]\';\r\n}\r\nexports.isDate = isDate;\r\n\r\nfunction isError(e) {\r\n  return (objectToString(e) === \'[object Error]\' || e instanceof Error);\r\n}\r\nexports.isError = isError;\r\n\r\nfunction isFunction(arg) {\r\n  return typeof arg === \'function\';\r\n}\r\nexports.isFunction = isFunction;\r\n\r\nfunction isPrimitive(arg) {\r\n  return arg === null ||\r\n         typeof arg === \'boolean\' ||\r\n         typeof arg === \'number\' ||\r\n         typeof arg === \'string\' ||\r\n         typeof arg === \'symbol\' ||  // ES6 symbol\r\n         typeof arg === \'undefined\';\r\n}\r\nexports.isPrimitive = isPrimitive;\r\n\r\nexports.isBuffer = Buffer.isBuffer;\r\n\r\nfunction objectToString(o) {\r\n  return Object.prototype.toString.call(o);\r\n}\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n/* WEBPACK VAR INJECTION */(function(global) {/*!\r\n * The buffer module from node.js, for the browser.\r\n *\r\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\r\n * @license  MIT\r\n */\r\n/* eslint-disable no-proto */\r\n\r\n\r\n\r\nvar base64 = __webpack_require__(23)\r\nvar ieee754 = __webpack_require__(24)\r\nvar isArray = __webpack_require__(15)\r\n\r\nexports.Buffer = Buffer\r\nexports.SlowBuffer = SlowBuffer\r\nexports.INSPECT_MAX_BYTES = 50\r\n\r\n/**\r\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n *   === true    Use Uint8Array implementation (fastest)\r\n *   === false   Use Object implementation (most compatible, even IE6)\r\n *\r\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n * Opera 11.6+, iOS 4.2+.\r\n *\r\n * Due to various browser bugs, sometimes the Object implementation will be used even\r\n * when the browser supports typed arrays.\r\n *\r\n * Note:\r\n *\r\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\r\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\r\n *\r\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\r\n *\r\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\r\n *     incorrect length in some situations.\r\n\r\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\r\n * get the Object implementation, which is slower but behaves correctly.\r\n */\r\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\r\n  ? global.TYPED_ARRAY_SUPPORT\r\n  : typedArraySupport()\r\n\r\n/*\r\n * Export kMaxLength after typed array support is determined.\r\n */\r\nexports.kMaxLength = kMaxLength()\r\n\r\nfunction typedArraySupport () {\r\n  try {\r\n    var arr = new Uint8Array(1)\r\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n    return arr.foo() === 42 && // typed array instances can be augmented\r\n        typeof arr.subarray === \'function\' && // chrome 9-10 lack `subarray`\r\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction kMaxLength () {\r\n  return Buffer.TYPED_ARRAY_SUPPORT\r\n    ? 0x7fffffff\r\n    : 0x3fffffff\r\n}\r\n\r\nfunction createBuffer (that, length) {\r\n  if (kMaxLength() < length) {\r\n    throw new RangeError(\'Invalid typed array length\')\r\n  }\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = new Uint8Array(length)\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    if (that === null) {\r\n      that = new Buffer(length)\r\n    }\r\n    that.length = length\r\n  }\r\n\r\n  return that\r\n}\r\n\r\n/**\r\n * The Buffer constructor returns instances of `Uint8Array` that have their\r\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n * returns a single octet.\r\n *\r\n * The `Uint8Array` prototype remains unmodified.\r\n */\r\n\r\nfunction Buffer (arg, encodingOrOffset, length) {\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\r\n    return new Buffer(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Common case.\r\n  if (typeof arg === \'number\') {\r\n    if (typeof encodingOrOffset === \'string\') {\r\n      throw new Error(\r\n        \'If encoding is specified then the first argument must be a string\'\r\n      )\r\n    }\r\n    return allocUnsafe(this, arg)\r\n  }\r\n  return from(this, arg, encodingOrOffset, length)\r\n}\r\n\r\nBuffer.poolSize = 8192 // not used by this implementation\r\n\r\n// TODO: Legacy, not needed anymore. Remove in next major version.\r\nBuffer._augment = function (arr) {\r\n  arr.__proto__ = Buffer.prototype\r\n  return arr\r\n}\r\n\r\nfunction from (that, value, encodingOrOffset, length) {\r\n  if (typeof value === \'number\') {\r\n    throw new TypeError(\'"value" argument must not be a number\')\r\n  }\r\n\r\n  if (typeof ArrayBuffer !== \'undefined\' && value instanceof ArrayBuffer) {\r\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\r\n  }\r\n\r\n  if (typeof value === \'string\') {\r\n    return fromString(that, value, encodingOrOffset)\r\n  }\r\n\r\n  return fromObject(that, value)\r\n}\r\n\r\n/**\r\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n * if value is a number.\r\n * Buffer.from(str[, encoding])\r\n * Buffer.from(array)\r\n * Buffer.from(buffer)\r\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n **/\r\nBuffer.from = function (value, encodingOrOffset, length) {\r\n  return from(null, value, encodingOrOffset, length)\r\n}\r\n\r\nif (Buffer.TYPED_ARRAY_SUPPORT) {\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n  if (typeof Symbol !== \'undefined\' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true\r\n    })\r\n  }\r\n}\r\n\r\nfunction assertSize (size) {\r\n  if (typeof size !== \'number\') {\r\n    throw new TypeError(\'"size" argument must be a number\')\r\n  } else if (size < 0) {\r\n    throw new RangeError(\'"size" argument must not be negative\')\r\n  }\r\n}\r\n\r\nfunction alloc (that, size, fill, encoding) {\r\n  assertSize(size)\r\n  if (size <= 0) {\r\n    return createBuffer(that, size)\r\n  }\r\n  if (fill !== undefined) {\r\n    // Only pay attention to encoding if it\'s a string. This\r\n    // prevents accidentally sending in a number that would\r\n    // be interpretted as a start offset.\r\n    return typeof encoding === \'string\'\r\n      ? createBuffer(that, size).fill(fill, encoding)\r\n      : createBuffer(that, size).fill(fill)\r\n  }\r\n  return createBuffer(that, size)\r\n}\r\n\r\n/**\r\n * Creates a new filled Buffer instance.\r\n * alloc(size[, fill[, encoding]])\r\n **/\r\nBuffer.alloc = function (size, fill, encoding) {\r\n  return alloc(null, size, fill, encoding)\r\n}\r\n\r\nfunction allocUnsafe (that, size) {\r\n  assertSize(size)\r\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\r\n    for (var i = 0; i < size; ++i) {\r\n      that[i] = 0\r\n    }\r\n  }\r\n  return that\r\n}\r\n\r\n/**\r\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n * */\r\nBuffer.allocUnsafe = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n/**\r\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n */\r\nBuffer.allocUnsafeSlow = function (size) {\r\n  return allocUnsafe(null, size)\r\n}\r\n\r\nfunction fromString (that, string, encoding) {\r\n  if (typeof encoding !== \'string\' || encoding === \'\') {\r\n    encoding = \'utf8\'\r\n  }\r\n\r\n  if (!Buffer.isEncoding(encoding)) {\r\n    throw new TypeError(\'"encoding" must be a valid string encoding\')\r\n  }\r\n\r\n  var length = byteLength(string, encoding) | 0\r\n  that = createBuffer(that, length)\r\n\r\n  var actual = that.write(string, encoding)\r\n\r\n  if (actual !== length) {\r\n    // Writing a hex string, for example, that contains invalid characters will\r\n    // cause everything after the first invalid character to be ignored. (e.g.\r\n    // \'abxxcd\' will be treated as \'ab\')\r\n    that = that.slice(0, actual)\r\n  }\r\n\r\n  return that\r\n}\r\n\r\nfunction fromArrayLike (that, array) {\r\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n  that = createBuffer(that, length)\r\n  for (var i = 0; i < length; i += 1) {\r\n    that[i] = array[i] & 255\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromArrayBuffer (that, array, byteOffset, length) {\r\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\r\n\r\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n    throw new RangeError(\'\\\'offset\\\' is out of bounds\')\r\n  }\r\n\r\n  if (array.byteLength < byteOffset + (length || 0)) {\r\n    throw new RangeError(\'\\\'length\\\' is out of bounds\')\r\n  }\r\n\r\n  if (byteOffset === undefined && length === undefined) {\r\n    array = new Uint8Array(array)\r\n  } else if (length === undefined) {\r\n    array = new Uint8Array(array, byteOffset)\r\n  } else {\r\n    array = new Uint8Array(array, byteOffset, length)\r\n  }\r\n\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // Return an augmented `Uint8Array` instance, for best performance\r\n    that = array\r\n    that.__proto__ = Buffer.prototype\r\n  } else {\r\n    // Fallback: Return an object instance of the Buffer class\r\n    that = fromArrayLike(that, array)\r\n  }\r\n  return that\r\n}\r\n\r\nfunction fromObject (that, obj) {\r\n  if (Buffer.isBuffer(obj)) {\r\n    var len = checked(obj.length) | 0\r\n    that = createBuffer(that, len)\r\n\r\n    if (that.length === 0) {\r\n      return that\r\n    }\r\n\r\n    obj.copy(that, 0, 0, len)\r\n    return that\r\n  }\r\n\r\n  if (obj) {\r\n    if ((typeof ArrayBuffer !== \'undefined\' &&\r\n        obj.buffer instanceof ArrayBuffer) || \'length\' in obj) {\r\n      if (typeof obj.length !== \'number\' || isnan(obj.length)) {\r\n        return createBuffer(that, 0)\r\n      }\r\n      return fromArrayLike(that, obj)\r\n    }\r\n\r\n    if (obj.type === \'Buffer\' && isArray(obj.data)) {\r\n      return fromArrayLike(that, obj.data)\r\n    }\r\n  }\r\n\r\n  throw new TypeError(\'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\')\r\n}\r\n\r\nfunction checked (length) {\r\n  // Note: cannot use `length < kMaxLength()` here because that fails when\r\n  // length is NaN (which is otherwise coerced to zero.)\r\n  if (length >= kMaxLength()) {\r\n    throw new RangeError(\'Attempt to allocate Buffer larger than maximum \' +\r\n                         \'size: 0x\' + kMaxLength().toString(16) + \' bytes\')\r\n  }\r\n  return length | 0\r\n}\r\n\r\nfunction SlowBuffer (length) {\r\n  if (+length != length) { // eslint-disable-line eqeqeq\r\n    length = 0\r\n  }\r\n  return Buffer.alloc(+length)\r\n}\r\n\r\nBuffer.isBuffer = function isBuffer (b) {\r\n  return !!(b != null && b._isBuffer)\r\n}\r\n\r\nBuffer.compare = function compare (a, b) {\r\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n    throw new TypeError(\'Arguments must be Buffers\')\r\n  }\r\n\r\n  if (a === b) return 0\r\n\r\n  var x = a.length\r\n  var y = b.length\r\n\r\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n    if (a[i] !== b[i]) {\r\n      x = a[i]\r\n      y = b[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\nBuffer.isEncoding = function isEncoding (encoding) {\r\n  switch (String(encoding).toLowerCase()) {\r\n    case \'hex\':\r\n    case \'utf8\':\r\n    case \'utf-8\':\r\n    case \'ascii\':\r\n    case \'latin1\':\r\n    case \'binary\':\r\n    case \'base64\':\r\n    case \'ucs2\':\r\n    case \'ucs-2\':\r\n    case \'utf16le\':\r\n    case \'utf-16le\':\r\n      return true\r\n    default:\r\n      return false\r\n  }\r\n}\r\n\r\nBuffer.concat = function concat (list, length) {\r\n  if (!isArray(list)) {\r\n    throw new TypeError(\'"list" argument must be an Array of Buffers\')\r\n  }\r\n\r\n  if (list.length === 0) {\r\n    return Buffer.alloc(0)\r\n  }\r\n\r\n  var i\r\n  if (length === undefined) {\r\n    length = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      length += list[i].length\r\n    }\r\n  }\r\n\r\n  var buffer = Buffer.allocUnsafe(length)\r\n  var pos = 0\r\n  for (i = 0; i < list.length; ++i) {\r\n    var buf = list[i]\r\n    if (!Buffer.isBuffer(buf)) {\r\n      throw new TypeError(\'"list" argument must be an Array of Buffers\')\r\n    }\r\n    buf.copy(buffer, pos)\r\n    pos += buf.length\r\n  }\r\n  return buffer\r\n}\r\n\r\nfunction byteLength (string, encoding) {\r\n  if (Buffer.isBuffer(string)) {\r\n    return string.length\r\n  }\r\n  if (typeof ArrayBuffer !== \'undefined\' && typeof ArrayBuffer.isView === \'function\' &&\r\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\r\n    return string.byteLength\r\n  }\r\n  if (typeof string !== \'string\') {\r\n    string = \'\' + string\r\n  }\r\n\r\n  var len = string.length\r\n  if (len === 0) return 0\r\n\r\n  // Use a for loop to avoid recursion\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case \'ascii\':\r\n      case \'latin1\':\r\n      case \'binary\':\r\n        return len\r\n      case \'utf8\':\r\n      case \'utf-8\':\r\n      case undefined:\r\n        return utf8ToBytes(string).length\r\n      case \'ucs2\':\r\n      case \'ucs-2\':\r\n      case \'utf16le\':\r\n      case \'utf-16le\':\r\n        return len * 2\r\n      case \'hex\':\r\n        return len >>> 1\r\n      case \'base64\':\r\n        return base64ToBytes(string).length\r\n      default:\r\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n        encoding = (\'\' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\nBuffer.byteLength = byteLength\r\n\r\nfunction slowToString (encoding, start, end) {\r\n  var loweredCase = false\r\n\r\n  // No need to verify that "this.length <= MAX_UINT32" since it\'s a read-only\r\n  // property of a typed array.\r\n\r\n  // This behaves neither like String nor Uint8Array in that we set start/end\r\n  // to their upper/lower bounds if the value passed is out of range.\r\n  // undefined is handled specially as per ECMA-262 6th Edition,\r\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n  if (start === undefined || start < 0) {\r\n    start = 0\r\n  }\r\n  // Return early if start > this.length. Done here to prevent potential uint32\r\n  // coercion fail below.\r\n  if (start > this.length) {\r\n    return \'\'\r\n  }\r\n\r\n  if (end === undefined || end > this.length) {\r\n    end = this.length\r\n  }\r\n\r\n  if (end <= 0) {\r\n    return \'\'\r\n  }\r\n\r\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n  end >>>= 0\r\n  start >>>= 0\r\n\r\n  if (end <= start) {\r\n    return \'\'\r\n  }\r\n\r\n  if (!encoding) encoding = \'utf8\'\r\n\r\n  while (true) {\r\n    switch (encoding) {\r\n      case \'hex\':\r\n        return hexSlice(this, start, end)\r\n\r\n      case \'utf8\':\r\n      case \'utf-8\':\r\n        return utf8Slice(this, start, end)\r\n\r\n      case \'ascii\':\r\n        return asciiSlice(this, start, end)\r\n\r\n      case \'latin1\':\r\n      case \'binary\':\r\n        return latin1Slice(this, start, end)\r\n\r\n      case \'base64\':\r\n        return base64Slice(this, start, end)\r\n\r\n      case \'ucs2\':\r\n      case \'ucs-2\':\r\n      case \'utf16le\':\r\n      case \'utf-16le\':\r\n        return utf16leSlice(this, start, end)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError(\'Unknown encoding: \' + encoding)\r\n        encoding = (encoding + \'\').toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\r\n// Buffer instances.\r\nBuffer.prototype._isBuffer = true\r\n\r\nfunction swap (b, n, m) {\r\n  var i = b[n]\r\n  b[n] = b[m]\r\n  b[m] = i\r\n}\r\n\r\nBuffer.prototype.swap16 = function swap16 () {\r\n  var len = this.length\r\n  if (len % 2 !== 0) {\r\n    throw new RangeError(\'Buffer size must be a multiple of 16-bits\')\r\n  }\r\n  for (var i = 0; i < len; i += 2) {\r\n    swap(this, i, i + 1)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap32 = function swap32 () {\r\n  var len = this.length\r\n  if (len % 4 !== 0) {\r\n    throw new RangeError(\'Buffer size must be a multiple of 32-bits\')\r\n  }\r\n  for (var i = 0; i < len; i += 4) {\r\n    swap(this, i, i + 3)\r\n    swap(this, i + 1, i + 2)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap64 = function swap64 () {\r\n  var len = this.length\r\n  if (len % 8 !== 0) {\r\n    throw new RangeError(\'Buffer size must be a multiple of 64-bits\')\r\n  }\r\n  for (var i = 0; i < len; i += 8) {\r\n    swap(this, i, i + 7)\r\n    swap(this, i + 1, i + 6)\r\n    swap(this, i + 2, i + 5)\r\n    swap(this, i + 3, i + 4)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.toString = function toString () {\r\n  var length = this.length | 0\r\n  if (length === 0) return \'\'\r\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n  return slowToString.apply(this, arguments)\r\n}\r\n\r\nBuffer.prototype.equals = function equals (b) {\r\n  if (!Buffer.isBuffer(b)) throw new TypeError(\'Argument must be a Buffer\')\r\n  if (this === b) return true\r\n  return Buffer.compare(this, b) === 0\r\n}\r\n\r\nBuffer.prototype.inspect = function inspect () {\r\n  var str = \'\'\r\n  var max = exports.INSPECT_MAX_BYTES\r\n  if (this.length > 0) {\r\n    str = this.toString(\'hex\', 0, max).match(/.{2}/g).join(\' \')\r\n    if (this.length > max) str += \' ... \'\r\n  }\r\n  return \'<Buffer \' + str + \'>\'\r\n}\r\n\r\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n  if (!Buffer.isBuffer(target)) {\r\n    throw new TypeError(\'Argument must be a Buffer\')\r\n  }\r\n\r\n  if (start === undefined) {\r\n    start = 0\r\n  }\r\n  if (end === undefined) {\r\n    end = target ? target.length : 0\r\n  }\r\n  if (thisStart === undefined) {\r\n    thisStart = 0\r\n  }\r\n  if (thisEnd === undefined) {\r\n    thisEnd = this.length\r\n  }\r\n\r\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n    throw new RangeError(\'out of range index\')\r\n  }\r\n\r\n  if (thisStart >= thisEnd && start >= end) {\r\n    return 0\r\n  }\r\n  if (thisStart >= thisEnd) {\r\n    return -1\r\n  }\r\n  if (start >= end) {\r\n    return 1\r\n  }\r\n\r\n  start >>>= 0\r\n  end >>>= 0\r\n  thisStart >>>= 0\r\n  thisEnd >>>= 0\r\n\r\n  if (this === target) return 0\r\n\r\n  var x = thisEnd - thisStart\r\n  var y = end - start\r\n  var len = Math.min(x, y)\r\n\r\n  var thisCopy = this.slice(thisStart, thisEnd)\r\n  var targetCopy = target.slice(start, end)\r\n\r\n  for (var i = 0; i < len; ++i) {\r\n    if (thisCopy[i] !== targetCopy[i]) {\r\n      x = thisCopy[i]\r\n      y = targetCopy[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n//\r\n// Arguments:\r\n// - buffer - a Buffer to search\r\n// - val - a string, Buffer, or number\r\n// - byteOffset - an index into `buffer`; will be clamped to an int32\r\n// - encoding - an optional encoding, relevant is val is a string\r\n// - dir - true for indexOf, false for lastIndexOf\r\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n  // Empty buffer means no match\r\n  if (buffer.length === 0) return -1\r\n\r\n  // Normalize byteOffset\r\n  if (typeof byteOffset === \'string\') {\r\n    encoding = byteOffset\r\n    byteOffset = 0\r\n  } else if (byteOffset > 0x7fffffff) {\r\n    byteOffset = 0x7fffffff\r\n  } else if (byteOffset < -0x80000000) {\r\n    byteOffset = -0x80000000\r\n  }\r\n  byteOffset = +byteOffset  // Coerce to Number.\r\n  if (isNaN(byteOffset)) {\r\n    // byteOffset: it it\'s undefined, null, NaN, "foo", etc, search whole buffer\r\n    byteOffset = dir ? 0 : (buffer.length - 1)\r\n  }\r\n\r\n  // Normalize byteOffset: negative offsets start from the end of the buffer\r\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n  if (byteOffset >= buffer.length) {\r\n    if (dir) return -1\r\n    else byteOffset = buffer.length - 1\r\n  } else if (byteOffset < 0) {\r\n    if (dir) byteOffset = 0\r\n    else return -1\r\n  }\r\n\r\n  // Normalize val\r\n  if (typeof val === \'string\') {\r\n    val = Buffer.from(val, encoding)\r\n  }\r\n\r\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n  if (Buffer.isBuffer(val)) {\r\n    // Special case: looking for empty string/buffer always fails\r\n    if (val.length === 0) {\r\n      return -1\r\n    }\r\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n  } else if (typeof val === \'number\') {\r\n    val = val & 0xFF // Search for a byte value [0-255]\r\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\r\n        typeof Uint8Array.prototype.indexOf === \'function\') {\r\n      if (dir) {\r\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n      } else {\r\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n      }\r\n    }\r\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n  }\r\n\r\n  throw new TypeError(\'val must be string, number or Buffer\')\r\n}\r\n\r\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n  var indexSize = 1\r\n  var arrLength = arr.length\r\n  var valLength = val.length\r\n\r\n  if (encoding !== undefined) {\r\n    encoding = String(encoding).toLowerCase()\r\n    if (encoding === \'ucs2\' || encoding === \'ucs-2\' ||\r\n        encoding === \'utf16le\' || encoding === \'utf-16le\') {\r\n      if (arr.length < 2 || val.length < 2) {\r\n        return -1\r\n      }\r\n      indexSize = 2\r\n      arrLength /= 2\r\n      valLength /= 2\r\n      byteOffset /= 2\r\n    }\r\n  }\r\n\r\n  function read (buf, i) {\r\n    if (indexSize === 1) {\r\n      return buf[i]\r\n    } else {\r\n      return buf.readUInt16BE(i * indexSize)\r\n    }\r\n  }\r\n\r\n  var i\r\n  if (dir) {\r\n    var foundIndex = -1\r\n    for (i = byteOffset; i < arrLength; i++) {\r\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n        if (foundIndex === -1) foundIndex = i\r\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n      } else {\r\n        if (foundIndex !== -1) i -= i - foundIndex\r\n        foundIndex = -1\r\n      }\r\n    }\r\n  } else {\r\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n    for (i = byteOffset; i >= 0; i--) {\r\n      var found = true\r\n      for (var j = 0; j < valLength; j++) {\r\n        if (read(arr, i + j) !== read(val, j)) {\r\n          found = false\r\n          break\r\n        }\r\n      }\r\n      if (found) return i\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n  return this.indexOf(val, byteOffset, encoding) !== -1\r\n}\r\n\r\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n}\r\n\r\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n}\r\n\r\nfunction hexWrite (buf, string, offset, length) {\r\n  offset = Number(offset) || 0\r\n  var remaining = buf.length - offset\r\n  if (!length) {\r\n    length = remaining\r\n  } else {\r\n    length = Number(length)\r\n    if (length > remaining) {\r\n      length = remaining\r\n    }\r\n  }\r\n\r\n  // must be an even number of digits\r\n  var strLen = string.length\r\n  if (strLen % 2 !== 0) throw new TypeError(\'Invalid hex string\')\r\n\r\n  if (length > strLen / 2) {\r\n    length = strLen / 2\r\n  }\r\n  for (var i = 0; i < length; ++i) {\r\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n    if (isNaN(parsed)) return i\r\n    buf[offset + i] = parsed\r\n  }\r\n  return i\r\n}\r\n\r\nfunction utf8Write (buf, string, offset, length) {\r\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nfunction asciiWrite (buf, string, offset, length) {\r\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction latin1Write (buf, string, offset, length) {\r\n  return asciiWrite(buf, string, offset, length)\r\n}\r\n\r\nfunction base64Write (buf, string, offset, length) {\r\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction ucs2Write (buf, string, offset, length) {\r\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nBuffer.prototype.write = function write (string, offset, length, encoding) {\r\n  // Buffer#write(string)\r\n  if (offset === undefined) {\r\n    encoding = \'utf8\'\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, encoding)\r\n  } else if (length === undefined && typeof offset === \'string\') {\r\n    encoding = offset\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, offset[, length][, encoding])\r\n  } else if (isFinite(offset)) {\r\n    offset = offset | 0\r\n    if (isFinite(length)) {\r\n      length = length | 0\r\n      if (encoding === undefined) encoding = \'utf8\'\r\n    } else {\r\n      encoding = length\r\n      length = undefined\r\n    }\r\n  // legacy write(string, encoding, offset, length) - remove in v0.13\r\n  } else {\r\n    throw new Error(\r\n      \'Buffer.write(string, encoding, offset[, length]) is no longer supported\'\r\n    )\r\n  }\r\n\r\n  var remaining = this.length - offset\r\n  if (length === undefined || length > remaining) length = remaining\r\n\r\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n    throw new RangeError(\'Attempt to write outside buffer bounds\')\r\n  }\r\n\r\n  if (!encoding) encoding = \'utf8\'\r\n\r\n  var loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case \'hex\':\r\n        return hexWrite(this, string, offset, length)\r\n\r\n      case \'utf8\':\r\n      case \'utf-8\':\r\n        return utf8Write(this, string, offset, length)\r\n\r\n      case \'ascii\':\r\n        return asciiWrite(this, string, offset, length)\r\n\r\n      case \'latin1\':\r\n      case \'binary\':\r\n        return latin1Write(this, string, offset, length)\r\n\r\n      case \'base64\':\r\n        // Warning: maxLength not taken into account in base64Write\r\n        return base64Write(this, string, offset, length)\r\n\r\n      case \'ucs2\':\r\n      case \'ucs-2\':\r\n      case \'utf16le\':\r\n      case \'utf-16le\':\r\n        return ucs2Write(this, string, offset, length)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError(\'Unknown encoding: \' + encoding)\r\n        encoding = (\'\' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\nBuffer.prototype.toJSON = function toJSON () {\r\n  return {\r\n    type: \'Buffer\',\r\n    data: Array.prototype.slice.call(this._arr || this, 0)\r\n  }\r\n}\r\n\r\nfunction base64Slice (buf, start, end) {\r\n  if (start === 0 && end === buf.length) {\r\n    return base64.fromByteArray(buf)\r\n  } else {\r\n    return base64.fromByteArray(buf.slice(start, end))\r\n  }\r\n}\r\n\r\nfunction utf8Slice (buf, start, end) {\r\n  end = Math.min(buf.length, end)\r\n  var res = []\r\n\r\n  var i = start\r\n  while (i < end) {\r\n    var firstByte = buf[i]\r\n    var codePoint = null\r\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n      : (firstByte > 0xDF) ? 3\r\n      : (firstByte > 0xBF) ? 2\r\n      : 1\r\n\r\n    if (i + bytesPerSequence <= end) {\r\n      var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n      switch (bytesPerSequence) {\r\n        case 1:\r\n          if (firstByte < 0x80) {\r\n            codePoint = firstByte\r\n          }\r\n          break\r\n        case 2:\r\n          secondByte = buf[i + 1]\r\n          if ((secondByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n            if (tempCodePoint > 0x7F) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 3:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 4:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          fourthByte = buf[i + 3]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n      }\r\n    }\r\n\r\n    if (codePoint === null) {\r\n      // we did not generate a valid codePoint so insert a\r\n      // replacement char (U+FFFD) and advance only 1 byte\r\n      codePoint = 0xFFFD\r\n      bytesPerSequence = 1\r\n    } else if (codePoint > 0xFFFF) {\r\n      // encode to utf16 (surrogate pair dance)\r\n      codePoint -= 0x10000\r\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n      codePoint = 0xDC00 | codePoint & 0x3FF\r\n    }\r\n\r\n    res.push(codePoint)\r\n    i += bytesPerSequence\r\n  }\r\n\r\n  return decodeCodePointsArray(res)\r\n}\r\n\r\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n// the lowest limit is Chrome, with 0x10000 args.\r\n// We go 1 magnitude less, for safety\r\nvar MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\nfunction decodeCodePointsArray (codePoints) {\r\n  var len = codePoints.length\r\n  if (len <= MAX_ARGUMENTS_LENGTH) {\r\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n  }\r\n\r\n  // Decode in chunks to avoid "call stack size exceeded".\r\n  var res = \'\'\r\n  var i = 0\r\n  while (i < len) {\r\n    res += String.fromCharCode.apply(\r\n      String,\r\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n    )\r\n  }\r\n  return res\r\n}\r\n\r\nfunction asciiSlice (buf, start, end) {\r\n  var ret = \'\'\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i] & 0x7F)\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction latin1Slice (buf, start, end) {\r\n  var ret = \'\'\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (var i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i])\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction hexSlice (buf, start, end) {\r\n  var len = buf.length\r\n\r\n  if (!start || start < 0) start = 0\r\n  if (!end || end < 0 || end > len) end = len\r\n\r\n  var out = \'\'\r\n  for (var i = start; i < end; ++i) {\r\n    out += toHex(buf[i])\r\n  }\r\n  return out\r\n}\r\n\r\nfunction utf16leSlice (buf, start, end) {\r\n  var bytes = buf.slice(start, end)\r\n  var res = \'\'\r\n  for (var i = 0; i < bytes.length; i += 2) {\r\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\r\n  }\r\n  return res\r\n}\r\n\r\nBuffer.prototype.slice = function slice (start, end) {\r\n  var len = this.length\r\n  start = ~~start\r\n  end = end === undefined ? len : ~~end\r\n\r\n  if (start < 0) {\r\n    start += len\r\n    if (start < 0) start = 0\r\n  } else if (start > len) {\r\n    start = len\r\n  }\r\n\r\n  if (end < 0) {\r\n    end += len\r\n    if (end < 0) end = 0\r\n  } else if (end > len) {\r\n    end = len\r\n  }\r\n\r\n  if (end < start) end = start\r\n\r\n  var newBuf\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    newBuf = this.subarray(start, end)\r\n    newBuf.__proto__ = Buffer.prototype\r\n  } else {\r\n    var sliceLen = end - start\r\n    newBuf = new Buffer(sliceLen, undefined)\r\n    for (var i = 0; i < sliceLen; ++i) {\r\n      newBuf[i] = this[i + start]\r\n    }\r\n  }\r\n\r\n  return newBuf\r\n}\r\n\r\n/*\r\n * Need to make sure that buffer isn\'t trying to write out of bounds.\r\n */\r\nfunction checkOffset (offset, ext, length) {\r\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError(\'offset is not uint\')\r\n  if (offset + ext > length) throw new RangeError(\'Trying to access beyond buffer length\')\r\n}\r\n\r\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    checkOffset(offset, byteLength, this.length)\r\n  }\r\n\r\n  var val = this[offset + --byteLength]\r\n  var mul = 1\r\n  while (byteLength > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --byteLength] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  return this[offset]\r\n}\r\n\r\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return this[offset] | (this[offset + 1] << 8)\r\n}\r\n\r\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return (this[offset] << 8) | this[offset + 1]\r\n}\r\n\r\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return ((this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16)) +\r\n      (this[offset + 3] * 0x1000000)\r\n}\r\n\r\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] * 0x1000000) +\r\n    ((this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var val = this[offset]\r\n  var mul = 1\r\n  var i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  var i = byteLength\r\n  var mul = 1\r\n  var val = this[offset + --i]\r\n  while (i > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  if (!(this[offset] & 0x80)) return (this[offset])\r\n  return ((0xff - this[offset] + 1) * -1)\r\n}\r\n\r\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset] | (this[offset + 1] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  var val = this[offset + 1] | (this[offset] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset]) |\r\n    (this[offset + 1] << 8) |\r\n    (this[offset + 2] << 16) |\r\n    (this[offset + 3] << 24)\r\n}\r\n\r\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] << 24) |\r\n    (this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    (this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, true, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, false, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, true, 52, 8)\r\n}\r\n\r\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, false, 52, 8)\r\n}\r\n\r\nfunction checkInt (buf, value, offset, ext, max, min) {\r\n  if (!Buffer.isBuffer(buf)) throw new TypeError(\'"buffer" argument must be a Buffer instance\')\r\n  if (value > max || value < min) throw new RangeError(\'"value" argument is out of bounds\')\r\n  if (offset + ext > buf.length) throw new RangeError(\'Index out of range\')\r\n}\r\n\r\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var mul = 1\r\n  var i = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  byteLength = byteLength | 0\r\n  if (!noAssert) {\r\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\r\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\r\n      (littleEndian ? i : 1 - i) * 8\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\r\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\r\n  }\r\n}\r\n\r\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = 0\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) {\r\n    var limit = Math.pow(2, 8 * byteLength - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  var i = byteLength - 1\r\n  var mul = 1\r\n  var sub = 0\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\r\n  if (value < 0) value = 0xff + value + 1\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, true)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt16(this, value, offset, false)\r\n  }\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, true)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset | 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n  } else {\r\n    objectWriteUInt32(this, value, offset, false)\r\n  }\r\n  return offset + 4\r\n}\r\n\r\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\r\n  if (offset + ext > buf.length) throw new RangeError(\'Index out of range\')\r\n  if (offset < 0) throw new RangeError(\'Index out of range\')\r\n}\r\n\r\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, false, noAssert)\r\n}\r\n\r\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n  return offset + 8\r\n}\r\n\r\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, false, noAssert)\r\n}\r\n\r\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n  if (!start) start = 0\r\n  if (!end && end !== 0) end = this.length\r\n  if (targetStart >= target.length) targetStart = target.length\r\n  if (!targetStart) targetStart = 0\r\n  if (end > 0 && end < start) end = start\r\n\r\n  // Copy 0 bytes; we\'re done\r\n  if (end === start) return 0\r\n  if (target.length === 0 || this.length === 0) return 0\r\n\r\n  // Fatal error conditions\r\n  if (targetStart < 0) {\r\n    throw new RangeError(\'targetStart out of bounds\')\r\n  }\r\n  if (start < 0 || start >= this.length) throw new RangeError(\'sourceStart out of bounds\')\r\n  if (end < 0) throw new RangeError(\'sourceEnd out of bounds\')\r\n\r\n  // Are we oob?\r\n  if (end > this.length) end = this.length\r\n  if (target.length - targetStart < end - start) {\r\n    end = target.length - targetStart + start\r\n  }\r\n\r\n  var len = end - start\r\n  var i\r\n\r\n  if (this === target && start < targetStart && targetStart < end) {\r\n    // descending copy from end\r\n    for (i = len - 1; i >= 0; --i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\r\n    // ascending copy from start\r\n    for (i = 0; i < len; ++i) {\r\n      target[i + targetStart] = this[i + start]\r\n    }\r\n  } else {\r\n    Uint8Array.prototype.set.call(\r\n      target,\r\n      this.subarray(start, start + len),\r\n      targetStart\r\n    )\r\n  }\r\n\r\n  return len\r\n}\r\n\r\n// Usage:\r\n//    buffer.fill(number[, offset[, end]])\r\n//    buffer.fill(buffer[, offset[, end]])\r\n//    buffer.fill(string[, offset[, end]][, encoding])\r\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\r\n  // Handle string cases:\r\n  if (typeof val === \'string\') {\r\n    if (typeof start === \'string\') {\r\n      encoding = start\r\n      start = 0\r\n      end = this.length\r\n    } else if (typeof end === \'string\') {\r\n      encoding = end\r\n      end = this.length\r\n    }\r\n    if (val.length === 1) {\r\n      var code = val.charCodeAt(0)\r\n      if (code < 256) {\r\n        val = code\r\n      }\r\n    }\r\n    if (encoding !== undefined && typeof encoding !== \'string\') {\r\n      throw new TypeError(\'encoding must be a string\')\r\n    }\r\n    if (typeof encoding === \'string\' && !Buffer.isEncoding(encoding)) {\r\n      throw new TypeError(\'Unknown encoding: \' + encoding)\r\n    }\r\n  } else if (typeof val === \'number\') {\r\n    val = val & 255\r\n  }\r\n\r\n  // Invalid ranges are not set to a default, so can range check early.\r\n  if (start < 0 || this.length < start || this.length < end) {\r\n    throw new RangeError(\'Out of range index\')\r\n  }\r\n\r\n  if (end <= start) {\r\n    return this\r\n  }\r\n\r\n  start = start >>> 0\r\n  end = end === undefined ? this.length : end >>> 0\r\n\r\n  if (!val) val = 0\r\n\r\n  var i\r\n  if (typeof val === \'number\') {\r\n    for (i = start; i < end; ++i) {\r\n      this[i] = val\r\n    }\r\n  } else {\r\n    var bytes = Buffer.isBuffer(val)\r\n      ? val\r\n      : utf8ToBytes(new Buffer(val, encoding).toString())\r\n    var len = bytes.length\r\n    for (i = 0; i < end - start; ++i) {\r\n      this[i + start] = bytes[i % len]\r\n    }\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n// HELPER FUNCTIONS\r\n// ================\r\n\r\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\r\n\r\nfunction base64clean (str) {\r\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n  str = stringtrim(str).replace(INVALID_BASE64_RE, \'\')\r\n  // Node converts strings with length < 2 to \'\'\r\n  if (str.length < 2) return \'\'\r\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n  while (str.length % 4 !== 0) {\r\n    str = str + \'=\'\r\n  }\r\n  return str\r\n}\r\n\r\nfunction stringtrim (str) {\r\n  if (str.trim) return str.trim()\r\n  return str.replace(/^\\s+|\\s+$/g, \'\')\r\n}\r\n\r\nfunction toHex (n) {\r\n  if (n < 16) return \'0\' + n.toString(16)\r\n  return n.toString(16)\r\n}\r\n\r\nfunction utf8ToBytes (string, units) {\r\n  units = units || Infinity\r\n  var codePoint\r\n  var length = string.length\r\n  var leadSurrogate = null\r\n  var bytes = []\r\n\r\n  for (var i = 0; i < length; ++i) {\r\n    codePoint = string.charCodeAt(i)\r\n\r\n    // is surrogate component\r\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n      // last char was a lead\r\n      if (!leadSurrogate) {\r\n        // no lead yet\r\n        if (codePoint > 0xDBFF) {\r\n          // unexpected trail\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        } else if (i + 1 === length) {\r\n          // unpaired lead\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        }\r\n\r\n        // valid lead\r\n        leadSurrogate = codePoint\r\n\r\n        continue\r\n      }\r\n\r\n      // 2 leads in a row\r\n      if (codePoint < 0xDC00) {\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n        leadSurrogate = codePoint\r\n        continue\r\n      }\r\n\r\n      // valid surrogate pair\r\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n    } else if (leadSurrogate) {\r\n      // valid bmp char, but last char was a lead\r\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n    }\r\n\r\n    leadSurrogate = null\r\n\r\n    // encode utf8\r\n    if (codePoint < 0x80) {\r\n      if ((units -= 1) < 0) break\r\n      bytes.push(codePoint)\r\n    } else if (codePoint < 0x800) {\r\n      if ((units -= 2) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x6 | 0xC0,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x10000) {\r\n      if ((units -= 3) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0xC | 0xE0,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x110000) {\r\n      if ((units -= 4) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x12 | 0xF0,\r\n        codePoint >> 0xC & 0x3F | 0x80,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else {\r\n      throw new Error(\'Invalid code point\')\r\n    }\r\n  }\r\n\r\n  return bytes\r\n}\r\n\r\nfunction asciiToBytes (str) {\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Node\'s code seems to be doing this and not & 0x7F..\r\n    byteArray.push(str.charCodeAt(i) & 0xFF)\r\n  }\r\n  return byteArray\r\n}\r\n\r\nfunction utf16leToBytes (str, units) {\r\n  var c, hi, lo\r\n  var byteArray = []\r\n  for (var i = 0; i < str.length; ++i) {\r\n    if ((units -= 2) < 0) break\r\n\r\n    c = str.charCodeAt(i)\r\n    hi = c >> 8\r\n    lo = c % 256\r\n    byteArray.push(lo)\r\n    byteArray.push(hi)\r\n  }\r\n\r\n  return byteArray\r\n}\r\n\r\nfunction base64ToBytes (str) {\r\n  return base64.toByteArray(base64clean(str))\r\n}\r\n\r\nfunction blitBuffer (src, dst, offset, length) {\r\n  for (var i = 0; i < length; ++i) {\r\n    if ((i + offset >= dst.length) || (i >= src.length)) break\r\n    dst[i + offset] = src[i]\r\n  }\r\n  return i\r\n}\r\n\r\nfunction isnan (val) {\r\n  return val !== val // eslint-disable-line no-self-compare\r\n}\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports) {\r\n\r\n// shim for using process in browser\r\nvar process = module.exports = {};\r\n\r\n// cached from whatever global is present so that test runners that stub it\r\n// don\'t break things.  But we need to wrap it in a try catch in case it is\r\n// wrapped in strict mode code which doesn\'t define any globals.  It\'s inside a\r\n// function because try/catches deoptimize in certain engines.\r\n\r\nvar cachedSetTimeout;\r\nvar cachedClearTimeout;\r\n\r\nfunction defaultSetTimout() {\r\n    throw new Error(\'setTimeout has not been defined\');\r\n}\r\nfunction defaultClearTimeout () {\r\n    throw new Error(\'clearTimeout has not been defined\');\r\n}\r\n(function () {\r\n    try {\r\n        if (typeof setTimeout === \'function\') {\r\n            cachedSetTimeout = setTimeout;\r\n        } else {\r\n            cachedSetTimeout = defaultSetTimout;\r\n        }\r\n    } catch (e) {\r\n        cachedSetTimeout = defaultSetTimout;\r\n    }\r\n    try {\r\n        if (typeof clearTimeout === \'function\') {\r\n            cachedClearTimeout = clearTimeout;\r\n        } else {\r\n            cachedClearTimeout = defaultClearTimeout;\r\n        }\r\n    } catch (e) {\r\n        cachedClearTimeout = defaultClearTimeout;\r\n    }\r\n} ())\r\nfunction runTimeout(fun) {\r\n    if (cachedSetTimeout === setTimeout) {\r\n        //normal enviroments in sane situations\r\n        return setTimeout(fun, 0);\r\n    }\r\n    // if setTimeout wasn\'t available but was latter defined\r\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\r\n        cachedSetTimeout = setTimeout;\r\n        return setTimeout(fun, 0);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedSetTimeout(fun, 0);\r\n    } catch(e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn\'t trust the global object when called normally\r\n            return cachedSetTimeout.call(null, fun, 0);\r\n        } catch(e){\r\n            // same as above but when it\'s a version of I.E. that must have the global object for \'this\', hopfully our context correct otherwise it will throw a global error\r\n            return cachedSetTimeout.call(this, fun, 0);\r\n        }\r\n    }\r\n\r\n\r\n}\r\nfunction runClearTimeout(marker) {\r\n    if (cachedClearTimeout === clearTimeout) {\r\n        //normal enviroments in sane situations\r\n        return clearTimeout(marker);\r\n    }\r\n    // if clearTimeout wasn\'t available but was latter defined\r\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\r\n        cachedClearTimeout = clearTimeout;\r\n        return clearTimeout(marker);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedClearTimeout(marker);\r\n    } catch (e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn\'t  trust the global object when called normally\r\n            return cachedClearTimeout.call(null, marker);\r\n        } catch (e){\r\n            // same as above but when it\'s a version of I.E. that must have the global object for \'this\', hopfully our context correct otherwise it will throw a global error.\r\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\r\n            return cachedClearTimeout.call(this, marker);\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\nvar queue = [];\r\nvar draining = false;\r\nvar currentQueue;\r\nvar queueIndex = -1;\r\n\r\nfunction cleanUpNextTick() {\r\n    if (!draining || !currentQueue) {\r\n        return;\r\n    }\r\n    draining = false;\r\n    if (currentQueue.length) {\r\n        queue = currentQueue.concat(queue);\r\n    } else {\r\n        queueIndex = -1;\r\n    }\r\n    if (queue.length) {\r\n        drainQueue();\r\n    }\r\n}\r\n\r\nfunction drainQueue() {\r\n    if (draining) {\r\n        return;\r\n    }\r\n    var timeout = runTimeout(cleanUpNextTick);\r\n    draining = true;\r\n\r\n    var len = queue.length;\r\n    while(len) {\r\n        currentQueue = queue;\r\n        queue = [];\r\n        while (++queueIndex < len) {\r\n            if (currentQueue) {\r\n                currentQueue[queueIndex].run();\r\n            }\r\n        }\r\n        queueIndex = -1;\r\n        len = queue.length;\r\n    }\r\n    currentQueue = null;\r\n    draining = false;\r\n    runClearTimeout(timeout);\r\n}\r\n\r\nprocess.nextTick = function (fun) {\r\n    var args = new Array(arguments.length - 1);\r\n    if (arguments.length > 1) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            args[i - 1] = arguments[i];\r\n        }\r\n    }\r\n    queue.push(new Item(fun, args));\r\n    if (queue.length === 1 && !draining) {\r\n        runTimeout(drainQueue);\r\n    }\r\n};\r\n\r\n// v8 likes predictible objects\r\nfunction Item(fun, array) {\r\n    this.fun = fun;\r\n    this.array = array;\r\n}\r\nItem.prototype.run = function () {\r\n    this.fun.apply(null, this.array);\r\n};\r\nprocess.title = \'browser\';\r\nprocess.browser = true;\r\nprocess.env = {};\r\nprocess.argv = [];\r\nprocess.version = \'\'; // empty string to avoid regexp issues\r\nprocess.versions = {};\r\n\r\nfunction noop() {}\r\n\r\nprocess.on = noop;\r\nprocess.addListener = noop;\r\nprocess.once = noop;\r\nprocess.off = noop;\r\nprocess.removeListener = noop;\r\nprocess.removeAllListeners = noop;\r\nprocess.emit = noop;\r\nprocess.prependListener = noop;\r\nprocess.prependOnceListener = noop;\r\n\r\nprocess.listeners = function (name) { return [] }\r\n\r\nprocess.binding = function (name) {\r\n    throw new Error(\'process.binding is not supported\');\r\n};\r\n\r\nprocess.cwd = function () { return \'/\' };\r\nprocess.chdir = function (dir) {\r\n    throw new Error(\'process.chdir is not supported\');\r\n};\r\nprocess.umask = function() { return 0; };\r\n\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n/* WEBPACK VAR INJECTION */(function(process) {\r\n\r\nif (!process.version ||\r\n    process.version.indexOf(\'v0.\') === 0 ||\r\n    process.version.indexOf(\'v1.\') === 0 && process.version.indexOf(\'v1.8.\') !== 0) {\r\n  module.exports = nextTick;\r\n} else {\r\n  module.exports = process.nextTick;\r\n}\r\n\r\nfunction nextTick(fn, arg1, arg2, arg3) {\r\n  if (typeof fn !== \'function\') {\r\n    throw new TypeError(\'"callback" argument must be a function\');\r\n  }\r\n  var len = arguments.length;\r\n  var args, i;\r\n  switch (len) {\r\n  case 0:\r\n  case 1:\r\n    return process.nextTick(fn);\r\n  case 2:\r\n    return process.nextTick(function afterTickOne() {\r\n      fn.call(null, arg1);\r\n    });\r\n  case 3:\r\n    return process.nextTick(function afterTickTwo() {\r\n      fn.call(null, arg1, arg2);\r\n    });\r\n  case 4:\r\n    return process.nextTick(function afterTickThree() {\r\n      fn.call(null, arg1, arg2, arg3);\r\n    });\r\n  default:\r\n    args = new Array(len - 1);\r\n    i = 0;\r\n    while (i < args.length) {\r\n      args[i++] = arguments[i];\r\n    }\r\n    return process.nextTick(function afterTick() {\r\n      fn.apply(null, args);\r\n    });\r\n  }\r\n}\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/* eslint-disable node/no-deprecated-api */\r\nvar buffer = __webpack_require__(4)\r\nvar Buffer = buffer.Buffer\r\n\r\n// alternative to using Object.keys for old browsers\r\nfunction copyProps (src, dst) {\r\n  for (var key in src) {\r\n    dst[key] = src[key]\r\n  }\r\n}\r\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\r\n  module.exports = buffer\r\n} else {\r\n  // Copy properties from require(\'buffer\')\r\n  copyProps(buffer, exports)\r\n  exports.Buffer = SafeBuffer\r\n}\r\n\r\nfunction SafeBuffer (arg, encodingOrOffset, length) {\r\n  return Buffer(arg, encodingOrOffset, length)\r\n}\r\n\r\n// Copy static methods from Buffer\r\ncopyProps(Buffer, SafeBuffer)\r\n\r\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\r\n  if (typeof arg === \'number\') {\r\n    throw new TypeError(\'Argument must not be a number\')\r\n  }\r\n  return Buffer(arg, encodingOrOffset, length)\r\n}\r\n\r\nSafeBuffer.alloc = function (size, fill, encoding) {\r\n  if (typeof size !== \'number\') {\r\n    throw new TypeError(\'Argument must be a number\')\r\n  }\r\n  var buf = Buffer(size)\r\n  if (fill !== undefined) {\r\n    if (typeof encoding === \'string\') {\r\n      buf.fill(fill, encoding)\r\n    } else {\r\n      buf.fill(fill)\r\n    }\r\n  } else {\r\n    buf.fill(0)\r\n  }\r\n  return buf\r\n}\r\n\r\nSafeBuffer.allocUnsafe = function (size) {\r\n  if (typeof size !== \'number\') {\r\n    throw new TypeError(\'Argument must be a number\')\r\n  }\r\n  return Buffer(size)\r\n}\r\n\r\nSafeBuffer.allocUnsafeSlow = function (size) {\r\n  if (typeof size !== \'number\') {\r\n    throw new TypeError(\'Argument must be a number\')\r\n  }\r\n  return buffer.SlowBuffer(size)\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports) {\r\n\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nfunction EventEmitter() {\r\n  this._events = this._events || {};\r\n  this._maxListeners = this._maxListeners || undefined;\r\n}\r\nmodule.exports = EventEmitter;\r\n\r\n// Backwards-compat with node 0.10.x\r\nEventEmitter.EventEmitter = EventEmitter;\r\n\r\nEventEmitter.prototype._events = undefined;\r\nEventEmitter.prototype._maxListeners = undefined;\r\n\r\n// By default EventEmitters will print a warning if more than 10 listeners are\r\n// added to it. This is a useful default which helps finding memory leaks.\r\nEventEmitter.defaultMaxListeners = 10;\r\n\r\n// Obviously not all Emitters should be limited to 10. This function allows\r\n// that to be increased. Set to zero for unlimited.\r\nEventEmitter.prototype.setMaxListeners = function(n) {\r\n  if (!isNumber(n) || n < 0 || isNaN(n))\r\n    throw TypeError(\'n must be a positive number\');\r\n  this._maxListeners = n;\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.emit = function(type) {\r\n  var er, handler, len, args, i, listeners;\r\n\r\n  if (!this._events)\r\n    this._events = {};\r\n\r\n  // If there is no \'error\' event listener then throw.\r\n  if (type === \'error\') {\r\n    if (!this._events.error ||\r\n        (isObject(this._events.error) && !this._events.error.length)) {\r\n      er = arguments[1];\r\n      if (er instanceof Error) {\r\n        throw er; // Unhandled \'error\' event\r\n      } else {\r\n        // At least give some kind of context to the user\r\n        var err = new Error(\'Uncaught, unspecified "error" event. (\' + er + \')\');\r\n        err.context = er;\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n\r\n  handler = this._events[type];\r\n\r\n  if (isUndefined(handler))\r\n    return false;\r\n\r\n  if (isFunction(handler)) {\r\n    switch (arguments.length) {\r\n      // fast cases\r\n      case 1:\r\n        handler.call(this);\r\n        break;\r\n      case 2:\r\n        handler.call(this, arguments[1]);\r\n        break;\r\n      case 3:\r\n        handler.call(this, arguments[1], arguments[2]);\r\n        break;\r\n      // slower\r\n      default:\r\n        args = Array.prototype.slice.call(arguments, 1);\r\n        handler.apply(this, args);\r\n    }\r\n  } else if (isObject(handler)) {\r\n    args = Array.prototype.slice.call(arguments, 1);\r\n    listeners = handler.slice();\r\n    len = listeners.length;\r\n    for (i = 0; i < len; i++)\r\n      listeners[i].apply(this, args);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nEventEmitter.prototype.addListener = function(type, listener) {\r\n  var m;\r\n\r\n  if (!isFunction(listener))\r\n    throw TypeError(\'listener must be a function\');\r\n\r\n  if (!this._events)\r\n    this._events = {};\r\n\r\n  // To avoid recursion in the case that type === "newListener"! Before\r\n  // adding it to the listeners, first emit "newListener".\r\n  if (this._events.newListener)\r\n    this.emit(\'newListener\', type,\r\n              isFunction(listener.listener) ?\r\n              listener.listener : listener);\r\n\r\n  if (!this._events[type])\r\n    // Optimize the case of one listener. Don\'t need the extra array object.\r\n    this._events[type] = listener;\r\n  else if (isObject(this._events[type]))\r\n    // If we\'ve already got an array, just append.\r\n    this._events[type].push(listener);\r\n  else\r\n    // Adding the second element, need to change to array.\r\n    this._events[type] = [this._events[type], listener];\r\n\r\n  // Check for listener leak\r\n  if (isObject(this._events[type]) && !this._events[type].warned) {\r\n    if (!isUndefined(this._maxListeners)) {\r\n      m = this._maxListeners;\r\n    } else {\r\n      m = EventEmitter.defaultMaxListeners;\r\n    }\r\n\r\n    if (m && m > 0 && this._events[type].length > m) {\r\n      this._events[type].warned = true;\r\n      console.error(\'(node) warning: possible EventEmitter memory \' +\r\n                    \'leak detected. %d listeners added. \' +\r\n                    \'Use emitter.setMaxListeners() to increase limit.\',\r\n                    this._events[type].length);\r\n      if (typeof console.trace === \'function\') {\r\n        // not supported in IE 10\r\n        console.trace();\r\n      }\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n\r\nEventEmitter.prototype.once = function(type, listener) {\r\n  if (!isFunction(listener))\r\n    throw TypeError(\'listener must be a function\');\r\n\r\n  var fired = false;\r\n\r\n  function g() {\r\n    this.removeListener(type, g);\r\n\r\n    if (!fired) {\r\n      fired = true;\r\n      listener.apply(this, arguments);\r\n    }\r\n  }\r\n\r\n  g.listener = listener;\r\n  this.on(type, g);\r\n\r\n  return this;\r\n};\r\n\r\n// emits a \'removeListener\' event iff the listener was removed\r\nEventEmitter.prototype.removeListener = function(type, listener) {\r\n  var list, position, length, i;\r\n\r\n  if (!isFunction(listener))\r\n    throw TypeError(\'listener must be a function\');\r\n\r\n  if (!this._events || !this._events[type])\r\n    return this;\r\n\r\n  list = this._events[type];\r\n  length = list.length;\r\n  position = -1;\r\n\r\n  if (list === listener ||\r\n      (isFunction(list.listener) && list.listener === listener)) {\r\n    delete this._events[type];\r\n    if (this._events.removeListener)\r\n      this.emit(\'removeListener\', type, listener);\r\n\r\n  } else if (isObject(list)) {\r\n    for (i = length; i-- > 0;) {\r\n      if (list[i] === listener ||\r\n          (list[i].listener && list[i].listener === listener)) {\r\n        position = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (position < 0)\r\n      return this;\r\n\r\n    if (list.length === 1) {\r\n      list.length = 0;\r\n      delete this._events[type];\r\n    } else {\r\n      list.splice(position, 1);\r\n    }\r\n\r\n    if (this._events.removeListener)\r\n      this.emit(\'removeListener\', type, listener);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.removeAllListeners = function(type) {\r\n  var key, listeners;\r\n\r\n  if (!this._events)\r\n    return this;\r\n\r\n  // not listening for removeListener, no need to emit\r\n  if (!this._events.removeListener) {\r\n    if (arguments.length === 0)\r\n      this._events = {};\r\n    else if (this._events[type])\r\n      delete this._events[type];\r\n    return this;\r\n  }\r\n\r\n  // emit removeListener for all listeners on all events\r\n  if (arguments.length === 0) {\r\n    for (key in this._events) {\r\n      if (key === \'removeListener\') continue;\r\n      this.removeAllListeners(key);\r\n    }\r\n    this.removeAllListeners(\'removeListener\');\r\n    this._events = {};\r\n    return this;\r\n  }\r\n\r\n  listeners = this._events[type];\r\n\r\n  if (isFunction(listeners)) {\r\n    this.removeListener(type, listeners);\r\n  } else if (listeners) {\r\n    // LIFO order\r\n    while (listeners.length)\r\n      this.removeListener(type, listeners[listeners.length - 1]);\r\n  }\r\n  delete this._events[type];\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.listeners = function(type) {\r\n  var ret;\r\n  if (!this._events || !this._events[type])\r\n    ret = [];\r\n  else if (isFunction(this._events[type]))\r\n    ret = [this._events[type]];\r\n  else\r\n    ret = this._events[type].slice();\r\n  return ret;\r\n};\r\n\r\nEventEmitter.prototype.listenerCount = function(type) {\r\n  if (this._events) {\r\n    var evlistener = this._events[type];\r\n\r\n    if (isFunction(evlistener))\r\n      return 1;\r\n    else if (evlistener)\r\n      return evlistener.length;\r\n  }\r\n  return 0;\r\n};\r\n\r\nEventEmitter.listenerCount = function(emitter, type) {\r\n  return emitter.listenerCount(type);\r\n};\r\n\r\nfunction isFunction(arg) {\r\n  return typeof arg === \'function\';\r\n}\r\n\r\nfunction isNumber(arg) {\r\n  return typeof arg === \'number\';\r\n}\r\n\r\nfunction isObject(arg) {\r\n  return typeof arg === \'object\' && arg !== null;\r\n}\r\n\r\nfunction isUndefined(arg) {\r\n  return arg === void 0;\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nexports = module.exports = __webpack_require__(16);\r\nexports.Stream = exports;\r\nexports.Readable = exports;\r\nexports.Writable = __webpack_require__(10);\r\nexports.Duplex = __webpack_require__(0);\r\nexports.Transform = __webpack_require__(19);\r\nexports.PassThrough = __webpack_require__(31);\r\n\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// A bit simpler than readable streams.\r\n// Implement an async ._write(chunk, encoding, cb), and it\'ll handle all\r\n// the drain event emission and buffering.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar processNextTick = __webpack_require__(6);\r\n/*</replacement>*/\r\n\r\nmodule.exports = Writable;\r\n\r\n/* <replacement> */\r\nfunction WriteReq(chunk, encoding, cb) {\r\n  this.chunk = chunk;\r\n  this.encoding = encoding;\r\n  this.callback = cb;\r\n  this.next = null;\r\n}\r\n\r\n// It seems a linked list but it is not\r\n// there will be only 2 of these for each stream\r\nfunction CorkedRequest(state) {\r\n  var _this = this;\r\n\r\n  this.next = null;\r\n  this.entry = null;\r\n  this.finish = function () {\r\n    onCorkedFinish(_this, state);\r\n  };\r\n}\r\n/* </replacement> */\r\n\r\n/*<replacement>*/\r\nvar asyncWrite = !process.browser && [\'v0.10\', \'v0.9.\'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Duplex;\r\n/*</replacement>*/\r\n\r\nWritable.WritableState = WritableState;\r\n\r\n/*<replacement>*/\r\nvar util = __webpack_require__(3);\r\nutil.inherits = __webpack_require__(1);\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar internalUtil = {\r\n  deprecate: __webpack_require__(30)\r\n};\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Stream = __webpack_require__(17);\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Buffer = __webpack_require__(7).Buffer;\r\nvar OurUint8Array = global.Uint8Array || function () {};\r\nfunction _uint8ArrayToBuffer(chunk) {\r\n  return Buffer.from(chunk);\r\n}\r\nfunction _isUint8Array(obj) {\r\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n}\r\n/*</replacement>*/\r\n\r\nvar destroyImpl = __webpack_require__(18);\r\n\r\nutil.inherits(Writable, Stream);\r\n\r\nfunction nop() {}\r\n\r\nfunction WritableState(options, stream) {\r\n  Duplex = Duplex || __webpack_require__(0);\r\n\r\n  options = options || {};\r\n\r\n  // object stream flag to indicate whether or not this stream\r\n  // contains buffers or objects.\r\n  this.objectMode = !!options.objectMode;\r\n\r\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\r\n\r\n  // the point at which write() starts returning false\r\n  // Note: 0 is a valid value, means that we always return false if\r\n  // the entire buffer is not flushed immediately on write()\r\n  var hwm = options.highWaterMark;\r\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\r\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\r\n\r\n  // cast to ints.\r\n  this.highWaterMark = Math.floor(this.highWaterMark);\r\n\r\n  // if _final has been called\r\n  this.finalCalled = false;\r\n\r\n  // drain event flag.\r\n  this.needDrain = false;\r\n  // at the start of calling end()\r\n  this.ending = false;\r\n  // when end() has been called, and returned\r\n  this.ended = false;\r\n  // when \'finish\' is emitted\r\n  this.finished = false;\r\n\r\n  // has it been destroyed\r\n  this.destroyed = false;\r\n\r\n  // should we decode strings into buffers before passing to _write?\r\n  // this is here so that some node-core streams can optimize string\r\n  // handling at a lower level.\r\n  var noDecode = options.decodeStrings === false;\r\n  this.decodeStrings = !noDecode;\r\n\r\n  // Crypto is kind of old and crusty.  Historically, its default string\r\n  // encoding is \'binary\' so we have to make this configurable.\r\n  // Everything else in the universe uses \'utf8\', though.\r\n  this.defaultEncoding = options.defaultEncoding || \'utf8\';\r\n\r\n  // not an actual buffer we keep track of, but a measurement\r\n  // of how much we\'re waiting to get pushed to some underlying\r\n  // socket or file.\r\n  this.length = 0;\r\n\r\n  // a flag to see when we\'re in the middle of a write.\r\n  this.writing = false;\r\n\r\n  // when true all writes will be buffered until .uncork() call\r\n  this.corked = 0;\r\n\r\n  // a flag to be able to tell if the onwrite cb is called immediately,\r\n  // or on a later tick.  We set this to true at first, because any\r\n  // actions that shouldn\'t happen until "later" should generally also\r\n  // not happen before the first write call.\r\n  this.sync = true;\r\n\r\n  // a flag to know if we\'re processing previously buffered items, which\r\n  // may call the _write() callback in the same tick, so that we don\'t\r\n  // end up in an overlapped onwrite situation.\r\n  this.bufferProcessing = false;\r\n\r\n  // the callback that\'s passed to _write(chunk,cb)\r\n  this.onwrite = function (er) {\r\n    onwrite(stream, er);\r\n  };\r\n\r\n  // the callback that the user supplies to write(chunk,encoding,cb)\r\n  this.writecb = null;\r\n\r\n  // the amount that is being written when _write is called.\r\n  this.writelen = 0;\r\n\r\n  this.bufferedRequest = null;\r\n  this.lastBufferedRequest = null;\r\n\r\n  // number of pending user-supplied write callbacks\r\n  // this must be 0 before \'finish\' can be emitted\r\n  this.pendingcb = 0;\r\n\r\n  // emit prefinish if the only thing we\'re waiting for is _write cbs\r\n  // This is relevant for synchronous Transform streams\r\n  this.prefinished = false;\r\n\r\n  // True if the error was already emitted and should not be thrown again\r\n  this.errorEmitted = false;\r\n\r\n  // count buffered requests\r\n  this.bufferedRequestCount = 0;\r\n\r\n  // allocate the first CorkedRequest, there is always\r\n  // one allocated and free to use, and we maintain at most two\r\n  this.corkedRequestsFree = new CorkedRequest(this);\r\n}\r\n\r\nWritableState.prototype.getBuffer = function getBuffer() {\r\n  var current = this.bufferedRequest;\r\n  var out = [];\r\n  while (current) {\r\n    out.push(current);\r\n    current = current.next;\r\n  }\r\n  return out;\r\n};\r\n\r\n(function () {\r\n  try {\r\n    Object.defineProperty(WritableState.prototype, \'buffer\', {\r\n      get: internalUtil.deprecate(function () {\r\n        return this.getBuffer();\r\n      }, \'_writableState.buffer is deprecated. Use _writableState.getBuffer \' + \'instead.\', \'DEP0003\')\r\n    });\r\n  } catch (_) {}\r\n})();\r\n\r\n// Test _writableState for inheritance to account for Duplex streams,\r\n// whose prototype chain only points to Readable.\r\nvar realHasInstance;\r\nif (typeof Symbol === \'function\' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === \'function\') {\r\n  realHasInstance = Function.prototype[Symbol.hasInstance];\r\n  Object.defineProperty(Writable, Symbol.hasInstance, {\r\n    value: function (object) {\r\n      if (realHasInstance.call(this, object)) return true;\r\n\r\n      return object && object._writableState instanceof WritableState;\r\n    }\r\n  });\r\n} else {\r\n  realHasInstance = function (object) {\r\n    return object instanceof this;\r\n  };\r\n}\r\n\r\nfunction Writable(options) {\r\n  Duplex = Duplex || __webpack_require__(0);\r\n\r\n  // Writable ctor is applied to Duplexes, too.\r\n  // `realHasInstance` is necessary because using plain `instanceof`\r\n  // would return false, as no `_writableState` property is attached.\r\n\r\n  // Trying to use the custom `instanceof` for Writable here will also break the\r\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\r\n  // `_writableState` that would lead to infinite recursion.\r\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\r\n    return new Writable(options);\r\n  }\r\n\r\n  this._writableState = new WritableState(options, this);\r\n\r\n  // legacy.\r\n  this.writable = true;\r\n\r\n  if (options) {\r\n    if (typeof options.write === \'function\') this._write = options.write;\r\n\r\n    if (typeof options.writev === \'function\') this._writev = options.writev;\r\n\r\n    if (typeof options.destroy === \'function\') this._destroy = options.destroy;\r\n\r\n    if (typeof options.final === \'function\') this._final = options.final;\r\n  }\r\n\r\n  Stream.call(this);\r\n}\r\n\r\n// Otherwise people can pipe Writable streams, which is just wrong.\r\nWritable.prototype.pipe = function () {\r\n  this.emit(\'error\', new Error(\'Cannot pipe, not readable\'));\r\n};\r\n\r\nfunction writeAfterEnd(stream, cb) {\r\n  var er = new Error(\'write after end\');\r\n  // TODO: defer error events consistently everywhere, not just the cb\r\n  stream.emit(\'error\', er);\r\n  processNextTick(cb, er);\r\n}\r\n\r\n// Checks that a user-supplied chunk is valid, especially for the particular\r\n// mode the stream is in. Currently this means that `null` is never accepted\r\n// and undefined/non-string values are only allowed in object mode.\r\nfunction validChunk(stream, state, chunk, cb) {\r\n  var valid = true;\r\n  var er = false;\r\n\r\n  if (chunk === null) {\r\n    er = new TypeError(\'May not write null values to stream\');\r\n  } else if (typeof chunk !== \'string\' && chunk !== undefined && !state.objectMode) {\r\n    er = new TypeError(\'Invalid non-string/buffer chunk\');\r\n  }\r\n  if (er) {\r\n    stream.emit(\'error\', er);\r\n    processNextTick(cb, er);\r\n    valid = false;\r\n  }\r\n  return valid;\r\n}\r\n\r\nWritable.prototype.write = function (chunk, encoding, cb) {\r\n  var state = this._writableState;\r\n  var ret = false;\r\n  var isBuf = _isUint8Array(chunk) && !state.objectMode;\r\n\r\n  if (isBuf && !Buffer.isBuffer(chunk)) {\r\n    chunk = _uint8ArrayToBuffer(chunk);\r\n  }\r\n\r\n  if (typeof encoding === \'function\') {\r\n    cb = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  if (isBuf) encoding = \'buffer\';else if (!encoding) encoding = state.defaultEncoding;\r\n\r\n  if (typeof cb !== \'function\') cb = nop;\r\n\r\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\r\n    state.pendingcb++;\r\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nWritable.prototype.cork = function () {\r\n  var state = this._writableState;\r\n\r\n  state.corked++;\r\n};\r\n\r\nWritable.prototype.uncork = function () {\r\n  var state = this._writableState;\r\n\r\n  if (state.corked) {\r\n    state.corked--;\r\n\r\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\r\n  }\r\n};\r\n\r\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\r\n  // node::ParseEncoding() requires lower case.\r\n  if (typeof encoding === \'string\') encoding = encoding.toLowerCase();\r\n  if (!([\'hex\', \'utf8\', \'utf-8\', \'ascii\', \'binary\', \'base64\', \'ucs2\', \'ucs-2\', \'utf16le\', \'utf-16le\', \'raw\'].indexOf((encoding + \'\').toLowerCase()) > -1)) throw new TypeError(\'Unknown encoding: \' + encoding);\r\n  this._writableState.defaultEncoding = encoding;\r\n  return this;\r\n};\r\n\r\nfunction decodeChunk(state, chunk, encoding) {\r\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === \'string\') {\r\n    chunk = Buffer.from(chunk, encoding);\r\n  }\r\n  return chunk;\r\n}\r\n\r\n// if we\'re already writing something, then just put this\r\n// in the queue, and wait our turn.  Otherwise, call _write\r\n// If we return false, then we need a drain event, so set that flag.\r\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\r\n  if (!isBuf) {\r\n    var newChunk = decodeChunk(state, chunk, encoding);\r\n    if (chunk !== newChunk) {\r\n      isBuf = true;\r\n      encoding = \'buffer\';\r\n      chunk = newChunk;\r\n    }\r\n  }\r\n  var len = state.objectMode ? 1 : chunk.length;\r\n\r\n  state.length += len;\r\n\r\n  var ret = state.length < state.highWaterMark;\r\n  // we must ensure that previous needDrain will not be reset to false.\r\n  if (!ret) state.needDrain = true;\r\n\r\n  if (state.writing || state.corked) {\r\n    var last = state.lastBufferedRequest;\r\n    state.lastBufferedRequest = {\r\n      chunk: chunk,\r\n      encoding: encoding,\r\n      isBuf: isBuf,\r\n      callback: cb,\r\n      next: null\r\n    };\r\n    if (last) {\r\n      last.next = state.lastBufferedRequest;\r\n    } else {\r\n      state.bufferedRequest = state.lastBufferedRequest;\r\n    }\r\n    state.bufferedRequestCount += 1;\r\n  } else {\r\n    doWrite(stream, state, false, len, chunk, encoding, cb);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\r\n  state.writelen = len;\r\n  state.writecb = cb;\r\n  state.writing = true;\r\n  state.sync = true;\r\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\r\n  state.sync = false;\r\n}\r\n\r\nfunction onwriteError(stream, state, sync, er, cb) {\r\n  --state.pendingcb;\r\n\r\n  if (sync) {\r\n    // defer the callback if we are being called synchronously\r\n    // to avoid piling up things on the stack\r\n    processNextTick(cb, er);\r\n    // this can emit finish, and it will always happen\r\n    // after error\r\n    processNextTick(finishMaybe, stream, state);\r\n    stream._writableState.errorEmitted = true;\r\n    stream.emit(\'error\', er);\r\n  } else {\r\n    // the caller expect this to happen before if\r\n    // it is async\r\n    cb(er);\r\n    stream._writableState.errorEmitted = true;\r\n    stream.emit(\'error\', er);\r\n    // this can emit finish, but finish must\r\n    // always follow error\r\n    finishMaybe(stream, state);\r\n  }\r\n}\r\n\r\nfunction onwriteStateUpdate(state) {\r\n  state.writing = false;\r\n  state.writecb = null;\r\n  state.length -= state.writelen;\r\n  state.writelen = 0;\r\n}\r\n\r\nfunction onwrite(stream, er) {\r\n  var state = stream._writableState;\r\n  var sync = state.sync;\r\n  var cb = state.writecb;\r\n\r\n  onwriteStateUpdate(state);\r\n\r\n  if (er) onwriteError(stream, state, sync, er, cb);else {\r\n    // Check if we\'re actually ready to finish, but don\'t emit yet\r\n    var finished = needFinish(state);\r\n\r\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\r\n      clearBuffer(stream, state);\r\n    }\r\n\r\n    if (sync) {\r\n      /*<replacement>*/\r\n      asyncWrite(afterWrite, stream, state, finished, cb);\r\n      /*</replacement>*/\r\n    } else {\r\n      afterWrite(stream, state, finished, cb);\r\n    }\r\n  }\r\n}\r\n\r\nfunction afterWrite(stream, state, finished, cb) {\r\n  if (!finished) onwriteDrain(stream, state);\r\n  state.pendingcb--;\r\n  cb();\r\n  finishMaybe(stream, state);\r\n}\r\n\r\n// Must force callback to be called on nextTick, so that we don\'t\r\n// emit \'drain\' before the write() consumer gets the \'false\' return\r\n// value, and has a chance to attach a \'drain\' listener.\r\nfunction onwriteDrain(stream, state) {\r\n  if (state.length === 0 && state.needDrain) {\r\n    state.needDrain = false;\r\n    stream.emit(\'drain\');\r\n  }\r\n}\r\n\r\n// if there\'s something in the buffer waiting, then process it\r\nfunction clearBuffer(stream, state) {\r\n  state.bufferProcessing = true;\r\n  var entry = state.bufferedRequest;\r\n\r\n  if (stream._writev && entry && entry.next) {\r\n    // Fast case, write everything using _writev()\r\n    var l = state.bufferedRequestCount;\r\n    var buffer = new Array(l);\r\n    var holder = state.corkedRequestsFree;\r\n    holder.entry = entry;\r\n\r\n    var count = 0;\r\n    var allBuffers = true;\r\n    while (entry) {\r\n      buffer[count] = entry;\r\n      if (!entry.isBuf) allBuffers = false;\r\n      entry = entry.next;\r\n      count += 1;\r\n    }\r\n    buffer.allBuffers = allBuffers;\r\n\r\n    doWrite(stream, state, true, state.length, buffer, \'\', holder.finish);\r\n\r\n    // doWrite is almost always async, defer these to save a bit of time\r\n    // as the hot path ends with doWrite\r\n    state.pendingcb++;\r\n    state.lastBufferedRequest = null;\r\n    if (holder.next) {\r\n      state.corkedRequestsFree = holder.next;\r\n      holder.next = null;\r\n    } else {\r\n      state.corkedRequestsFree = new CorkedRequest(state);\r\n    }\r\n  } else {\r\n    // Slow case, write chunks one-by-one\r\n    while (entry) {\r\n      var chunk = entry.chunk;\r\n      var encoding = entry.encoding;\r\n      var cb = entry.callback;\r\n      var len = state.objectMode ? 1 : chunk.length;\r\n\r\n      doWrite(stream, state, false, len, chunk, encoding, cb);\r\n      entry = entry.next;\r\n      // if we didn\'t call the onwrite immediately, then\r\n      // it means that we need to wait until it does.\r\n      // also, that means that the chunk and cb are currently\r\n      // being processed, so move the buffer counter past them.\r\n      if (state.writing) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (entry === null) state.lastBufferedRequest = null;\r\n  }\r\n\r\n  state.bufferedRequestCount = 0;\r\n  state.bufferedRequest = entry;\r\n  state.bufferProcessing = false;\r\n}\r\n\r\nWritable.prototype._write = function (chunk, encoding, cb) {\r\n  cb(new Error(\'_write() is not implemented\'));\r\n};\r\n\r\nWritable.prototype._writev = null;\r\n\r\nWritable.prototype.end = function (chunk, encoding, cb) {\r\n  var state = this._writableState;\r\n\r\n  if (typeof chunk === \'function\') {\r\n    cb = chunk;\r\n    chunk = null;\r\n    encoding = null;\r\n  } else if (typeof encoding === \'function\') {\r\n    cb = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\r\n\r\n  // .end() fully uncorks\r\n  if (state.corked) {\r\n    state.corked = 1;\r\n    this.uncork();\r\n  }\r\n\r\n  // ignore unnecessary end() calls.\r\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\r\n};\r\n\r\nfunction needFinish(state) {\r\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\r\n}\r\nfunction callFinal(stream, state) {\r\n  stream._final(function (err) {\r\n    state.pendingcb--;\r\n    if (err) {\r\n      stream.emit(\'error\', err);\r\n    }\r\n    state.prefinished = true;\r\n    stream.emit(\'prefinish\');\r\n    finishMaybe(stream, state);\r\n  });\r\n}\r\nfunction prefinish(stream, state) {\r\n  if (!state.prefinished && !state.finalCalled) {\r\n    if (typeof stream._final === \'function\') {\r\n      state.pendingcb++;\r\n      state.finalCalled = true;\r\n      processNextTick(callFinal, stream, state);\r\n    } else {\r\n      state.prefinished = true;\r\n      stream.emit(\'prefinish\');\r\n    }\r\n  }\r\n}\r\n\r\nfunction finishMaybe(stream, state) {\r\n  var need = needFinish(state);\r\n  if (need) {\r\n    prefinish(stream, state);\r\n    if (state.pendingcb === 0) {\r\n      state.finished = true;\r\n      stream.emit(\'finish\');\r\n    }\r\n  }\r\n  return need;\r\n}\r\n\r\nfunction endWritable(stream, state, cb) {\r\n  state.ending = true;\r\n  finishMaybe(stream, state);\r\n  if (cb) {\r\n    if (state.finished) processNextTick(cb);else stream.once(\'finish\', cb);\r\n  }\r\n  state.ended = true;\r\n  stream.writable = false;\r\n}\r\n\r\nfunction onCorkedFinish(corkReq, state, err) {\r\n  var entry = corkReq.entry;\r\n  corkReq.entry = null;\r\n  while (entry) {\r\n    var cb = entry.callback;\r\n    state.pendingcb--;\r\n    cb(err);\r\n    entry = entry.next;\r\n  }\r\n  if (state.corkedRequestsFree) {\r\n    state.corkedRequestsFree.next = corkReq;\r\n  } else {\r\n    state.corkedRequestsFree = corkReq;\r\n  }\r\n}\r\n\r\nObject.defineProperty(Writable.prototype, \'destroyed\', {\r\n  get: function () {\r\n    if (this._writableState === undefined) {\r\n      return false;\r\n    }\r\n    return this._writableState.destroyed;\r\n  },\r\n  set: function (value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (!this._writableState) {\r\n      return;\r\n    }\r\n\r\n    // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n    this._writableState.destroyed = value;\r\n  }\r\n});\r\n\r\nWritable.prototype.destroy = destroyImpl.destroy;\r\nWritable.prototype._undestroy = destroyImpl.undestroy;\r\nWritable.prototype._destroy = function (err, cb) {\r\n  this.end();\r\n  cb(err);\r\n};\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(28).setImmediate, __webpack_require__(2)))\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n\r\n\r\nvar Buffer = __webpack_require__(7).Buffer;\r\n\r\nvar isEncoding = Buffer.isEncoding || function (encoding) {\r\n  encoding = \'\' + encoding;\r\n  switch (encoding && encoding.toLowerCase()) {\r\n    case \'hex\':case \'utf8\':case \'utf-8\':case \'ascii\':case \'binary\':case \'base64\':case \'ucs2\':case \'ucs-2\':case \'utf16le\':case \'utf-16le\':case \'raw\':\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n};\r\n\r\nfunction _normalizeEncoding(enc) {\r\n  if (!enc) return \'utf8\';\r\n  var retried;\r\n  while (true) {\r\n    switch (enc) {\r\n      case \'utf8\':\r\n      case \'utf-8\':\r\n        return \'utf8\';\r\n      case \'ucs2\':\r\n      case \'ucs-2\':\r\n      case \'utf16le\':\r\n      case \'utf-16le\':\r\n        return \'utf16le\';\r\n      case \'latin1\':\r\n      case \'binary\':\r\n        return \'latin1\';\r\n      case \'base64\':\r\n      case \'ascii\':\r\n      case \'hex\':\r\n        return enc;\r\n      default:\r\n        if (retried) return; // undefined\r\n        enc = (\'\' + enc).toLowerCase();\r\n        retried = true;\r\n    }\r\n  }\r\n};\r\n\r\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\r\n// modules monkey-patch it to support additional encodings\r\nfunction normalizeEncoding(enc) {\r\n  var nenc = _normalizeEncoding(enc);\r\n  if (typeof nenc !== \'string\' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error(\'Unknown encoding: \' + enc);\r\n  return nenc || enc;\r\n}\r\n\r\n// StringDecoder provides an interface for efficiently splitting a series of\r\n// buffers into a series of JS strings without breaking apart multi-byte\r\n// characters.\r\nexports.StringDecoder = StringDecoder;\r\nfunction StringDecoder(encoding) {\r\n  this.encoding = normalizeEncoding(encoding);\r\n  var nb;\r\n  switch (this.encoding) {\r\n    case \'utf16le\':\r\n      this.text = utf16Text;\r\n      this.end = utf16End;\r\n      nb = 4;\r\n      break;\r\n    case \'utf8\':\r\n      this.fillLast = utf8FillLast;\r\n      nb = 4;\r\n      break;\r\n    case \'base64\':\r\n      this.text = base64Text;\r\n      this.end = base64End;\r\n      nb = 3;\r\n      break;\r\n    default:\r\n      this.write = simpleWrite;\r\n      this.end = simpleEnd;\r\n      return;\r\n  }\r\n  this.lastNeed = 0;\r\n  this.lastTotal = 0;\r\n  this.lastChar = Buffer.allocUnsafe(nb);\r\n}\r\n\r\nStringDecoder.prototype.write = function (buf) {\r\n  if (buf.length === 0) return \'\';\r\n  var r;\r\n  var i;\r\n  if (this.lastNeed) {\r\n    r = this.fillLast(buf);\r\n    if (r === undefined) return \'\';\r\n    i = this.lastNeed;\r\n    this.lastNeed = 0;\r\n  } else {\r\n    i = 0;\r\n  }\r\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\r\n  return r || \'\';\r\n};\r\n\r\nStringDecoder.prototype.end = utf8End;\r\n\r\n// Returns only complete characters in a Buffer\r\nStringDecoder.prototype.text = utf8Text;\r\n\r\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\r\nStringDecoder.prototype.fillLast = function (buf) {\r\n  if (this.lastNeed <= buf.length) {\r\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\r\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n  }\r\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\r\n  this.lastNeed -= buf.length;\r\n};\r\n\r\n// Checks the type of a UTF-8 byte, whether it\'s ASCII, a leading byte, or a\r\n// continuation byte.\r\nfunction utf8CheckByte(byte) {\r\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\r\n  return -1;\r\n}\r\n\r\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\r\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\r\n// needed to complete the UTF-8 character (if applicable) are returned.\r\nfunction utf8CheckIncomplete(self, buf, i) {\r\n  var j = buf.length - 1;\r\n  if (j < i) return 0;\r\n  var nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) self.lastNeed = nb - 1;\r\n    return nb;\r\n  }\r\n  if (--j < i) return 0;\r\n  nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) self.lastNeed = nb - 2;\r\n    return nb;\r\n  }\r\n  if (--j < i) return 0;\r\n  nb = utf8CheckByte(buf[j]);\r\n  if (nb >= 0) {\r\n    if (nb > 0) {\r\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\r\n    }\r\n    return nb;\r\n  }\r\n  return 0;\r\n}\r\n\r\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\r\n// needed or are available. If we see a non-continuation byte where we expect\r\n// one, we "replace" the validated continuation bytes we\'ve seen so far with\r\n// UTF-8 replacement characters (\'\\ufffd\'), to match v8\'s UTF-8 decoding\r\n// behavior. The continuation byte check is included three times in the case\r\n// where all of the continuation bytes for a character exist in the same buffer.\r\n// It is also done this way as a slight performance increase instead of using a\r\n// loop.\r\nfunction utf8CheckExtraBytes(self, buf, p) {\r\n  if ((buf[0] & 0xC0) !== 0x80) {\r\n    self.lastNeed = 0;\r\n    return \'\\ufffd\'.repeat(p);\r\n  }\r\n  if (self.lastNeed > 1 && buf.length > 1) {\r\n    if ((buf[1] & 0xC0) !== 0x80) {\r\n      self.lastNeed = 1;\r\n      return \'\\ufffd\'.repeat(p + 1);\r\n    }\r\n    if (self.lastNeed > 2 && buf.length > 2) {\r\n      if ((buf[2] & 0xC0) !== 0x80) {\r\n        self.lastNeed = 2;\r\n        return \'\\ufffd\'.repeat(p + 2);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\r\nfunction utf8FillLast(buf) {\r\n  var p = this.lastTotal - this.lastNeed;\r\n  var r = utf8CheckExtraBytes(this, buf, p);\r\n  if (r !== undefined) return r;\r\n  if (this.lastNeed <= buf.length) {\r\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\r\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\r\n  }\r\n  buf.copy(this.lastChar, p, 0, buf.length);\r\n  this.lastNeed -= buf.length;\r\n}\r\n\r\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\r\n// partial character, the character\'s bytes are buffered until the required\r\n// number of bytes are available.\r\nfunction utf8Text(buf, i) {\r\n  var total = utf8CheckIncomplete(this, buf, i);\r\n  if (!this.lastNeed) return buf.toString(\'utf8\', i);\r\n  this.lastTotal = total;\r\n  var end = buf.length - (total - this.lastNeed);\r\n  buf.copy(this.lastChar, 0, end);\r\n  return buf.toString(\'utf8\', i, end);\r\n}\r\n\r\n// For UTF-8, a replacement character for each buffered byte of a (partial)\r\n// character needs to be added to the output.\r\nfunction utf8End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : \'\';\r\n  if (this.lastNeed) return r + \'\\ufffd\'.repeat(this.lastTotal - this.lastNeed);\r\n  return r;\r\n}\r\n\r\n// UTF-16LE typically needs two bytes per character, but even if we have an even\r\n// number of bytes available, we need to check if we end on a leading/high\r\n// surrogate. In that case, we need to wait for the next two bytes in order to\r\n// decode the last character properly.\r\nfunction utf16Text(buf, i) {\r\n  if ((buf.length - i) % 2 === 0) {\r\n    var r = buf.toString(\'utf16le\', i);\r\n    if (r) {\r\n      var c = r.charCodeAt(r.length - 1);\r\n      if (c >= 0xD800 && c <= 0xDBFF) {\r\n        this.lastNeed = 2;\r\n        this.lastTotal = 4;\r\n        this.lastChar[0] = buf[buf.length - 2];\r\n        this.lastChar[1] = buf[buf.length - 1];\r\n        return r.slice(0, -1);\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n  this.lastNeed = 1;\r\n  this.lastTotal = 2;\r\n  this.lastChar[0] = buf[buf.length - 1];\r\n  return buf.toString(\'utf16le\', i, buf.length - 1);\r\n}\r\n\r\n// For UTF-16LE we do not explicitly append special replacement characters if we\r\n// end on a partial character, we simply let v8 handle that.\r\nfunction utf16End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : \'\';\r\n  if (this.lastNeed) {\r\n    var end = this.lastTotal - this.lastNeed;\r\n    return r + this.lastChar.toString(\'utf16le\', 0, end);\r\n  }\r\n  return r;\r\n}\r\n\r\nfunction base64Text(buf, i) {\r\n  var n = (buf.length - i) % 3;\r\n  if (n === 0) return buf.toString(\'base64\', i);\r\n  this.lastNeed = 3 - n;\r\n  this.lastTotal = 3;\r\n  if (n === 1) {\r\n    this.lastChar[0] = buf[buf.length - 1];\r\n  } else {\r\n    this.lastChar[0] = buf[buf.length - 2];\r\n    this.lastChar[1] = buf[buf.length - 1];\r\n  }\r\n  return buf.toString(\'base64\', i, buf.length - n);\r\n}\r\n\r\nfunction base64End(buf) {\r\n  var r = buf && buf.length ? this.write(buf) : \'\';\r\n  if (this.lastNeed) return r + this.lastChar.toString(\'base64\', 0, 3 - this.lastNeed);\r\n  return r;\r\n}\r\n\r\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\r\nfunction simpleWrite(buf) {\r\n  return buf.toString(this.encoding);\r\n}\r\n\r\nfunction simpleEnd(buf) {\r\n  return buf && buf.length ? this.write(buf) : \'\';\r\n}\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nvar isArray = __webpack_require__(13).isArray;\r\n\r\nmodule.exports = {\r\n\r\n  copyOptions: function (options) {\r\n    var key, copy = {};\r\n    for (key in options) {\r\n      if (options.hasOwnProperty(key)) {\r\n        copy[key] = options[key];\r\n      }\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  ensureFlagExists: function (item, options) {\r\n    if (!(item in options) || typeof options[item] !== \'boolean\') {\r\n      options[item] = false;\r\n    }\r\n  },\r\n\r\n  ensureSpacesExists: function (options) {\r\n    if (!(\'spaces\' in options) || (typeof options.spaces !== \'number\' && typeof options.spaces !== \'string\')) {\r\n      options.spaces = 0;\r\n    }\r\n  },\r\n\r\n  ensureAlwaysArrayExists: function (options) {\r\n    if (!(\'alwaysArray\' in options) || (typeof options.alwaysArray !== \'boolean\' && !isArray(options.alwaysArray))) {\r\n      options.alwaysArray = false;\r\n    }\r\n  },\r\n\r\n  ensureKeyExists: function (key, options) {\r\n    if (!(key + \'Key\' in options) || typeof options[key + \'Key\'] !== \'string\') {\r\n      options[key + \'Key\'] = options.compact ? \'_\' + key : key;\r\n    }\r\n  },\r\n\r\n  checkFnExists: function (key, options) {\r\n    return key + \'Fn\' in options;\r\n  }\r\n\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = {\r\n\r\n  isArray: function(value) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(value);\r\n    }\r\n    // fallback for older browsers like  IE 8\r\n    return Object.prototype.toString.call( value ) === \'[object Array]\';\r\n  }\r\n\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nvar sax = __webpack_require__(22);\r\nvar expat /*= require(\'node-expat\');*/ = { on: function () { }, parse: function () { } };\r\nvar helper = __webpack_require__(12);\r\nvar isArray = __webpack_require__(13).isArray;\r\n\r\nvar options;\r\nvar pureJsParser = true;\r\nvar currentElement;\r\n\r\nfunction validateOptions(userOptions) {\r\n  options = helper.copyOptions(userOptions);\r\n  helper.ensureFlagExists(\'ignoreDeclaration\', options);\r\n  helper.ensureFlagExists(\'ignoreInstruction\', options);\r\n  helper.ensureFlagExists(\'ignoreAttributes\', options);\r\n  helper.ensureFlagExists(\'ignoreText\', options);\r\n  helper.ensureFlagExists(\'ignoreComment\', options);\r\n  helper.ensureFlagExists(\'ignoreCdata\', options);\r\n  helper.ensureFlagExists(\'ignoreDoctype\', options);\r\n  helper.ensureFlagExists(\'compact\', options);\r\n  helper.ensureFlagExists(\'alwaysChildren\', options);\r\n  helper.ensureFlagExists(\'addParent\', options);\r\n  helper.ensureFlagExists(\'trim\', options);\r\n  helper.ensureFlagExists(\'nativeType\', options);\r\n  helper.ensureFlagExists(\'sanitize\', options);\r\n  helper.ensureFlagExists(\'instructionHasAttributes\', options);\r\n  helper.ensureFlagExists(\'captureSpacesBetweenElements\', options);\r\n  helper.ensureAlwaysArrayExists(options);\r\n  helper.ensureKeyExists(\'declaration\', options);\r\n  helper.ensureKeyExists(\'instruction\', options);\r\n  helper.ensureKeyExists(\'attributes\', options);\r\n  helper.ensureKeyExists(\'text\', options);\r\n  helper.ensureKeyExists(\'comment\', options);\r\n  helper.ensureKeyExists(\'cdata\', options);\r\n  helper.ensureKeyExists(\'doctype\', options);\r\n  helper.ensureKeyExists(\'type\', options);\r\n  helper.ensureKeyExists(\'name\', options);\r\n  helper.ensureKeyExists(\'elements\', options);\r\n  helper.ensureKeyExists(\'parent\', options);\r\n  helper.checkFnExists(\'doctype\', options);\r\n  helper.checkFnExists(\'instruction\', options);\r\n  helper.checkFnExists(\'cdata\', options);\r\n  helper.checkFnExists(\'comment\', options);\r\n  helper.checkFnExists(\'text\', options);\r\n  helper.checkFnExists(\'instructionName\', options);\r\n  helper.checkFnExists(\'elementName\', options);\r\n  helper.checkFnExists(\'attributeName\', options);\r\n  helper.checkFnExists(\'attributeValue\', options);\r\n  helper.checkFnExists(\'attributes\', options);\r\n  return options;\r\n}\r\n\r\nfunction nativeType(value) {\r\n  var nValue = Number(value);\r\n  if (!isNaN(nValue)) {\r\n    return nValue;\r\n  }\r\n  var bValue = value.toLowerCase();\r\n  if (bValue === \'true\') {\r\n    return true;\r\n  } else if (bValue === \'false\') {\r\n    return false;\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction addField(type, value) {\r\n  var key;\r\n  if (options.compact) {\r\n    if (\r\n      !currentElement[options[type + \'Key\']] &&\r\n      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + \'Key\']) !== -1 : options.alwaysArray)\r\n    ) {\r\n      currentElement[options[type + \'Key\']] = [];\r\n    }\r\n    if (currentElement[options[type + \'Key\']] && !isArray(currentElement[options[type + \'Key\']])) {\r\n      currentElement[options[type + \'Key\']] = [currentElement[options[type + \'Key\']]];\r\n    }\r\n    if (type + \'Fn\' in options && typeof value === \'string\') {\r\n      value = options[type + \'Fn\'](value, currentElement);\r\n    }\r\n    if (type === \'instruction\' && (\'instructionFn\' in options || \'instructionNameFn\' in options)) {\r\n      for (key in value) {\r\n        if (value.hasOwnProperty(key)) {\r\n          if (\'instructionFn\' in options) {\r\n            value[key] = options.instructionFn(value[key], key, currentElement);\r\n          } else {\r\n            var temp = value[key];\r\n            delete value[key];\r\n            value[options.instructionNameFn(key, temp, currentElement)] = temp;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (isArray(currentElement[options[type + \'Key\']])) {\r\n      currentElement[options[type + \'Key\']].push(value);\r\n    } else {\r\n      currentElement[options[type + \'Key\']] = value;\r\n    }\r\n  } else {\r\n    if (!currentElement[options.elementsKey]) {\r\n      currentElement[options.elementsKey] = [];\r\n    }\r\n    var element = {};\r\n    element[options.typeKey] = type;\r\n    if (type === \'instruction\') {\r\n      for (key in value) {\r\n        if (value.hasOwnProperty(key)) {\r\n          break;\r\n        }\r\n      }\r\n      element[options.nameKey] = \'instructionNameFn\' in options ? options.instructionNameFn(key, value, currentElement) : key;\r\n      if (options.instructionHasAttributes) {\r\n        element[options.attributesKey] = value[key][options.attributesKey];\r\n        if (\'instructionFn\' in options) {\r\n          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);\r\n        }\r\n      } else {\r\n        if (\'instructionFn\' in options) {\r\n          value[key] = options.instructionFn(value[key], key, currentElement);\r\n        }\r\n        element[options.instructionKey] = value[key];\r\n      }\r\n    } else {\r\n      if (type + \'Fn\' in options) {\r\n        value = options[type + \'Fn\'](value, currentElement);\r\n      }\r\n      element[options[type + \'Key\']] = value;\r\n    }\r\n    if (options.addParent) {\r\n      element[options.parentKey] = currentElement;\r\n    }\r\n    currentElement[options.elementsKey].push(element);\r\n  }\r\n}\r\n\r\nfunction manipulateAttributes(attributes) {\r\n  if (\'attributesFn\' in options && attributes) {\r\n    attributes = options.attributesFn(attributes, currentElement);\r\n  }\r\n  if ((options.trim || \'attributeValueFn\' in options || \'attributeNameFn\' in options) && attributes) {\r\n    var key;\r\n    for (key in attributes) {\r\n      if (attributes.hasOwnProperty(key)) {\r\n        if (options.trim) attributes[key] = attributes[key].trim();\r\n        if (\'attributeValueFn\' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);\r\n        if (\'attributeNameFn\' in options) {\r\n          var temp = attributes[key];\r\n          delete attributes[key];\r\n          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return attributes;\r\n}\r\n\r\nfunction onInstruction(instruction) {\r\n  var attributes = {};\r\n  if (instruction.body && (instruction.name.toLowerCase() === \'xml\' || options.instructionHasAttributes)) {\r\n    var attrsRegExp = /([\\w:-]+)\\s*=\\s*(?:"([^"]*)"|\'([^\']*)\'|(\\w+))\\s*/g;\r\n    var match;\r\n    while ((match = attrsRegExp.exec(instruction.body)) !== null) {\r\n      attributes[match[1]] = match[2] || match[3] || match[4];\r\n    }\r\n    attributes = manipulateAttributes(attributes);\r\n  }\r\n  if (instruction.name.toLowerCase() === \'xml\') {\r\n    if (options.ignoreDeclaration) {\r\n      return;\r\n    }\r\n    currentElement[options.declarationKey] = {};\r\n    if (Object.keys(attributes).length) {\r\n      currentElement[options.declarationKey][options.attributesKey] = attributes;\r\n    }\r\n    if (options.addParent) {\r\n      currentElement[options.declarationKey][options.parentKey] = currentElement;\r\n    }\r\n  } else {\r\n    if (options.ignoreInstruction) {\r\n      return;\r\n    }\r\n    if (options.trim) {\r\n      instruction.body = instruction.body.trim();\r\n    }\r\n    var value = {};\r\n    if (options.instructionHasAttributes && Object.keys(attributes).length) {\r\n      value[instruction.name] = {};\r\n      value[instruction.name][options.attributesKey] = attributes;\r\n    } else {\r\n      value[instruction.name] = instruction.body;\r\n    }\r\n    addField(\'instruction\', value);\r\n  }\r\n}\r\n\r\nfunction onStartElement(name, attributes) {\r\n  var element;\r\n  if (typeof name === \'object\') {\r\n    attributes = name.attributes;\r\n    name = name.name;\r\n  }\r\n  attributes = manipulateAttributes(attributes);\r\n  if (\'elementNameFn\' in options) {\r\n    name = options.elementNameFn(name, currentElement);\r\n  }\r\n  if (options.compact) {\r\n    element = {};\r\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\r\n      element[options.attributesKey] = {};\r\n      var key;\r\n      for (key in attributes) {\r\n        if (attributes.hasOwnProperty(key)) {\r\n          element[options.attributesKey][key] = attributes[key];\r\n        }\r\n      }\r\n    }\r\n    if (\r\n      !(name in currentElement) &&\r\n      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)\r\n    ) {\r\n      currentElement[name] = [];\r\n    }\r\n    if (currentElement[name] && !isArray(currentElement[name])) {\r\n      currentElement[name] = [currentElement[name]];\r\n    }\r\n    if (isArray(currentElement[name])) {\r\n      currentElement[name].push(element);\r\n    } else {\r\n      currentElement[name] = element;\r\n    }\r\n  } else {\r\n    if (!currentElement[options.elementsKey]) {\r\n      currentElement[options.elementsKey] = [];\r\n    }\r\n    element = {};\r\n    element[options.typeKey] = \'element\';\r\n    element[options.nameKey] = name;\r\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\r\n      element[options.attributesKey] = attributes;\r\n    }\r\n    if (options.alwaysChildren) {\r\n      element[options.elementsKey] = [];\r\n    }\r\n    currentElement[options.elementsKey].push(element);\r\n  }\r\n  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent\r\n  currentElement = element;\r\n}\r\n\r\nfunction onText(text) {\r\n  if (options.ignoreText) {\r\n    return;\r\n  }\r\n  if (!text.trim() && !options.captureSpacesBetweenElements) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    text = text.trim();\r\n  }\r\n  if (options.nativeType) {\r\n    text = nativeType(text);\r\n  }\r\n  if (options.sanitize) {\r\n    text = text.replace(/&/g, \'&amp;\').replace(/</g, \'&lt;\').replace(/>/g, \'&gt;\');\r\n  }\r\n  addField(\'text\', text);\r\n}\r\n\r\nfunction onComment(comment) {\r\n  if (options.ignoreComment) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    comment = comment.trim();\r\n  }\r\n  addField(\'comment\', comment);\r\n}\r\n\r\nfunction onEndElement(name) {\r\n  var parentElement = currentElement[options.parentKey];\r\n  if (!options.addParent) {\r\n    delete currentElement[options.parentKey];\r\n  }\r\n  currentElement = parentElement;\r\n}\r\n\r\nfunction onCdata(cdata) {\r\n  if (options.ignoreCdata) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    cdata = cdata.trim();\r\n  }\r\n  addField(\'cdata\', cdata);\r\n}\r\n\r\nfunction onDoctype(doctype) {\r\n  if (options.ignoreDoctype) {\r\n    return;\r\n  }\r\n  doctype = doctype.replace(/^ /, \'\');\r\n  if (options.trim) {\r\n    doctype = doctype.trim();\r\n  }\r\n  addField(\'doctype\', doctype);\r\n}\r\n\r\nfunction onError(error) {\r\n  error.note = error; //console.error(error);\r\n}\r\n\r\nmodule.exports = function (xml, userOptions) {\r\n\r\n  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser(\'UTF-8\');\r\n  var result = {};\r\n  currentElement = result;\r\n\r\n  options = validateOptions(userOptions);\r\n\r\n  if (pureJsParser) {\r\n    parser.opt = {strictEntities: true};\r\n    parser.onopentag = onStartElement;\r\n    parser.ontext = onText;\r\n    parser.oncomment = onComment;\r\n    parser.onclosetag = onEndElement;\r\n    parser.onerror = onError;\r\n    parser.oncdata = onCdata;\r\n    parser.ondoctype = onDoctype;\r\n    parser.onprocessinginstruction = onInstruction;\r\n  } else {\r\n    parser.on(\'startElement\', onStartElement);\r\n    parser.on(\'text\', onText);\r\n    parser.on(\'comment\', onComment);\r\n    parser.on(\'endElement\', onEndElement);\r\n    parser.on(\'error\', onError);\r\n    //parser.on(\'startCdata\', onStartCdata);\r\n    //parser.on(\'endCdata\', onEndCdata);\r\n    //parser.on(\'entityDecl\', onEntityDecl);\r\n  }\r\n\r\n  if (pureJsParser) {\r\n    parser.write(xml).close();\r\n  } else {\r\n    if (!parser.parse(xml)) {\r\n      throw new Error(\'XML parsing error: \' + parser.getError());\r\n    }\r\n  }\r\n\r\n  if (result[options.elementsKey]) {\r\n    var temp = result[options.elementsKey];\r\n    delete result[options.elementsKey];\r\n    result[options.elementsKey] = temp;\r\n    delete result.text;\r\n  }\r\n\r\n  return result;\r\n\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports) {\r\n\r\nvar toString = {}.toString;\r\n\r\nmodule.exports = Array.isArray || function (arr) {\r\n  return toString.call(arr) == \'[object Array]\';\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar processNextTick = __webpack_require__(6);\r\n/*</replacement>*/\r\n\r\nmodule.exports = Readable;\r\n\r\n/*<replacement>*/\r\nvar isArray = __webpack_require__(15);\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Duplex;\r\n/*</replacement>*/\r\n\r\nReadable.ReadableState = ReadableState;\r\n\r\n/*<replacement>*/\r\nvar EE = __webpack_require__(8).EventEmitter;\r\n\r\nvar EElistenerCount = function (emitter, type) {\r\n  return emitter.listeners(type).length;\r\n};\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar Stream = __webpack_require__(17);\r\n/*</replacement>*/\r\n\r\n// TODO(bmeurer): Change this back to const once hole checks are\r\n// properly optimized away early in Ignition+TurboFan.\r\n/*<replacement>*/\r\nvar Buffer = __webpack_require__(7).Buffer;\r\nvar OurUint8Array = global.Uint8Array || function () {};\r\nfunction _uint8ArrayToBuffer(chunk) {\r\n  return Buffer.from(chunk);\r\n}\r\nfunction _isUint8Array(obj) {\r\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\r\n}\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar util = __webpack_require__(3);\r\nutil.inherits = __webpack_require__(1);\r\n/*</replacement>*/\r\n\r\n/*<replacement>*/\r\nvar debugUtil = __webpack_require__(26);\r\nvar debug = void 0;\r\nif (debugUtil && debugUtil.debuglog) {\r\n  debug = debugUtil.debuglog(\'stream\');\r\n} else {\r\n  debug = function () {};\r\n}\r\n/*</replacement>*/\r\n\r\nvar BufferList = __webpack_require__(27);\r\nvar destroyImpl = __webpack_require__(18);\r\nvar StringDecoder;\r\n\r\nutil.inherits(Readable, Stream);\r\n\r\nvar kProxyEvents = [\'error\', \'close\', \'destroy\', \'pause\', \'resume\'];\r\n\r\nfunction prependListener(emitter, event, fn) {\r\n  // Sadly this is not cacheable as some libraries bundle their own\r\n  // event emitter implementation with them.\r\n  if (typeof emitter.prependListener === \'function\') {\r\n    return emitter.prependListener(event, fn);\r\n  } else {\r\n    // This is a hack to make sure that our error handler is attached before any\r\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\r\n    // to continue to work with older versions of Node.js that do not include\r\n    // the prependListener() method. The goal is to eventually remove this hack.\r\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\r\n  }\r\n}\r\n\r\nfunction ReadableState(options, stream) {\r\n  Duplex = Duplex || __webpack_require__(0);\r\n\r\n  options = options || {};\r\n\r\n  // object stream flag. Used to make read(n) ignore n and to\r\n  // make all the buffer merging and length checks go away\r\n  this.objectMode = !!options.objectMode;\r\n\r\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\r\n\r\n  // the point at which it stops calling _read() to fill the buffer\r\n  // Note: 0 is a valid value, means "don\'t call _read preemptively ever"\r\n  var hwm = options.highWaterMark;\r\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\r\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\r\n\r\n  // cast to ints.\r\n  this.highWaterMark = Math.floor(this.highWaterMark);\r\n\r\n  // A linked list is used to store data chunks instead of an array because the\r\n  // linked list can remove elements from the beginning faster than\r\n  // array.shift()\r\n  this.buffer = new BufferList();\r\n  this.length = 0;\r\n  this.pipes = null;\r\n  this.pipesCount = 0;\r\n  this.flowing = null;\r\n  this.ended = false;\r\n  this.endEmitted = false;\r\n  this.reading = false;\r\n\r\n  // a flag to be able to tell if the event \'readable\'/\'data\' is emitted\r\n  // immediately, or on a later tick.  We set this to true at first, because\r\n  // any actions that shouldn\'t happen until "later" should generally also\r\n  // not happen before the first read call.\r\n  this.sync = true;\r\n\r\n  // whenever we return null, then we set a flag to say\r\n  // that we\'re awaiting a \'readable\' event emission.\r\n  this.needReadable = false;\r\n  this.emittedReadable = false;\r\n  this.readableListening = false;\r\n  this.resumeScheduled = false;\r\n\r\n  // has it been destroyed\r\n  this.destroyed = false;\r\n\r\n  // Crypto is kind of old and crusty.  Historically, its default string\r\n  // encoding is \'binary\' so we have to make this configurable.\r\n  // Everything else in the universe uses \'utf8\', though.\r\n  this.defaultEncoding = options.defaultEncoding || \'utf8\';\r\n\r\n  // the number of writers that are awaiting a drain event in .pipe()s\r\n  this.awaitDrain = 0;\r\n\r\n  // if true, a maybeReadMore has been scheduled\r\n  this.readingMore = false;\r\n\r\n  this.decoder = null;\r\n  this.encoding = null;\r\n  if (options.encoding) {\r\n    if (!StringDecoder) StringDecoder = __webpack_require__(11).StringDecoder;\r\n    this.decoder = new StringDecoder(options.encoding);\r\n    this.encoding = options.encoding;\r\n  }\r\n}\r\n\r\nfunction Readable(options) {\r\n  Duplex = Duplex || __webpack_require__(0);\r\n\r\n  if (!(this instanceof Readable)) return new Readable(options);\r\n\r\n  this._readableState = new ReadableState(options, this);\r\n\r\n  // legacy\r\n  this.readable = true;\r\n\r\n  if (options) {\r\n    if (typeof options.read === \'function\') this._read = options.read;\r\n\r\n    if (typeof options.destroy === \'function\') this._destroy = options.destroy;\r\n  }\r\n\r\n  Stream.call(this);\r\n}\r\n\r\nObject.defineProperty(Readable.prototype, \'destroyed\', {\r\n  get: function () {\r\n    if (this._readableState === undefined) {\r\n      return false;\r\n    }\r\n    return this._readableState.destroyed;\r\n  },\r\n  set: function (value) {\r\n    // we ignore the value if the stream\r\n    // has not been initialized yet\r\n    if (!this._readableState) {\r\n      return;\r\n    }\r\n\r\n    // backward compatibility, the user is explicitly\r\n    // managing destroyed\r\n    this._readableState.destroyed = value;\r\n  }\r\n});\r\n\r\nReadable.prototype.destroy = destroyImpl.destroy;\r\nReadable.prototype._undestroy = destroyImpl.undestroy;\r\nReadable.prototype._destroy = function (err, cb) {\r\n  this.push(null);\r\n  cb(err);\r\n};\r\n\r\n// Manually shove something into the read() buffer.\r\n// This returns true if the highWaterMark has not been hit yet,\r\n// similar to how Writable.write() returns true if you should\r\n// write() some more.\r\nReadable.prototype.push = function (chunk, encoding) {\r\n  var state = this._readableState;\r\n  var skipChunkCheck;\r\n\r\n  if (!state.objectMode) {\r\n    if (typeof chunk === \'string\') {\r\n      encoding = encoding || state.defaultEncoding;\r\n      if (encoding !== state.encoding) {\r\n        chunk = Buffer.from(chunk, encoding);\r\n        encoding = \'\';\r\n      }\r\n      skipChunkCheck = true;\r\n    }\r\n  } else {\r\n    skipChunkCheck = true;\r\n  }\r\n\r\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\r\n};\r\n\r\n// Unshift should *always* be something directly out of read()\r\nReadable.prototype.unshift = function (chunk) {\r\n  return readableAddChunk(this, chunk, null, true, false);\r\n};\r\n\r\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\r\n  var state = stream._readableState;\r\n  if (chunk === null) {\r\n    state.reading = false;\r\n    onEofChunk(stream, state);\r\n  } else {\r\n    var er;\r\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\r\n    if (er) {\r\n      stream.emit(\'error\', er);\r\n    } else if (state.objectMode || chunk && chunk.length > 0) {\r\n      if (typeof chunk !== \'string\' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\r\n        chunk = _uint8ArrayToBuffer(chunk);\r\n      }\r\n\r\n      if (addToFront) {\r\n        if (state.endEmitted) stream.emit(\'error\', new Error(\'stream.unshift() after end event\'));else addChunk(stream, state, chunk, true);\r\n      } else if (state.ended) {\r\n        stream.emit(\'error\', new Error(\'stream.push() after EOF\'));\r\n      } else {\r\n        state.reading = false;\r\n        if (state.decoder && !encoding) {\r\n          chunk = state.decoder.write(chunk);\r\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\r\n        } else {\r\n          addChunk(stream, state, chunk, false);\r\n        }\r\n      }\r\n    } else if (!addToFront) {\r\n      state.reading = false;\r\n    }\r\n  }\r\n\r\n  return needMoreData(state);\r\n}\r\n\r\nfunction addChunk(stream, state, chunk, addToFront) {\r\n  if (state.flowing && state.length === 0 && !state.sync) {\r\n    stream.emit(\'data\', chunk);\r\n    stream.read(0);\r\n  } else {\r\n    // update the buffer info.\r\n    state.length += state.objectMode ? 1 : chunk.length;\r\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\r\n\r\n    if (state.needReadable) emitReadable(stream);\r\n  }\r\n  maybeReadMore(stream, state);\r\n}\r\n\r\nfunction chunkInvalid(state, chunk) {\r\n  var er;\r\n  if (!_isUint8Array(chunk) && typeof chunk !== \'string\' && chunk !== undefined && !state.objectMode) {\r\n    er = new TypeError(\'Invalid non-string/buffer chunk\');\r\n  }\r\n  return er;\r\n}\r\n\r\n// if it\'s past the high water mark, we can push in some more.\r\n// Also, if we have no data yet, we can stand some\r\n// more bytes.  This is to work around cases where hwm=0,\r\n// such as the repl.  Also, if the push() triggered a\r\n// readable event, and the user called read(largeNumber) such that\r\n// needReadable was set, then we ought to push more, so that another\r\n// \'readable\' event will be triggered.\r\nfunction needMoreData(state) {\r\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\r\n}\r\n\r\nReadable.prototype.isPaused = function () {\r\n  return this._readableState.flowing === false;\r\n};\r\n\r\n// backwards compatibility.\r\nReadable.prototype.setEncoding = function (enc) {\r\n  if (!StringDecoder) StringDecoder = __webpack_require__(11).StringDecoder;\r\n  this._readableState.decoder = new StringDecoder(enc);\r\n  this._readableState.encoding = enc;\r\n  return this;\r\n};\r\n\r\n// Don\'t raise the hwm > 8MB\r\nvar MAX_HWM = 0x800000;\r\nfunction computeNewHighWaterMark(n) {\r\n  if (n >= MAX_HWM) {\r\n    n = MAX_HWM;\r\n  } else {\r\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\r\n    // tiny amounts\r\n    n--;\r\n    n |= n >>> 1;\r\n    n |= n >>> 2;\r\n    n |= n >>> 4;\r\n    n |= n >>> 8;\r\n    n |= n >>> 16;\r\n    n++;\r\n  }\r\n  return n;\r\n}\r\n\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction howMuchToRead(n, state) {\r\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\r\n  if (state.objectMode) return 1;\r\n  if (n !== n) {\r\n    // Only flow one buffer at a time\r\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\r\n  }\r\n  // If we\'re asking for more than the current hwm, then raise the hwm.\r\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\r\n  if (n <= state.length) return n;\r\n  // Don\'t have enough\r\n  if (!state.ended) {\r\n    state.needReadable = true;\r\n    return 0;\r\n  }\r\n  return state.length;\r\n}\r\n\r\n// you can override either this method, or the async _read(n) below.\r\nReadable.prototype.read = function (n) {\r\n  debug(\'read\', n);\r\n  n = parseInt(n, 10);\r\n  var state = this._readableState;\r\n  var nOrig = n;\r\n\r\n  if (n !== 0) state.emittedReadable = false;\r\n\r\n  // if we\'re doing read(0) to trigger a readable event, but we\r\n  // already have a bunch of data in the buffer, then just trigger\r\n  // the \'readable\' event and move on.\r\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\r\n    debug(\'read: emitReadable\', state.length, state.ended);\r\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\r\n    return null;\r\n  }\r\n\r\n  n = howMuchToRead(n, state);\r\n\r\n  // if we\'ve ended, and we\'re now clear, then finish it up.\r\n  if (n === 0 && state.ended) {\r\n    if (state.length === 0) endReadable(this);\r\n    return null;\r\n  }\r\n\r\n  // All the actual chunk generation logic needs to be\r\n  // *below* the call to _read.  The reason is that in certain\r\n  // synthetic stream cases, such as passthrough streams, _read\r\n  // may be a completely synchronous operation which may change\r\n  // the state of the read buffer, providing enough data when\r\n  // before there was *not* enough.\r\n  //\r\n  // So, the steps are:\r\n  // 1. Figure out what the state of things will be after we do\r\n  // a read from the buffer.\r\n  //\r\n  // 2. If that resulting state will trigger a _read, then call _read.\r\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\r\n  // deeply ugly to write APIs this way, but that still doesn\'t mean\r\n  // that the Readable class should behave improperly, as streams are\r\n  // designed to be sync/async agnostic.\r\n  // Take note if the _read call is sync or async (ie, if the read call\r\n  // has returned yet), so that we know whether or not it\'s safe to emit\r\n  // \'readable\' etc.\r\n  //\r\n  // 3. Actually pull the requested chunks out of the buffer and return.\r\n\r\n  // if we need a readable event, then we need to do some reading.\r\n  var doRead = state.needReadable;\r\n  debug(\'need readable\', doRead);\r\n\r\n  // if we currently have less than the highWaterMark, then also read some\r\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\r\n    doRead = true;\r\n    debug(\'length less than watermark\', doRead);\r\n  }\r\n\r\n  // however, if we\'ve ended, then there\'s no point, and if we\'re already\r\n  // reading, then it\'s unnecessary.\r\n  if (state.ended || state.reading) {\r\n    doRead = false;\r\n    debug(\'reading or ended\', doRead);\r\n  } else if (doRead) {\r\n    debug(\'do read\');\r\n    state.reading = true;\r\n    state.sync = true;\r\n    // if the length is currently zero, then we *need* a readable event.\r\n    if (state.length === 0) state.needReadable = true;\r\n    // call internal read method\r\n    this._read(state.highWaterMark);\r\n    state.sync = false;\r\n    // If _read pushed data synchronously, then `reading` will be false,\r\n    // and we need to re-evaluate how much data we can return to the user.\r\n    if (!state.reading) n = howMuchToRead(nOrig, state);\r\n  }\r\n\r\n  var ret;\r\n  if (n > 0) ret = fromList(n, state);else ret = null;\r\n\r\n  if (ret === null) {\r\n    state.needReadable = true;\r\n    n = 0;\r\n  } else {\r\n    state.length -= n;\r\n  }\r\n\r\n  if (state.length === 0) {\r\n    // If we have nothing in the buffer, then we want to know\r\n    // as soon as we *do* get something into the buffer.\r\n    if (!state.ended) state.needReadable = true;\r\n\r\n    // If we tried to read() past the EOF, then emit end on the next tick.\r\n    if (nOrig !== n && state.ended) endReadable(this);\r\n  }\r\n\r\n  if (ret !== null) this.emit(\'data\', ret);\r\n\r\n  return ret;\r\n};\r\n\r\nfunction onEofChunk(stream, state) {\r\n  if (state.ended) return;\r\n  if (state.decoder) {\r\n    var chunk = state.decoder.end();\r\n    if (chunk && chunk.length) {\r\n      state.buffer.push(chunk);\r\n      state.length += state.objectMode ? 1 : chunk.length;\r\n    }\r\n  }\r\n  state.ended = true;\r\n\r\n  // emit \'readable\' now to make sure it gets picked up.\r\n  emitReadable(stream);\r\n}\r\n\r\n// Don\'t emit readable right away in sync mode, because this can trigger\r\n// another read() call => stack overflow.  This way, it might trigger\r\n// a nextTick recursion warning, but that\'s not so bad.\r\nfunction emitReadable(stream) {\r\n  var state = stream._readableState;\r\n  state.needReadable = false;\r\n  if (!state.emittedReadable) {\r\n    debug(\'emitReadable\', state.flowing);\r\n    state.emittedReadable = true;\r\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\r\n  }\r\n}\r\n\r\nfunction emitReadable_(stream) {\r\n  debug(\'emit readable\');\r\n  stream.emit(\'readable\');\r\n  flow(stream);\r\n}\r\n\r\n// at this point, the user has presumably seen the \'readable\' event,\r\n// and called read() to consume some data.  that may have triggered\r\n// in turn another _read(n) call, in which case reading = true if\r\n// it\'s in progress.\r\n// However, if we\'re not ended, or reading, and the length < hwm,\r\n// then go ahead and try to read some more preemptively.\r\nfunction maybeReadMore(stream, state) {\r\n  if (!state.readingMore) {\r\n    state.readingMore = true;\r\n    processNextTick(maybeReadMore_, stream, state);\r\n  }\r\n}\r\n\r\nfunction maybeReadMore_(stream, state) {\r\n  var len = state.length;\r\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\r\n    debug(\'maybeReadMore read 0\');\r\n    stream.read(0);\r\n    if (len === state.length)\r\n      // didn\'t get any data, stop spinning.\r\n      break;else len = state.length;\r\n  }\r\n  state.readingMore = false;\r\n}\r\n\r\n// abstract method.  to be overridden in specific implementation classes.\r\n// call cb(er, data) where data is <= n in length.\r\n// for virtual (non-string, non-buffer) streams, "length" is somewhat\r\n// arbitrary, and perhaps not very meaningful.\r\nReadable.prototype._read = function (n) {\r\n  this.emit(\'error\', new Error(\'_read() is not implemented\'));\r\n};\r\n\r\nReadable.prototype.pipe = function (dest, pipeOpts) {\r\n  var src = this;\r\n  var state = this._readableState;\r\n\r\n  switch (state.pipesCount) {\r\n    case 0:\r\n      state.pipes = dest;\r\n      break;\r\n    case 1:\r\n      state.pipes = [state.pipes, dest];\r\n      break;\r\n    default:\r\n      state.pipes.push(dest);\r\n      break;\r\n  }\r\n  state.pipesCount += 1;\r\n  debug(\'pipe count=%d opts=%j\', state.pipesCount, pipeOpts);\r\n\r\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\r\n\r\n  var endFn = doEnd ? onend : unpipe;\r\n  if (state.endEmitted) processNextTick(endFn);else src.once(\'end\', endFn);\r\n\r\n  dest.on(\'unpipe\', onunpipe);\r\n  function onunpipe(readable, unpipeInfo) {\r\n    debug(\'onunpipe\');\r\n    if (readable === src) {\r\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\r\n        unpipeInfo.hasUnpiped = true;\r\n        cleanup();\r\n      }\r\n    }\r\n  }\r\n\r\n  function onend() {\r\n    debug(\'onend\');\r\n    dest.end();\r\n  }\r\n\r\n  // when the dest drains, it reduces the awaitDrain counter\r\n  // on the source.  This would be more elegant with a .once()\r\n  // handler in flow(), but adding and removing repeatedly is\r\n  // too slow.\r\n  var ondrain = pipeOnDrain(src);\r\n  dest.on(\'drain\', ondrain);\r\n\r\n  var cleanedUp = false;\r\n  function cleanup() {\r\n    debug(\'cleanup\');\r\n    // cleanup event handlers once the pipe is broken\r\n    dest.removeListener(\'close\', onclose);\r\n    dest.removeListener(\'finish\', onfinish);\r\n    dest.removeListener(\'drain\', ondrain);\r\n    dest.removeListener(\'error\', onerror);\r\n    dest.removeListener(\'unpipe\', onunpipe);\r\n    src.removeListener(\'end\', onend);\r\n    src.removeListener(\'end\', unpipe);\r\n    src.removeListener(\'data\', ondata);\r\n\r\n    cleanedUp = true;\r\n\r\n    // if the reader is waiting for a drain event from this\r\n    // specific writer, then it would cause it to never start\r\n    // flowing again.\r\n    // So, if this is awaiting a drain, then we just call it now.\r\n    // If we don\'t know, then assume that we are waiting for one.\r\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\r\n  }\r\n\r\n  // If the user pushes more data while we\'re writing to dest then we\'ll end up\r\n  // in ondata again. However, we only want to increase awaitDrain once because\r\n  // dest will only emit one \'drain\' event for the multiple writes.\r\n  // => Introduce a guard on increasing awaitDrain.\r\n  var increasedAwaitDrain = false;\r\n  src.on(\'data\', ondata);\r\n  function ondata(chunk) {\r\n    debug(\'ondata\');\r\n    increasedAwaitDrain = false;\r\n    var ret = dest.write(chunk);\r\n    if (false === ret && !increasedAwaitDrain) {\r\n      // If the user unpiped during `dest.write()`, it is possible\r\n      // to get stuck in a permanently paused state if that write\r\n      // also returned false.\r\n      // => Check whether `dest` is still a piping destination.\r\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\r\n        debug(\'false write response, pause\', src._readableState.awaitDrain);\r\n        src._readableState.awaitDrain++;\r\n        increasedAwaitDrain = true;\r\n      }\r\n      src.pause();\r\n    }\r\n  }\r\n\r\n  // if the dest has an error, then stop piping into it.\r\n  // however, don\'t suppress the throwing behavior for this.\r\n  function onerror(er) {\r\n    debug(\'onerror\', er);\r\n    unpipe();\r\n    dest.removeListener(\'error\', onerror);\r\n    if (EElistenerCount(dest, \'error\') === 0) dest.emit(\'error\', er);\r\n  }\r\n\r\n  // Make sure our error handler is attached before userland ones.\r\n  prependListener(dest, \'error\', onerror);\r\n\r\n  // Both close and finish should trigger unpipe, but only once.\r\n  function onclose() {\r\n    dest.removeListener(\'finish\', onfinish);\r\n    unpipe();\r\n  }\r\n  dest.once(\'close\', onclose);\r\n  function onfinish() {\r\n    debug(\'onfinish\');\r\n    dest.removeListener(\'close\', onclose);\r\n    unpipe();\r\n  }\r\n  dest.once(\'finish\', onfinish);\r\n\r\n  function unpipe() {\r\n    debug(\'unpipe\');\r\n    src.unpipe(dest);\r\n  }\r\n\r\n  // tell the dest that it\'s being piped to\r\n  dest.emit(\'pipe\', src);\r\n\r\n  // start the flow if it hasn\'t been started already.\r\n  if (!state.flowing) {\r\n    debug(\'pipe resume\');\r\n    src.resume();\r\n  }\r\n\r\n  return dest;\r\n};\r\n\r\nfunction pipeOnDrain(src) {\r\n  return function () {\r\n    var state = src._readableState;\r\n    debug(\'pipeOnDrain\', state.awaitDrain);\r\n    if (state.awaitDrain) state.awaitDrain--;\r\n    if (state.awaitDrain === 0 && EElistenerCount(src, \'data\')) {\r\n      state.flowing = true;\r\n      flow(src);\r\n    }\r\n  };\r\n}\r\n\r\nReadable.prototype.unpipe = function (dest) {\r\n  var state = this._readableState;\r\n  var unpipeInfo = { hasUnpiped: false };\r\n\r\n  // if we\'re not piping anywhere, then do nothing.\r\n  if (state.pipesCount === 0) return this;\r\n\r\n  // just one destination.  most common case.\r\n  if (state.pipesCount === 1) {\r\n    // passed in one, but it\'s not the right one.\r\n    if (dest && dest !== state.pipes) return this;\r\n\r\n    if (!dest) dest = state.pipes;\r\n\r\n    // got a match.\r\n    state.pipes = null;\r\n    state.pipesCount = 0;\r\n    state.flowing = false;\r\n    if (dest) dest.emit(\'unpipe\', this, unpipeInfo);\r\n    return this;\r\n  }\r\n\r\n  // slow case. multiple pipe destinations.\r\n\r\n  if (!dest) {\r\n    // remove all.\r\n    var dests = state.pipes;\r\n    var len = state.pipesCount;\r\n    state.pipes = null;\r\n    state.pipesCount = 0;\r\n    state.flowing = false;\r\n\r\n    for (var i = 0; i < len; i++) {\r\n      dests[i].emit(\'unpipe\', this, unpipeInfo);\r\n    }return this;\r\n  }\r\n\r\n  // try to find the right one.\r\n  var index = indexOf(state.pipes, dest);\r\n  if (index === -1) return this;\r\n\r\n  state.pipes.splice(index, 1);\r\n  state.pipesCount -= 1;\r\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\r\n\r\n  dest.emit(\'unpipe\', this, unpipeInfo);\r\n\r\n  return this;\r\n};\r\n\r\n// set up data events if they are asked for\r\n// Ensure readable listeners eventually get something\r\nReadable.prototype.on = function (ev, fn) {\r\n  var res = Stream.prototype.on.call(this, ev, fn);\r\n\r\n  if (ev === \'data\') {\r\n    // Start flowing on next tick if stream isn\'t explicitly paused\r\n    if (this._readableState.flowing !== false) this.resume();\r\n  } else if (ev === \'readable\') {\r\n    var state = this._readableState;\r\n    if (!state.endEmitted && !state.readableListening) {\r\n      state.readableListening = state.needReadable = true;\r\n      state.emittedReadable = false;\r\n      if (!state.reading) {\r\n        processNextTick(nReadingNextTick, this);\r\n      } else if (state.length) {\r\n        emitReadable(this);\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\nReadable.prototype.addListener = Readable.prototype.on;\r\n\r\nfunction nReadingNextTick(self) {\r\n  debug(\'readable nexttick read 0\');\r\n  self.read(0);\r\n}\r\n\r\n// pause() and resume() are remnants of the legacy readable stream API\r\n// If the user uses them, then switch into old mode.\r\nReadable.prototype.resume = function () {\r\n  var state = this._readableState;\r\n  if (!state.flowing) {\r\n    debug(\'resume\');\r\n    state.flowing = true;\r\n    resume(this, state);\r\n  }\r\n  return this;\r\n};\r\n\r\nfunction resume(stream, state) {\r\n  if (!state.resumeScheduled) {\r\n    state.resumeScheduled = true;\r\n    processNextTick(resume_, stream, state);\r\n  }\r\n}\r\n\r\nfunction resume_(stream, state) {\r\n  if (!state.reading) {\r\n    debug(\'resume read 0\');\r\n    stream.read(0);\r\n  }\r\n\r\n  state.resumeScheduled = false;\r\n  state.awaitDrain = 0;\r\n  stream.emit(\'resume\');\r\n  flow(stream);\r\n  if (state.flowing && !state.reading) stream.read(0);\r\n}\r\n\r\nReadable.prototype.pause = function () {\r\n  debug(\'call pause flowing=%j\', this._readableState.flowing);\r\n  if (false !== this._readableState.flowing) {\r\n    debug(\'pause\');\r\n    this._readableState.flowing = false;\r\n    this.emit(\'pause\');\r\n  }\r\n  return this;\r\n};\r\n\r\nfunction flow(stream) {\r\n  var state = stream._readableState;\r\n  debug(\'flow\', state.flowing);\r\n  while (state.flowing && stream.read() !== null) {}\r\n}\r\n\r\n// wrap an old-style stream as the async data source.\r\n// This is *not* part of the readable stream interface.\r\n// It is an ugly unfortunate mess of history.\r\nReadable.prototype.wrap = function (stream) {\r\n  var state = this._readableState;\r\n  var paused = false;\r\n\r\n  var self = this;\r\n  stream.on(\'end\', function () {\r\n    debug(\'wrapped end\');\r\n    if (state.decoder && !state.ended) {\r\n      var chunk = state.decoder.end();\r\n      if (chunk && chunk.length) self.push(chunk);\r\n    }\r\n\r\n    self.push(null);\r\n  });\r\n\r\n  stream.on(\'data\', function (chunk) {\r\n    debug(\'wrapped data\');\r\n    if (state.decoder) chunk = state.decoder.write(chunk);\r\n\r\n    // don\'t skip over falsy values in objectMode\r\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\r\n\r\n    var ret = self.push(chunk);\r\n    if (!ret) {\r\n      paused = true;\r\n      stream.pause();\r\n    }\r\n  });\r\n\r\n  // proxy all the other methods.\r\n  // important when wrapping filters and duplexes.\r\n  for (var i in stream) {\r\n    if (this[i] === undefined && typeof stream[i] === \'function\') {\r\n      this[i] = function (method) {\r\n        return function () {\r\n          return stream[method].apply(stream, arguments);\r\n        };\r\n      }(i);\r\n    }\r\n  }\r\n\r\n  // proxy certain important events.\r\n  for (var n = 0; n < kProxyEvents.length; n++) {\r\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\r\n  }\r\n\r\n  // when we try to consume some more bytes, simply unpause the\r\n  // underlying stream.\r\n  self._read = function (n) {\r\n    debug(\'wrapped _read\', n);\r\n    if (paused) {\r\n      paused = false;\r\n      stream.resume();\r\n    }\r\n  };\r\n\r\n  return self;\r\n};\r\n\r\n// exposed for testing purposes only.\r\nReadable._fromList = fromList;\r\n\r\n// Pluck off n bytes from an array of buffers.\r\n// Length is the combined lengths of all the buffers in the list.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction fromList(n, state) {\r\n  // nothing buffered\r\n  if (state.length === 0) return null;\r\n\r\n  var ret;\r\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\r\n    // read it all, truncate the list\r\n    if (state.decoder) ret = state.buffer.join(\'\');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\r\n    state.buffer.clear();\r\n  } else {\r\n    // read part of list\r\n    ret = fromListPartial(n, state.buffer, state.decoder);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n// Extracts only enough buffered data to satisfy the amount requested.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction fromListPartial(n, list, hasStrings) {\r\n  var ret;\r\n  if (n < list.head.data.length) {\r\n    // slice is the same for buffers and strings\r\n    ret = list.head.data.slice(0, n);\r\n    list.head.data = list.head.data.slice(n);\r\n  } else if (n === list.head.data.length) {\r\n    // first chunk is a perfect match\r\n    ret = list.shift();\r\n  } else {\r\n    // result spans more than one buffer\r\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\r\n  }\r\n  return ret;\r\n}\r\n\r\n// Copies a specified amount of characters from the list of buffered data\r\n// chunks.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction copyFromBufferString(n, list) {\r\n  var p = list.head;\r\n  var c = 1;\r\n  var ret = p.data;\r\n  n -= ret.length;\r\n  while (p = p.next) {\r\n    var str = p.data;\r\n    var nb = n > str.length ? str.length : n;\r\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\r\n    n -= nb;\r\n    if (n === 0) {\r\n      if (nb === str.length) {\r\n        ++c;\r\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\r\n      } else {\r\n        list.head = p;\r\n        p.data = str.slice(nb);\r\n      }\r\n      break;\r\n    }\r\n    ++c;\r\n  }\r\n  list.length -= c;\r\n  return ret;\r\n}\r\n\r\n// Copies a specified amount of bytes from the list of buffered data chunks.\r\n// This function is designed to be inlinable, so please take care when making\r\n// changes to the function body.\r\nfunction copyFromBuffer(n, list) {\r\n  var ret = Buffer.allocUnsafe(n);\r\n  var p = list.head;\r\n  var c = 1;\r\n  p.data.copy(ret);\r\n  n -= p.data.length;\r\n  while (p = p.next) {\r\n    var buf = p.data;\r\n    var nb = n > buf.length ? buf.length : n;\r\n    buf.copy(ret, ret.length - n, 0, nb);\r\n    n -= nb;\r\n    if (n === 0) {\r\n      if (nb === buf.length) {\r\n        ++c;\r\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\r\n      } else {\r\n        list.head = p;\r\n        p.data = buf.slice(nb);\r\n      }\r\n      break;\r\n    }\r\n    ++c;\r\n  }\r\n  list.length -= c;\r\n  return ret;\r\n}\r\n\r\nfunction endReadable(stream) {\r\n  var state = stream._readableState;\r\n\r\n  // If we get here before consuming all the bytes, then that is a\r\n  // bug in node.  Should never happen.\r\n  if (state.length > 0) throw new Error(\'"endReadable()" called on non-empty stream\');\r\n\r\n  if (!state.endEmitted) {\r\n    state.ended = true;\r\n    processNextTick(endReadableNT, state, stream);\r\n  }\r\n}\r\n\r\nfunction endReadableNT(state, stream) {\r\n  // Check that we didn\'t get one last unshift.\r\n  if (!state.endEmitted && state.length === 0) {\r\n    state.endEmitted = true;\r\n    stream.readable = false;\r\n    stream.emit(\'end\');\r\n  }\r\n}\r\n\r\nfunction forEach(xs, f) {\r\n  for (var i = 0, l = xs.length; i < l; i++) {\r\n    f(xs[i], i);\r\n  }\r\n}\r\n\r\nfunction indexOf(xs, x) {\r\n  for (var i = 0, l = xs.length; i < l; i++) {\r\n    if (xs[i] === x) return i;\r\n  }\r\n  return -1;\r\n}\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(5)))\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nmodule.exports = __webpack_require__(8).EventEmitter;\r\n\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n\r\n\r\n/*<replacement>*/\r\n\r\nvar processNextTick = __webpack_require__(6);\r\n/*</replacement>*/\r\n\r\n// undocumented cb() API, needed for core, not for public API\r\nfunction destroy(err, cb) {\r\n  var _this = this;\r\n\r\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\r\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\r\n\r\n  if (readableDestroyed || writableDestroyed) {\r\n    if (cb) {\r\n      cb(err);\r\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\r\n      processNextTick(emitErrorNT, this, err);\r\n    }\r\n    return;\r\n  }\r\n\r\n  // we set destroyed to true before firing error callbacks in order\r\n  // to make it re-entrance safe in case destroy() is called within callbacks\r\n\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = true;\r\n  }\r\n\r\n  // if this is a duplex stream mark the writable part as destroyed as well\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = true;\r\n  }\r\n\r\n  this._destroy(err || null, function (err) {\r\n    if (!cb && err) {\r\n      processNextTick(emitErrorNT, _this, err);\r\n      if (_this._writableState) {\r\n        _this._writableState.errorEmitted = true;\r\n      }\r\n    } else if (cb) {\r\n      cb(err);\r\n    }\r\n  });\r\n}\r\n\r\nfunction undestroy() {\r\n  if (this._readableState) {\r\n    this._readableState.destroyed = false;\r\n    this._readableState.reading = false;\r\n    this._readableState.ended = false;\r\n    this._readableState.endEmitted = false;\r\n  }\r\n\r\n  if (this._writableState) {\r\n    this._writableState.destroyed = false;\r\n    this._writableState.ended = false;\r\n    this._writableState.ending = false;\r\n    this._writableState.finished = false;\r\n    this._writableState.errorEmitted = false;\r\n  }\r\n}\r\n\r\nfunction emitErrorNT(self, err) {\r\n  self.emit(\'error\', err);\r\n}\r\n\r\nmodule.exports = {\r\n  destroy: destroy,\r\n  undestroy: undestroy\r\n};\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// a transform stream is a readable/writable stream where you do\r\n// something with the data.  Sometimes it\'s called a "filter",\r\n// but that\'s not a great name for it, since that implies a thing where\r\n// some bits pass through, and others are simply ignored.  (That would\r\n// be a valid example of a transform, of course.)\r\n//\r\n// While the output is causally related to the input, it\'s not a\r\n// necessarily symmetric or synchronous transformation.  For example,\r\n// a zlib stream might take multiple plain-text writes(), and then\r\n// emit a single compressed chunk some time in the future.\r\n//\r\n// Here\'s how this works:\r\n//\r\n// The Transform stream has all the aspects of the readable and writable\r\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\r\n// internally, and returns false if there\'s a lot of pending writes\r\n// buffered up.  When you call read(), that calls _read(n) until\r\n// there\'s enough pending readable data buffered up.\r\n//\r\n// In a transform stream, the written data is placed in a buffer.  When\r\n// _read(n) is called, it transforms the queued up data, calling the\r\n// buffered _write cb\'s as it consumes chunks.  If consuming a single\r\n// written chunk would result in multiple output chunks, then the first\r\n// outputted bit calls the readcb, and subsequent chunks just go into\r\n// the read buffer, and will cause it to emit \'readable\' if necessary.\r\n//\r\n// This way, back-pressure is actually determined by the reading side,\r\n// since _read has to be called to start processing a new chunk.  However,\r\n// a pathological inflate type of transform can cause excessive buffering\r\n// here.  For example, imagine a stream where every byte of input is\r\n// interpreted as an integer from 0-255, and then results in that many\r\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\r\n// 1kb of data being output.  In this case, you could write a very small\r\n// amount of input, and end up with a very large amount of output.  In\r\n// such a pathological inflating mechanism, there\'d be no way to tell\r\n// the system to stop doing the transform.  A single 4MB write could\r\n// cause the system to run out of memory.\r\n//\r\n// However, even in such a pathological case, only a single written chunk\r\n// would be consumed, and then the rest would wait (un-transformed) until\r\n// the results of the previous transformed chunk were consumed.\r\n\r\n\r\n\r\nmodule.exports = Transform;\r\n\r\nvar Duplex = __webpack_require__(0);\r\n\r\n/*<replacement>*/\r\nvar util = __webpack_require__(3);\r\nutil.inherits = __webpack_require__(1);\r\n/*</replacement>*/\r\n\r\nutil.inherits(Transform, Duplex);\r\n\r\nfunction TransformState(stream) {\r\n  this.afterTransform = function (er, data) {\r\n    return afterTransform(stream, er, data);\r\n  };\r\n\r\n  this.needTransform = false;\r\n  this.transforming = false;\r\n  this.writecb = null;\r\n  this.writechunk = null;\r\n  this.writeencoding = null;\r\n}\r\n\r\nfunction afterTransform(stream, er, data) {\r\n  var ts = stream._transformState;\r\n  ts.transforming = false;\r\n\r\n  var cb = ts.writecb;\r\n\r\n  if (!cb) {\r\n    return stream.emit(\'error\', new Error(\'write callback called multiple times\'));\r\n  }\r\n\r\n  ts.writechunk = null;\r\n  ts.writecb = null;\r\n\r\n  if (data !== null && data !== undefined) stream.push(data);\r\n\r\n  cb(er);\r\n\r\n  var rs = stream._readableState;\r\n  rs.reading = false;\r\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\r\n    stream._read(rs.highWaterMark);\r\n  }\r\n}\r\n\r\nfunction Transform(options) {\r\n  if (!(this instanceof Transform)) return new Transform(options);\r\n\r\n  Duplex.call(this, options);\r\n\r\n  this._transformState = new TransformState(this);\r\n\r\n  var stream = this;\r\n\r\n  // start out asking for a readable event once data is transformed.\r\n  this._readableState.needReadable = true;\r\n\r\n  // we have implemented the _read method, and done the other things\r\n  // that Readable wants before the first _read call, so unset the\r\n  // sync guard flag.\r\n  this._readableState.sync = false;\r\n\r\n  if (options) {\r\n    if (typeof options.transform === \'function\') this._transform = options.transform;\r\n\r\n    if (typeof options.flush === \'function\') this._flush = options.flush;\r\n  }\r\n\r\n  // When the writable side finishes, then flush out anything remaining.\r\n  this.once(\'prefinish\', function () {\r\n    if (typeof this._flush === \'function\') this._flush(function (er, data) {\r\n      done(stream, er, data);\r\n    });else done(stream);\r\n  });\r\n}\r\n\r\nTransform.prototype.push = function (chunk, encoding) {\r\n  this._transformState.needTransform = false;\r\n  return Duplex.prototype.push.call(this, chunk, encoding);\r\n};\r\n\r\n// This is the part where you do stuff!\r\n// override this function in implementation classes.\r\n// \'chunk\' is an input chunk.\r\n//\r\n// Call `push(newChunk)` to pass along transformed output\r\n// to the readable side.  You may call \'push\' zero or more times.\r\n//\r\n// Call `cb(err)` when you are done with this chunk.  If you pass\r\n// an error, then that\'ll put the hurt on the whole operation.  If you\r\n// never call cb(), then you\'ll never get another chunk.\r\nTransform.prototype._transform = function (chunk, encoding, cb) {\r\n  throw new Error(\'_transform() is not implemented\');\r\n};\r\n\r\nTransform.prototype._write = function (chunk, encoding, cb) {\r\n  var ts = this._transformState;\r\n  ts.writecb = cb;\r\n  ts.writechunk = chunk;\r\n  ts.writeencoding = encoding;\r\n  if (!ts.transforming) {\r\n    var rs = this._readableState;\r\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\r\n  }\r\n};\r\n\r\n// Doesn\'t matter what the args are here.\r\n// _transform does all the work.\r\n// That we got here means that the readable side wants more data.\r\nTransform.prototype._read = function (n) {\r\n  var ts = this._transformState;\r\n\r\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\r\n    ts.transforming = true;\r\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\r\n  } else {\r\n    // mark that we need a transform, so that any data that comes in\r\n    // will get processed, now that we\'ve asked for it.\r\n    ts.needTransform = true;\r\n  }\r\n};\r\n\r\nTransform.prototype._destroy = function (err, cb) {\r\n  var _this = this;\r\n\r\n  Duplex.prototype._destroy.call(this, err, function (err2) {\r\n    cb(err2);\r\n    _this.emit(\'close\');\r\n  });\r\n};\r\n\r\nfunction done(stream, er, data) {\r\n  if (er) return stream.emit(\'error\', er);\r\n\r\n  if (data !== null && data !== undefined) stream.push(data);\r\n\r\n  // if there\'s nothing in the write buffer, then that means\r\n  // that nothing more will ever be provided\r\n  var ws = stream._writableState;\r\n  var ts = stream._transformState;\r\n\r\n  if (ws.length) throw new Error(\'Calling transform done when ws.length != 0\');\r\n\r\n  if (ts.transforming) throw new Error(\'Calling transform done when still transforming\');\r\n\r\n  return stream.push(null);\r\n}\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nvar helper = __webpack_require__(12);\r\nvar isArray = __webpack_require__(13).isArray;\r\n\r\nvar currentElement, currentElementName;\r\n\r\nfunction validateOptions(userOptions) {\r\n  var options = helper.copyOptions(userOptions);\r\n  helper.ensureFlagExists(\'ignoreDeclaration\', options);\r\n  helper.ensureFlagExists(\'ignoreInstruction\', options);\r\n  helper.ensureFlagExists(\'ignoreAttributes\', options);\r\n  helper.ensureFlagExists(\'ignoreText\', options);\r\n  helper.ensureFlagExists(\'ignoreComment\', options);\r\n  helper.ensureFlagExists(\'ignoreCdata\', options);\r\n  helper.ensureFlagExists(\'ignoreDoctype\', options);\r\n  helper.ensureFlagExists(\'compact\', options);\r\n  helper.ensureFlagExists(\'indentText\', options);\r\n  helper.ensureFlagExists(\'indentCdata\', options);\r\n  helper.ensureFlagExists(\'indentAttributes\', options);\r\n  helper.ensureFlagExists(\'indentInstruction\', options);\r\n  helper.ensureFlagExists(\'fullTagEmptyElement\', options);\r\n  helper.ensureFlagExists(\'noQuotesForNativeAttributes\', options);\r\n  helper.ensureSpacesExists(options);\r\n  if (typeof options.spaces === \'number\') {\r\n    options.spaces = Array(options.spaces + 1).join(\' \');\r\n  }\r\n  helper.ensureKeyExists(\'declaration\', options);\r\n  helper.ensureKeyExists(\'instruction\', options);\r\n  helper.ensureKeyExists(\'attributes\', options);\r\n  helper.ensureKeyExists(\'text\', options);\r\n  helper.ensureKeyExists(\'comment\', options);\r\n  helper.ensureKeyExists(\'cdata\', options);\r\n  helper.ensureKeyExists(\'doctype\', options);\r\n  helper.ensureKeyExists(\'type\', options);\r\n  helper.ensureKeyExists(\'name\', options);\r\n  helper.ensureKeyExists(\'elements\', options);\r\n  helper.checkFnExists(\'doctype\', options);\r\n  helper.checkFnExists(\'instruction\', options);\r\n  helper.checkFnExists(\'cdata\', options);\r\n  helper.checkFnExists(\'comment\', options);\r\n  helper.checkFnExists(\'text\', options);\r\n  helper.checkFnExists(\'instructionName\', options);\r\n  helper.checkFnExists(\'elementName\', options);\r\n  helper.checkFnExists(\'attributeName\', options);\r\n  helper.checkFnExists(\'attributeValue\', options);\r\n  helper.checkFnExists(\'attributes\', options);\r\n  helper.checkFnExists(\'fullTagEmptyElement\', options);\r\n  return options;\r\n}\r\n\r\nfunction writeIndentation(options, depth, firstLine) {\r\n  return (!firstLine && options.spaces ? \'\\n\' : \'\') + Array(depth + 1).join(options.spaces);\r\n}\r\n\r\nfunction writeAttributes(attributes, options, depth) {\r\n  if (options.ignoreAttributes) {\r\n    return \'\';\r\n  }\r\n  if (\'attributesFn\' in options) {\r\n    attributes = options.attributesFn(attributes, currentElementName, currentElement);\r\n  }\r\n  var key, attr, attrName, quote, result = \'\';\r\n  for (key in attributes) {\r\n    if (attributes.hasOwnProperty(key)) {\r\n      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== \'string\' ? \'\' : \'"\';\r\n      attr = \'\' + attributes[key]; // ensure number and boolean are converted to String\r\n      attr = attr.replace(/"/g, \'&quot;\');\r\n      attrName = \'attributeNameFn\' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;\r\n      result += (options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : \' \');\r\n      result += attrName + \'=\' + quote + (\'attributeValueFn\' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote;\r\n    }\r\n  }\r\n  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {\r\n    result += writeIndentation(options, depth, false);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction writeDeclaration(declaration, options, depth) {\r\n  currentElement = declaration;\r\n  currentElementName = \'xml\';\r\n  return options.ignoreDeclaration ? \'\' :  \'<?\' + \'xml\' + writeAttributes(declaration[options.attributesKey], options, depth) + \'?>\';\r\n}\r\n\r\nfunction writeInstruction(instruction, options, depth) {\r\n  if (options.ignoreInstruction) {\r\n    return \'\';\r\n  }\r\n  var key;\r\n  for (key in instruction) {\r\n    if (instruction.hasOwnProperty(key)) {\r\n      break;\r\n    }\r\n  }\r\n  var instructionName = \'instructionNameFn\' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;\r\n  if (typeof instruction[key] === \'object\') {\r\n    currentElement = instruction;\r\n    currentElementName = instructionName;\r\n    return \'<?\' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + \'?>\';\r\n  } else {\r\n    var instructionValue = instruction[key] ? instruction[key] : \'\';\r\n    if (\'instructionFn\' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);\r\n    return \'<?\' + instructionName + (instructionValue ? \' \' + instructionValue : \'\') + \'?>\';\r\n  }\r\n}\r\n\r\nfunction writeComment(comment, options) {\r\n  return options.ignoreComment ? \'\' : \'<!--\' + (\'commentFn\' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + \'-->\';\r\n}\r\n\r\nfunction writeCdata(cdata, options) {\r\n  return options.ignoreCdata ? \'\' : \'<![CDATA[\' + (\'cdataFn\' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata) + \']]>\';\r\n}\r\n\r\nfunction writeDoctype(doctype, options) {\r\n  return options.ignoreDoctype ? \'\' : \'<!DOCTYPE \' + (\'doctypeFn\' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + \'>\';\r\n}\r\n\r\nfunction writeText(text, options) {\r\n  if (options.ignoreText) return \'\';\r\n  text = \'\' + text; // ensure Number and Boolean are converted to String\r\n  text = text.replace(/&amp;/g, \'&\'); // desanitize to avoid double sanitization\r\n  text = text.replace(/&/g, \'&amp;\').replace(/</g, \'&lt;\').replace(/>/g, \'&gt;\');\r\n  return \'textFn\' in options ? options.textFn(text, currentElementName, currentElement) : text;\r\n}\r\n\r\nfunction hasContent(element, options) {\r\n  var i;\r\n  if (element.elements && element.elements.length) {\r\n    for (i = 0; i < element.elements.length; ++i) {\r\n      switch (element.elements[i][options.typeKey]) {\r\n      case \'text\':\r\n        if (options.indentText) {\r\n          return true;\r\n        }\r\n        break; // skip to next key\r\n      case \'cdata\':\r\n        if (options.indentCdata) {\r\n          return true;\r\n        }\r\n        break; // skip to next key\r\n      case \'instruction\':\r\n        if (options.indentInstruction) {\r\n          return true;\r\n        }\r\n        break; // skip to next key\r\n      case \'doctype\':\r\n      case \'comment\':\r\n      case \'element\':\r\n        return true;\r\n      default:\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction writeElement(element, options, depth) {\r\n  currentElement = element;\r\n  currentElementName = element.name;\r\n  var xml = \'\', elementName = \'elementNameFn\' in options ? options.elementNameFn(element.name, element) : element.name;\r\n  xml += \'<\' + elementName;\r\n  if (element[options.attributesKey]) {\r\n    xml += writeAttributes(element[options.attributesKey], options, depth);\r\n  }\r\n  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey][\'xml:space\'] === \'preserve\';\r\n  if (!withClosingTag) {\r\n    if (\'fullTagEmptyElementFn\' in options) {\r\n      withClosingTag = options.fullTagEmptyElementFn(element.name, element);\r\n    } else {\r\n      withClosingTag = options.fullTagEmptyElement;\r\n    }\r\n  }\r\n  if (withClosingTag) {\r\n    xml += \'>\';\r\n    if (element[options.elementsKey] && element[options.elementsKey].length) {\r\n      xml += writeElements(element[options.elementsKey], options, depth + 1);\r\n      currentElement = element;\r\n      currentElementName = element.name;\r\n    }\r\n    xml += options.spaces && hasContent(element, options) ? \'\\n\' + Array(depth + 1).join(options.spaces) : \'\';\r\n    xml += \'</\' + elementName + \'>\';\r\n  } else {\r\n    xml += \'/>\';\r\n  }\r\n  return xml;\r\n}\r\n\r\nfunction writeElements(elements, options, depth, firstLine) {\r\n  return elements.reduce(function (xml, element) {\r\n    var indent = writeIndentation(options, depth, firstLine && !xml);\r\n    switch (element.type) {\r\n    case \'element\': return xml + indent + writeElement(element, options, depth);\r\n    case \'comment\': return xml + indent + writeComment(element[options.commentKey], options);\r\n    case \'doctype\': return xml + indent + writeDoctype(element[options.doctypeKey], options);\r\n    case \'cdata\': return xml + (options.indentCdata ? indent : \'\') + writeCdata(element[options.cdataKey], options);\r\n    case \'text\': return xml + (options.indentText ? indent : \'\') + writeText(element[options.textKey], options);\r\n    case \'instruction\':\r\n      var instruction = {};\r\n      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];\r\n      return xml + (options.indentInstruction ? indent : \'\') + writeInstruction(instruction, options, depth);\r\n    }\r\n  }, \'\');\r\n}\r\n\r\nfunction hasContentCompact(element, options, anyContent) {\r\n  var key;\r\n  for (key in element) {\r\n    if (element.hasOwnProperty(key)) {\r\n      switch (key) {\r\n      case options.parentKey:\r\n      case options.attributesKey:\r\n        break; // skip to next key\r\n      case options.textKey:\r\n        if (options.indentText || anyContent) {\r\n          return true;\r\n        }\r\n        break; // skip to next key\r\n      case options.cdataKey:\r\n        if (options.indentCdata || anyContent) {\r\n          return true;\r\n        }\r\n        break; // skip to next key\r\n      case options.instructionKey:\r\n        if (options.indentInstruction || anyContent) {\r\n          return true;\r\n        }\r\n        break; // skip to next key\r\n      case options.doctypeKey:\r\n      case options.commentKey:\r\n        return true;\r\n      default:\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction writeElementCompact(element, name, options, depth, indent) {\r\n  currentElement = element;\r\n  currentElementName = name;\r\n  var elementName = \'elementNameFn\' in options ? options.elementNameFn(name, element) : name;\r\n  if (typeof element === \'undefined\' || element === null) {\r\n    return \'fullTagEmptyElementFn\' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? \'<\' + elementName + \'></\' + elementName + \'>\' : \'<\' + elementName + \'/>\';\r\n  }\r\n  var xml = \'\';\r\n  if (name) {\r\n    xml += \'<\' + elementName;\r\n    if (typeof element !== \'object\') {\r\n      xml += \'>\' + writeText(element,options) + \'</\' + elementName + \'>\';\r\n      return xml;\r\n    }\r\n    if (element[options.attributesKey]) {\r\n      xml += writeAttributes(element[options.attributesKey], options, depth);\r\n    }\r\n    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey][\'xml:space\'] === \'preserve\';\r\n    if (!withClosingTag) {\r\n      if (\'fullTagEmptyElementFn\' in options) {\r\n        withClosingTag = options.fullTagEmptyElementFn(name, element);\r\n      } else {\r\n        withClosingTag = options.fullTagEmptyElement;\r\n      }\r\n    }\r\n    if (withClosingTag) {\r\n      xml += \'>\';\r\n    } else {\r\n      xml += \'/>\';\r\n      return xml;\r\n    }\r\n  }\r\n  xml += writeElementsCompact(element, options, depth + 1, false);\r\n  currentElement = element;\r\n  currentElementName = name;\r\n  if (name) {\r\n    xml += (indent ? writeIndentation(options, depth, false) : \'\') + \'</\' + elementName + \'>\';\r\n  }\r\n  return xml;\r\n}\r\n\r\nfunction writeElementsCompact(element, options, depth, firstLine) {\r\n  var i, key, nodes, xml = \'\';\r\n  for (key in element) {\r\n    if (element.hasOwnProperty(key)) {\r\n      nodes = isArray(element[key]) ? element[key] : [element[key]];\r\n      for (i = 0; i < nodes.length; ++i) {\r\n        switch (key) {\r\n        case options.declarationKey: xml += writeDeclaration(nodes[i], options, depth); break;\r\n        case options.instructionKey: xml += (options.indentInstruction ? writeIndentation(options, depth, firstLine) : \'\') + writeInstruction(nodes[i], options, depth); break;\r\n        case options.attributesKey: case options.parentKey: break; // skip\r\n        case options.textKey: xml += (options.indentText ? writeIndentation(options, depth, firstLine) : \'\') + writeText(nodes[i], options); break;\r\n        case options.cdataKey: xml += (options.indentCdata ? writeIndentation(options, depth, firstLine) : \'\') + writeCdata(nodes[i], options); break;\r\n        case options.doctypeKey: xml += writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options); break;\r\n        case options.commentKey: xml += writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options); break;\r\n        default: xml += writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options));\r\n        }\r\n        firstLine = firstLine && !xml;\r\n      }\r\n    }\r\n  }\r\n  return xml;\r\n}\r\n\r\nmodule.exports = function (js, options) {\r\n  options = validateOptions(options);\r\n  var xml = \'\';\r\n  currentElement = js;\r\n  currentElementName = \'_root_\';\r\n  if (options.compact) {\r\n    xml = writeElementsCompact(js, options, 0, true);\r\n  } else {\r\n    if (js[options.declarationKey]) {\r\n      xml += writeDeclaration(js[options.declarationKey], options, 0);\r\n    }\r\n    if (js[options.elementsKey] && js[options.elementsKey].length) {\r\n      xml += writeElements(js[options.elementsKey], options, 0, !xml);\r\n    }\r\n  }\r\n  return xml;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/*jslint node:true */\r\n\r\nvar xml2js = __webpack_require__(14);\r\nvar xml2json = __webpack_require__(36);\r\nvar js2xml = __webpack_require__(20);\r\nvar json2xml = __webpack_require__(37);\r\n\r\nmodule.exports = {\r\n  xml2js: xml2js,\r\n  xml2json: xml2json,\r\n  js2xml: js2xml,\r\n  json2xml: json2xml\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(Buffer) {;(function (sax) { // wrapper for non-node envs\r\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\r\n  sax.SAXParser = SAXParser\r\n  sax.SAXStream = SAXStream\r\n  sax.createStream = createStream\r\n\r\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\r\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\r\n  // since that\'s the earliest that a buffer overrun could occur.  This way, checks are\r\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\r\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\r\n  // large string into write() might have undesirable effects, but this is manageable by\r\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\r\n  // edge case, result in creating at most one complete copy of the string passed in.\r\n  // Set to Infinity to have unlimited buffers.\r\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\r\n\r\n  var buffers = [\r\n    \'comment\', \'sgmlDecl\', \'textNode\', \'tagName\', \'doctype\',\r\n    \'procInstName\', \'procInstBody\', \'entity\', \'attribName\',\r\n    \'attribValue\', \'cdata\', \'script\'\r\n  ]\r\n\r\n  sax.EVENTS = [\r\n    \'text\',\r\n    \'processinginstruction\',\r\n    \'sgmldeclaration\',\r\n    \'doctype\',\r\n    \'comment\',\r\n    \'opentagstart\',\r\n    \'attribute\',\r\n    \'opentag\',\r\n    \'closetag\',\r\n    \'opencdata\',\r\n    \'cdata\',\r\n    \'closecdata\',\r\n    \'error\',\r\n    \'end\',\r\n    \'ready\',\r\n    \'script\',\r\n    \'opennamespace\',\r\n    \'closenamespace\'\r\n  ]\r\n\r\n  function SAXParser (strict, opt) {\r\n    if (!(this instanceof SAXParser)) {\r\n      return new SAXParser(strict, opt)\r\n    }\r\n\r\n    var parser = this\r\n    clearBuffers(parser)\r\n    parser.q = parser.c = \'\'\r\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\r\n    parser.opt = opt || {}\r\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\r\n    parser.looseCase = parser.opt.lowercase ? \'toLowerCase\' : \'toUpperCase\'\r\n    parser.tags = []\r\n    parser.closed = parser.closedRoot = parser.sawRoot = false\r\n    parser.tag = parser.error = null\r\n    parser.strict = !!strict\r\n    parser.noscript = !!(strict || parser.opt.noscript)\r\n    parser.state = S.BEGIN\r\n    parser.strictEntities = parser.opt.strictEntities\r\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\r\n    parser.attribList = []\r\n\r\n    // namespaces form a prototype chain.\r\n    // it always points at the current tag,\r\n    // which protos to its parent tag.\r\n    if (parser.opt.xmlns) {\r\n      parser.ns = Object.create(rootNS)\r\n    }\r\n\r\n    // mostly just for error reporting\r\n    parser.trackPosition = parser.opt.position !== false\r\n    if (parser.trackPosition) {\r\n      parser.position = parser.line = parser.column = 0\r\n    }\r\n    emit(parser, \'onready\')\r\n  }\r\n\r\n  if (!Object.create) {\r\n    Object.create = function (o) {\r\n      function F () {}\r\n      F.prototype = o\r\n      var newf = new F()\r\n      return newf\r\n    }\r\n  }\r\n\r\n  if (!Object.keys) {\r\n    Object.keys = function (o) {\r\n      var a = []\r\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\r\n      return a\r\n    }\r\n  }\r\n\r\n  function checkBufferLength (parser) {\r\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\r\n    var maxActual = 0\r\n    for (var i = 0, l = buffers.length; i < l; i++) {\r\n      var len = parser[buffers[i]].length\r\n      if (len > maxAllowed) {\r\n        // Text/cdata nodes can get big, and since they\'re buffered,\r\n        // we can get here under normal conditions.\r\n        // Avoid issues by emitting the text node now,\r\n        // so at least it won\'t get any bigger.\r\n        switch (buffers[i]) {\r\n          case \'textNode\':\r\n            closeText(parser)\r\n            break\r\n\r\n          case \'cdata\':\r\n            emitNode(parser, \'oncdata\', parser.cdata)\r\n            parser.cdata = \'\'\r\n            break\r\n\r\n          case \'script\':\r\n            emitNode(parser, \'onscript\', parser.script)\r\n            parser.script = \'\'\r\n            break\r\n\r\n          default:\r\n            error(parser, \'Max buffer length exceeded: \' + buffers[i])\r\n        }\r\n      }\r\n      maxActual = Math.max(maxActual, len)\r\n    }\r\n    // schedule the next check for the earliest possible buffer overrun.\r\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\r\n    parser.bufferCheckPosition = m + parser.position\r\n  }\r\n\r\n  function clearBuffers (parser) {\r\n    for (var i = 0, l = buffers.length; i < l; i++) {\r\n      parser[buffers[i]] = \'\'\r\n    }\r\n  }\r\n\r\n  function flushBuffers (parser) {\r\n    closeText(parser)\r\n    if (parser.cdata !== \'\') {\r\n      emitNode(parser, \'oncdata\', parser.cdata)\r\n      parser.cdata = \'\'\r\n    }\r\n    if (parser.script !== \'\') {\r\n      emitNode(parser, \'onscript\', parser.script)\r\n      parser.script = \'\'\r\n    }\r\n  }\r\n\r\n  SAXParser.prototype = {\r\n    end: function () { end(this) },\r\n    write: write,\r\n    resume: function () { this.error = null; return this },\r\n    close: function () { return this.write(null) },\r\n    flush: function () { flushBuffers(this) }\r\n  }\r\n\r\n  var Stream\r\n  try {\r\n    Stream = __webpack_require__(25).Stream\r\n  } catch (ex) {\r\n    Stream = function () {}\r\n  }\r\n\r\n  var streamWraps = sax.EVENTS.filter(function (ev) {\r\n    return ev !== \'error\' && ev !== \'end\'\r\n  })\r\n\r\n  function createStream (strict, opt) {\r\n    return new SAXStream(strict, opt)\r\n  }\r\n\r\n  function SAXStream (strict, opt) {\r\n    if (!(this instanceof SAXStream)) {\r\n      return new SAXStream(strict, opt)\r\n    }\r\n\r\n    Stream.apply(this)\r\n\r\n    this._parser = new SAXParser(strict, opt)\r\n    this.writable = true\r\n    this.readable = true\r\n\r\n    var me = this\r\n\r\n    this._parser.onend = function () {\r\n      me.emit(\'end\')\r\n    }\r\n\r\n    this._parser.onerror = function (er) {\r\n      me.emit(\'error\', er)\r\n\r\n      // if didn\'t throw, then means error was handled.\r\n      // go ahead and clear error, so we can write again.\r\n      me._parser.error = null\r\n    }\r\n\r\n    this._decoder = null\r\n\r\n    streamWraps.forEach(function (ev) {\r\n      Object.defineProperty(me, \'on\' + ev, {\r\n        get: function () {\r\n          return me._parser[\'on\' + ev]\r\n        },\r\n        set: function (h) {\r\n          if (!h) {\r\n            me.removeAllListeners(ev)\r\n            me._parser[\'on\' + ev] = h\r\n            return h\r\n          }\r\n          me.on(ev, h)\r\n        },\r\n        enumerable: true,\r\n        configurable: false\r\n      })\r\n    })\r\n  }\r\n\r\n  SAXStream.prototype = Object.create(Stream.prototype, {\r\n    constructor: {\r\n      value: SAXStream\r\n    }\r\n  })\r\n\r\n  SAXStream.prototype.write = function (data) {\r\n    if (typeof Buffer === \'function\' &&\r\n      typeof Buffer.isBuffer === \'function\' &&\r\n      Buffer.isBuffer(data)) {\r\n      if (!this._decoder) {\r\n        var SD = __webpack_require__(11).StringDecoder\r\n        this._decoder = new SD(\'utf8\')\r\n      }\r\n      data = this._decoder.write(data)\r\n    }\r\n\r\n    this._parser.write(data.toString())\r\n    this.emit(\'data\', data)\r\n    return true\r\n  }\r\n\r\n  SAXStream.prototype.end = function (chunk) {\r\n    if (chunk && chunk.length) {\r\n      this.write(chunk)\r\n    }\r\n    this._parser.end()\r\n    return true\r\n  }\r\n\r\n  SAXStream.prototype.on = function (ev, handler) {\r\n    var me = this\r\n    if (!me._parser[\'on\' + ev] && streamWraps.indexOf(ev) !== -1) {\r\n      me._parser[\'on\' + ev] = function () {\r\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\r\n        args.splice(0, 0, ev)\r\n        me.emit.apply(me, args)\r\n      }\r\n    }\r\n\r\n    return Stream.prototype.on.call(me, ev, handler)\r\n  }\r\n\r\n  // this really needs to be replaced with character classes.\r\n  // XML allows all manner of ridiculous numbers and digits.\r\n  var CDATA = \'[CDATA[\'\r\n  var DOCTYPE = \'DOCTYPE\'\r\n  var XML_NAMESPACE = \'http://www.w3.org/XML/1998/namespace\'\r\n  var XMLNS_NAMESPACE = \'http://www.w3.org/2000/xmlns/\'\r\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\r\n\r\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\r\n  // This implementation works on strings, a single character at a time\r\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\r\n  // without a significant breaking change to either this  parser, or the\r\n  // JavaScript language.  Implementation of an emoji-capable xml parser\r\n  // is left as an exercise for the reader.\r\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\r\n\r\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\r\n\r\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\r\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\r\n\r\n  function isWhitespace (c) {\r\n    return c === \' \' || c === \'\\n\' || c === \'\\r\' || c === \'\\t\'\r\n  }\r\n\r\n  function isQuote (c) {\r\n    return c === \'"\' || c === \'\\\'\'\r\n  }\r\n\r\n  function isAttribEnd (c) {\r\n    return c === \'>\' || isWhitespace(c)\r\n  }\r\n\r\n  function isMatch (regex, c) {\r\n    return regex.test(c)\r\n  }\r\n\r\n  function notMatch (regex, c) {\r\n    return !isMatch(regex, c)\r\n  }\r\n\r\n  var S = 0\r\n  sax.STATE = {\r\n    BEGIN: S++, // leading byte order mark or whitespace\r\n    BEGIN_WHITESPACE: S++, // leading whitespace\r\n    TEXT: S++, // general stuff\r\n    TEXT_ENTITY: S++, // &amp and such.\r\n    OPEN_WAKA: S++, // <\r\n    SGML_DECL: S++, // <!BLARG\r\n    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar\r\n    DOCTYPE: S++, // <!DOCTYPE\r\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah\r\n    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...\r\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo\r\n    COMMENT_STARTING: S++, // <!-\r\n    COMMENT: S++, // <!--\r\n    COMMENT_ENDING: S++, // <!-- blah -\r\n    COMMENT_ENDED: S++, // <!-- blah --\r\n    CDATA: S++, // <![CDATA[ something\r\n    CDATA_ENDING: S++, // ]\r\n    CDATA_ENDING_2: S++, // ]]\r\n    PROC_INST: S++, // <?hi\r\n    PROC_INST_BODY: S++, // <?hi there\r\n    PROC_INST_ENDING: S++, // <?hi "there" ?\r\n    OPEN_TAG: S++, // <strong\r\n    OPEN_TAG_SLASH: S++, // <strong /\r\n    ATTRIB: S++, // <a\r\n    ATTRIB_NAME: S++, // <a foo\r\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\r\n    ATTRIB_VALUE: S++, // <a foo=\r\n    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar\r\n    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"\r\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\r\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"\r\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\r\n    CLOSE_TAG: S++, // </a\r\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\r\n    SCRIPT: S++, // <script> ...\r\n    SCRIPT_ENDING: S++ // <script> ... <\r\n  }\r\n\r\n  sax.XML_ENTITIES = {\r\n    \'amp\': \'&\',\r\n    \'gt\': \'>\',\r\n    \'lt\': \'<\',\r\n    \'quot\': \'"\',\r\n    \'apos\': "\'"\r\n  }\r\n\r\n  sax.ENTITIES = {\r\n    \'amp\': \'&\',\r\n    \'gt\': \'>\',\r\n    \'lt\': \'<\',\r\n    \'quot\': \'"\',\r\n    \'apos\': "\'",\r\n    \'AElig\': 198,\r\n    \'Aacute\': 193,\r\n    \'Acirc\': 194,\r\n    \'Agrave\': 192,\r\n    \'Aring\': 197,\r\n    \'Atilde\': 195,\r\n    \'Auml\': 196,\r\n    \'Ccedil\': 199,\r\n    \'ETH\': 208,\r\n    \'Eacute\': 201,\r\n    \'Ecirc\': 202,\r\n    \'Egrave\': 200,\r\n    \'Euml\': 203,\r\n    \'Iacute\': 205,\r\n    \'Icirc\': 206,\r\n    \'Igrave\': 204,\r\n    \'Iuml\': 207,\r\n    \'Ntilde\': 209,\r\n    \'Oacute\': 211,\r\n    \'Ocirc\': 212,\r\n    \'Ograve\': 210,\r\n    \'Oslash\': 216,\r\n    \'Otilde\': 213,\r\n    \'Ouml\': 214,\r\n    \'THORN\': 222,\r\n    \'Uacute\': 218,\r\n    \'Ucirc\': 219,\r\n    \'Ugrave\': 217,\r\n    \'Uuml\': 220,\r\n    \'Yacute\': 221,\r\n    \'aacute\': 225,\r\n    \'acirc\': 226,\r\n    \'aelig\': 230,\r\n    \'agrave\': 224,\r\n    \'aring\': 229,\r\n    \'atilde\': 227,\r\n    \'auml\': 228,\r\n    \'ccedil\': 231,\r\n    \'eacute\': 233,\r\n    \'ecirc\': 234,\r\n    \'egrave\': 232,\r\n    \'eth\': 240,\r\n    \'euml\': 235,\r\n    \'iacute\': 237,\r\n    \'icirc\': 238,\r\n    \'igrave\': 236,\r\n    \'iuml\': 239,\r\n    \'ntilde\': 241,\r\n    \'oacute\': 243,\r\n    \'ocirc\': 244,\r\n    \'ograve\': 242,\r\n    \'oslash\': 248,\r\n    \'otilde\': 245,\r\n    \'ouml\': 246,\r\n    \'szlig\': 223,\r\n    \'thorn\': 254,\r\n    \'uacute\': 250,\r\n    \'ucirc\': 251,\r\n    \'ugrave\': 249,\r\n    \'uuml\': 252,\r\n    \'yacute\': 253,\r\n    \'yuml\': 255,\r\n    \'copy\': 169,\r\n    \'reg\': 174,\r\n    \'nbsp\': 160,\r\n    \'iexcl\': 161,\r\n    \'cent\': 162,\r\n    \'pound\': 163,\r\n    \'curren\': 164,\r\n    \'yen\': 165,\r\n    \'brvbar\': 166,\r\n    \'sect\': 167,\r\n    \'uml\': 168,\r\n    \'ordf\': 170,\r\n    \'laquo\': 171,\r\n    \'not\': 172,\r\n    \'shy\': 173,\r\n    \'macr\': 175,\r\n    \'deg\': 176,\r\n    \'plusmn\': 177,\r\n    \'sup1\': 185,\r\n    \'sup2\': 178,\r\n    \'sup3\': 179,\r\n    \'acute\': 180,\r\n    \'micro\': 181,\r\n    \'para\': 182,\r\n    \'middot\': 183,\r\n    \'cedil\': 184,\r\n    \'ordm\': 186,\r\n    \'raquo\': 187,\r\n    \'frac14\': 188,\r\n    \'frac12\': 189,\r\n    \'frac34\': 190,\r\n    \'iquest\': 191,\r\n    \'times\': 215,\r\n    \'divide\': 247,\r\n    \'OElig\': 338,\r\n    \'oelig\': 339,\r\n    \'Scaron\': 352,\r\n    \'scaron\': 353,\r\n    \'Yuml\': 376,\r\n    \'fnof\': 402,\r\n    \'circ\': 710,\r\n    \'tilde\': 732,\r\n    \'Alpha\': 913,\r\n    \'Beta\': 914,\r\n    \'Gamma\': 915,\r\n    \'Delta\': 916,\r\n    \'Epsilon\': 917,\r\n    \'Zeta\': 918,\r\n    \'Eta\': 919,\r\n    \'Theta\': 920,\r\n    \'Iota\': 921,\r\n    \'Kappa\': 922,\r\n    \'Lambda\': 923,\r\n    \'Mu\': 924,\r\n    \'Nu\': 925,\r\n    \'Xi\': 926,\r\n    \'Omicron\': 927,\r\n    \'Pi\': 928,\r\n    \'Rho\': 929,\r\n    \'Sigma\': 931,\r\n    \'Tau\': 932,\r\n    \'Upsilon\': 933,\r\n    \'Phi\': 934,\r\n    \'Chi\': 935,\r\n    \'Psi\': 936,\r\n    \'Omega\': 937,\r\n    \'alpha\': 945,\r\n    \'beta\': 946,\r\n    \'gamma\': 947,\r\n    \'delta\': 948,\r\n    \'epsilon\': 949,\r\n    \'zeta\': 950,\r\n    \'eta\': 951,\r\n    \'theta\': 952,\r\n    \'iota\': 953,\r\n    \'kappa\': 954,\r\n    \'lambda\': 955,\r\n    \'mu\': 956,\r\n    \'nu\': 957,\r\n    \'xi\': 958,\r\n    \'omicron\': 959,\r\n    \'pi\': 960,\r\n    \'rho\': 961,\r\n    \'sigmaf\': 962,\r\n    \'sigma\': 963,\r\n    \'tau\': 964,\r\n    \'upsilon\': 965,\r\n    \'phi\': 966,\r\n    \'chi\': 967,\r\n    \'psi\': 968,\r\n    \'omega\': 969,\r\n    \'thetasym\': 977,\r\n    \'upsih\': 978,\r\n    \'piv\': 982,\r\n    \'ensp\': 8194,\r\n    \'emsp\': 8195,\r\n    \'thinsp\': 8201,\r\n    \'zwnj\': 8204,\r\n    \'zwj\': 8205,\r\n    \'lrm\': 8206,\r\n    \'rlm\': 8207,\r\n    \'ndash\': 8211,\r\n    \'mdash\': 8212,\r\n    \'lsquo\': 8216,\r\n    \'rsquo\': 8217,\r\n    \'sbquo\': 8218,\r\n    \'ldquo\': 8220,\r\n    \'rdquo\': 8221,\r\n    \'bdquo\': 8222,\r\n    \'dagger\': 8224,\r\n    \'Dagger\': 8225,\r\n    \'bull\': 8226,\r\n    \'hellip\': 8230,\r\n    \'permil\': 8240,\r\n    \'prime\': 8242,\r\n    \'Prime\': 8243,\r\n    \'lsaquo\': 8249,\r\n    \'rsaquo\': 8250,\r\n    \'oline\': 8254,\r\n    \'frasl\': 8260,\r\n    \'euro\': 8364,\r\n    \'image\': 8465,\r\n    \'weierp\': 8472,\r\n    \'real\': 8476,\r\n    \'trade\': 8482,\r\n    \'alefsym\': 8501,\r\n    \'larr\': 8592,\r\n    \'uarr\': 8593,\r\n    \'rarr\': 8594,\r\n    \'darr\': 8595,\r\n    \'harr\': 8596,\r\n    \'crarr\': 8629,\r\n    \'lArr\': 8656,\r\n    \'uArr\': 8657,\r\n    \'rArr\': 8658,\r\n    \'dArr\': 8659,\r\n    \'hArr\': 8660,\r\n    \'forall\': 8704,\r\n    \'part\': 8706,\r\n    \'exist\': 8707,\r\n    \'empty\': 8709,\r\n    \'nabla\': 8711,\r\n    \'isin\': 8712,\r\n    \'notin\': 8713,\r\n    \'ni\': 8715,\r\n    \'prod\': 8719,\r\n    \'sum\': 8721,\r\n    \'minus\': 8722,\r\n    \'lowast\': 8727,\r\n    \'radic\': 8730,\r\n    \'prop\': 8733,\r\n    \'infin\': 8734,\r\n    \'ang\': 8736,\r\n    \'and\': 8743,\r\n    \'or\': 8744,\r\n    \'cap\': 8745,\r\n    \'cup\': 8746,\r\n    \'int\': 8747,\r\n    \'there4\': 8756,\r\n    \'sim\': 8764,\r\n    \'cong\': 8773,\r\n    \'asymp\': 8776,\r\n    \'ne\': 8800,\r\n    \'equiv\': 8801,\r\n    \'le\': 8804,\r\n    \'ge\': 8805,\r\n    \'sub\': 8834,\r\n    \'sup\': 8835,\r\n    \'nsub\': 8836,\r\n    \'sube\': 8838,\r\n    \'supe\': 8839,\r\n    \'oplus\': 8853,\r\n    \'otimes\': 8855,\r\n    \'perp\': 8869,\r\n    \'sdot\': 8901,\r\n    \'lceil\': 8968,\r\n    \'rceil\': 8969,\r\n    \'lfloor\': 8970,\r\n    \'rfloor\': 8971,\r\n    \'lang\': 9001,\r\n    \'rang\': 9002,\r\n    \'loz\': 9674,\r\n    \'spades\': 9824,\r\n    \'clubs\': 9827,\r\n    \'hearts\': 9829,\r\n    \'diams\': 9830\r\n  }\r\n\r\n  Object.keys(sax.ENTITIES).forEach(function (key) {\r\n    var e = sax.ENTITIES[key]\r\n    var s = typeof e === \'number\' ? String.fromCharCode(e) : e\r\n    sax.ENTITIES[key] = s\r\n  })\r\n\r\n  for (var s in sax.STATE) {\r\n    sax.STATE[sax.STATE[s]] = s\r\n  }\r\n\r\n  // shorthand\r\n  S = sax.STATE\r\n\r\n  function emit (parser, event, data) {\r\n    parser[event] && parser[event](data)\r\n  }\r\n\r\n  function emitNode (parser, nodeType, data) {\r\n    if (parser.textNode) closeText(parser)\r\n    emit(parser, nodeType, data)\r\n  }\r\n\r\n  function closeText (parser) {\r\n    parser.textNode = textopts(parser.opt, parser.textNode)\r\n    if (parser.textNode) emit(parser, \'ontext\', parser.textNode)\r\n    parser.textNode = \'\'\r\n  }\r\n\r\n  function textopts (opt, text) {\r\n    if (opt.trim) text = text.trim()\r\n    if (opt.normalize) text = text.replace(/\\s+/g, \' \')\r\n    return text\r\n  }\r\n\r\n  function error (parser, er) {\r\n    closeText(parser)\r\n    if (parser.trackPosition) {\r\n      er += \'\\nLine: \' + parser.line +\r\n        \'\\nColumn: \' + parser.column +\r\n        \'\\nChar: \' + parser.c\r\n    }\r\n    er = new Error(er)\r\n    parser.error = er\r\n    emit(parser, \'onerror\', er)\r\n    return parser\r\n  }\r\n\r\n  function end (parser) {\r\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, \'Unclosed root tag\')\r\n    if ((parser.state !== S.BEGIN) &&\r\n      (parser.state !== S.BEGIN_WHITESPACE) &&\r\n      (parser.state !== S.TEXT)) {\r\n      error(parser, \'Unexpected end\')\r\n    }\r\n    closeText(parser)\r\n    parser.c = \'\'\r\n    parser.closed = true\r\n    emit(parser, \'onend\')\r\n    SAXParser.call(parser, parser.strict, parser.opt)\r\n    return parser\r\n  }\r\n\r\n  function strictFail (parser, message) {\r\n    if (typeof parser !== \'object\' || !(parser instanceof SAXParser)) {\r\n      throw new Error(\'bad call to strictFail\')\r\n    }\r\n    if (parser.strict) {\r\n      error(parser, message)\r\n    }\r\n  }\r\n\r\n  function newTag (parser) {\r\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\r\n    var parent = parser.tags[parser.tags.length - 1] || parser\r\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\r\n\r\n    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"\r\n    if (parser.opt.xmlns) {\r\n      tag.ns = parent.ns\r\n    }\r\n    parser.attribList.length = 0\r\n    emitNode(parser, \'onopentagstart\', tag)\r\n  }\r\n\r\n  function qname (name, attribute) {\r\n    var i = name.indexOf(\':\')\r\n    var qualName = i < 0 ? [ \'\', name ] : name.split(\':\')\r\n    var prefix = qualName[0]\r\n    var local = qualName[1]\r\n\r\n    // <x "xmlns"="http://foo">\r\n    if (attribute && name === \'xmlns\') {\r\n      prefix = \'xmlns\'\r\n      local = \'\'\r\n    }\r\n\r\n    return { prefix: prefix, local: local }\r\n  }\r\n\r\n  function attrib (parser) {\r\n    if (!parser.strict) {\r\n      parser.attribName = parser.attribName[parser.looseCase]()\r\n    }\r\n\r\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\r\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\r\n      parser.attribName = parser.attribValue = \'\'\r\n      return\r\n    }\r\n\r\n    if (parser.opt.xmlns) {\r\n      var qn = qname(parser.attribName, true)\r\n      var prefix = qn.prefix\r\n      var local = qn.local\r\n\r\n      if (prefix === \'xmlns\') {\r\n        // namespace binding attribute. push the binding into scope\r\n        if (local === \'xml\' && parser.attribValue !== XML_NAMESPACE) {\r\n          strictFail(parser,\r\n            \'xml: prefix must be bound to \' + XML_NAMESPACE + \'\\n\' +\r\n            \'Actual: \' + parser.attribValue)\r\n        } else if (local === \'xmlns\' && parser.attribValue !== XMLNS_NAMESPACE) {\r\n          strictFail(parser,\r\n            \'xmlns: prefix must be bound to \' + XMLNS_NAMESPACE + \'\\n\' +\r\n            \'Actual: \' + parser.attribValue)\r\n        } else {\r\n          var tag = parser.tag\r\n          var parent = parser.tags[parser.tags.length - 1] || parser\r\n          if (tag.ns === parent.ns) {\r\n            tag.ns = Object.create(parent.ns)\r\n          }\r\n          tag.ns[local] = parser.attribValue\r\n        }\r\n      }\r\n\r\n      // defer onattribute events until all attributes have been seen\r\n      // so any new bindings can take effect. preserve attribute order\r\n      // so deferred events can be emitted in document order\r\n      parser.attribList.push([parser.attribName, parser.attribValue])\r\n    } else {\r\n      // in non-xmlns mode, we can emit the event right away\r\n      parser.tag.attributes[parser.attribName] = parser.attribValue\r\n      emitNode(parser, \'onattribute\', {\r\n        name: parser.attribName,\r\n        value: parser.attribValue\r\n      })\r\n    }\r\n\r\n    parser.attribName = parser.attribValue = \'\'\r\n  }\r\n\r\n  function openTag (parser, selfClosing) {\r\n    if (parser.opt.xmlns) {\r\n      // emit namespace binding events\r\n      var tag = parser.tag\r\n\r\n      // add namespace info to tag\r\n      var qn = qname(parser.tagName)\r\n      tag.prefix = qn.prefix\r\n      tag.local = qn.local\r\n      tag.uri = tag.ns[qn.prefix] || \'\'\r\n\r\n      if (tag.prefix && !tag.uri) {\r\n        strictFail(parser, \'Unbound namespace prefix: \' +\r\n          JSON.stringify(parser.tagName))\r\n        tag.uri = qn.prefix\r\n      }\r\n\r\n      var parent = parser.tags[parser.tags.length - 1] || parser\r\n      if (tag.ns && parent.ns !== tag.ns) {\r\n        Object.keys(tag.ns).forEach(function (p) {\r\n          emitNode(parser, \'onopennamespace\', {\r\n            prefix: p,\r\n            uri: tag.ns[p]\r\n          })\r\n        })\r\n      }\r\n\r\n      // handle deferred onattribute events\r\n      // Note: do not apply default ns to attributes:\r\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\r\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\r\n        var nv = parser.attribList[i]\r\n        var name = nv[0]\r\n        var value = nv[1]\r\n        var qualName = qname(name, true)\r\n        var prefix = qualName.prefix\r\n        var local = qualName.local\r\n        var uri = prefix === \'\' ? \'\' : (tag.ns[prefix] || \'\')\r\n        var a = {\r\n          name: name,\r\n          value: value,\r\n          prefix: prefix,\r\n          local: local,\r\n          uri: uri\r\n        }\r\n\r\n        // if there\'s any attributes with an undefined namespace,\r\n        // then fail on them now.\r\n        if (prefix && prefix !== \'xmlns\' && !uri) {\r\n          strictFail(parser, \'Unbound namespace prefix: \' +\r\n            JSON.stringify(prefix))\r\n          a.uri = prefix\r\n        }\r\n        parser.tag.attributes[name] = a\r\n        emitNode(parser, \'onattribute\', a)\r\n      }\r\n      parser.attribList.length = 0\r\n    }\r\n\r\n    parser.tag.isSelfClosing = !!selfClosing\r\n\r\n    // process the tag\r\n    parser.sawRoot = true\r\n    parser.tags.push(parser.tag)\r\n    emitNode(parser, \'onopentag\', parser.tag)\r\n    if (!selfClosing) {\r\n      // special case for <script> in non-strict mode.\r\n      if (!parser.noscript && parser.tagName.toLowerCase() === \'script\') {\r\n        parser.state = S.SCRIPT\r\n      } else {\r\n        parser.state = S.TEXT\r\n      }\r\n      parser.tag = null\r\n      parser.tagName = \'\'\r\n    }\r\n    parser.attribName = parser.attribValue = \'\'\r\n    parser.attribList.length = 0\r\n  }\r\n\r\n  function closeTag (parser) {\r\n    if (!parser.tagName) {\r\n      strictFail(parser, \'Weird empty close tag.\')\r\n      parser.textNode += \'</>\'\r\n      parser.state = S.TEXT\r\n      return\r\n    }\r\n\r\n    if (parser.script) {\r\n      if (parser.tagName !== \'script\') {\r\n        parser.script += \'</\' + parser.tagName + \'>\'\r\n        parser.tagName = \'\'\r\n        parser.state = S.SCRIPT\r\n        return\r\n      }\r\n      emitNode(parser, \'onscript\', parser.script)\r\n      parser.script = \'\'\r\n    }\r\n\r\n    // first make sure that the closing tag actually exists.\r\n    // <a><b></c></b></a> will close everything, otherwise.\r\n    var t = parser.tags.length\r\n    var tagName = parser.tagName\r\n    if (!parser.strict) {\r\n      tagName = tagName[parser.looseCase]()\r\n    }\r\n    var closeTo = tagName\r\n    while (t--) {\r\n      var close = parser.tags[t]\r\n      if (close.name !== closeTo) {\r\n        // fail the first time in strict mode\r\n        strictFail(parser, \'Unexpected close tag\')\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n\r\n    // didn\'t find it.  we already failed for strict, so just abort.\r\n    if (t < 0) {\r\n      strictFail(parser, \'Unmatched closing tag: \' + parser.tagName)\r\n      parser.textNode += \'</\' + parser.tagName + \'>\'\r\n      parser.state = S.TEXT\r\n      return\r\n    }\r\n    parser.tagName = tagName\r\n    var s = parser.tags.length\r\n    while (s-- > t) {\r\n      var tag = parser.tag = parser.tags.pop()\r\n      parser.tagName = parser.tag.name\r\n      emitNode(parser, \'onclosetag\', parser.tagName)\r\n\r\n      var x = {}\r\n      for (var i in tag.ns) {\r\n        x[i] = tag.ns[i]\r\n      }\r\n\r\n      var parent = parser.tags[parser.tags.length - 1] || parser\r\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\r\n        // remove namespace bindings introduced by tag\r\n        Object.keys(tag.ns).forEach(function (p) {\r\n          var n = tag.ns[p]\r\n          emitNode(parser, \'onclosenamespace\', { prefix: p, uri: n })\r\n        })\r\n      }\r\n    }\r\n    if (t === 0) parser.closedRoot = true\r\n    parser.tagName = parser.attribValue = parser.attribName = \'\'\r\n    parser.attribList.length = 0\r\n    parser.state = S.TEXT\r\n  }\r\n\r\n  function parseEntity (parser) {\r\n    var entity = parser.entity\r\n    var entityLC = entity.toLowerCase()\r\n    var num\r\n    var numStr = \'\'\r\n\r\n    if (parser.ENTITIES[entity]) {\r\n      return parser.ENTITIES[entity]\r\n    }\r\n    if (parser.ENTITIES[entityLC]) {\r\n      return parser.ENTITIES[entityLC]\r\n    }\r\n    entity = entityLC\r\n    if (entity.charAt(0) === \'#\') {\r\n      if (entity.charAt(1) === \'x\') {\r\n        entity = entity.slice(2)\r\n        num = parseInt(entity, 16)\r\n        numStr = num.toString(16)\r\n      } else {\r\n        entity = entity.slice(1)\r\n        num = parseInt(entity, 10)\r\n        numStr = num.toString(10)\r\n      }\r\n    }\r\n    entity = entity.replace(/^0+/, \'\')\r\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\r\n      strictFail(parser, \'Invalid character entity\')\r\n      return \'&\' + parser.entity + \';\'\r\n    }\r\n\r\n    return String.fromCodePoint(num)\r\n  }\r\n\r\n  function beginWhiteSpace (parser, c) {\r\n    if (c === \'<\') {\r\n      parser.state = S.OPEN_WAKA\r\n      parser.startTagPosition = parser.position\r\n    } else if (!isWhitespace(c)) {\r\n      // have to process this as a text node.\r\n      // weird, but happens.\r\n      strictFail(parser, \'Non-whitespace before first tag.\')\r\n      parser.textNode = c\r\n      parser.state = S.TEXT\r\n    }\r\n  }\r\n\r\n  function charAt (chunk, i) {\r\n    var result = \'\'\r\n    if (i < chunk.length) {\r\n      result = chunk.charAt(i)\r\n    }\r\n    return result\r\n  }\r\n\r\n  function write (chunk) {\r\n    var parser = this\r\n    if (this.error) {\r\n      throw this.error\r\n    }\r\n    if (parser.closed) {\r\n      return error(parser,\r\n        \'Cannot write after close. Assign an onready handler.\')\r\n    }\r\n    if (chunk === null) {\r\n      return end(parser)\r\n    }\r\n    if (typeof chunk === \'object\') {\r\n      chunk = chunk.toString()\r\n    }\r\n    var i = 0\r\n    var c = \'\'\r\n    while (true) {\r\n      c = charAt(chunk, i++)\r\n      parser.c = c\r\n\r\n      if (!c) {\r\n        break\r\n      }\r\n\r\n      if (parser.trackPosition) {\r\n        parser.position++\r\n        if (c === \'\\n\') {\r\n          parser.line++\r\n          parser.column = 0\r\n        } else {\r\n          parser.column++\r\n        }\r\n      }\r\n\r\n      switch (parser.state) {\r\n        case S.BEGIN:\r\n          parser.state = S.BEGIN_WHITESPACE\r\n          if (c === \'\\uFEFF\') {\r\n            continue\r\n          }\r\n          beginWhiteSpace(parser, c)\r\n          continue\r\n\r\n        case S.BEGIN_WHITESPACE:\r\n          beginWhiteSpace(parser, c)\r\n          continue\r\n\r\n        case S.TEXT:\r\n          if (parser.sawRoot && !parser.closedRoot) {\r\n            var starti = i - 1\r\n            while (c && c !== \'<\' && c !== \'&\') {\r\n              c = charAt(chunk, i++)\r\n              if (c && parser.trackPosition) {\r\n                parser.position++\r\n                if (c === \'\\n\') {\r\n                  parser.line++\r\n                  parser.column = 0\r\n                } else {\r\n                  parser.column++\r\n                }\r\n              }\r\n            }\r\n            parser.textNode += chunk.substring(starti, i - 1)\r\n          }\r\n          if (c === \'<\' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\r\n            parser.state = S.OPEN_WAKA\r\n            parser.startTagPosition = parser.position\r\n          } else {\r\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\r\n              strictFail(parser, \'Text data outside of root node.\')\r\n            }\r\n            if (c === \'&\') {\r\n              parser.state = S.TEXT_ENTITY\r\n            } else {\r\n              parser.textNode += c\r\n            }\r\n          }\r\n          continue\r\n\r\n        case S.SCRIPT:\r\n          // only non-strict\r\n          if (c === \'<\') {\r\n            parser.state = S.SCRIPT_ENDING\r\n          } else {\r\n            parser.script += c\r\n          }\r\n          continue\r\n\r\n        case S.SCRIPT_ENDING:\r\n          if (c === \'/\') {\r\n            parser.state = S.CLOSE_TAG\r\n          } else {\r\n            parser.script += \'<\' + c\r\n            parser.state = S.SCRIPT\r\n          }\r\n          continue\r\n\r\n        case S.OPEN_WAKA:\r\n          // either a /, ?, !, or text is coming next.\r\n          if (c === \'!\') {\r\n            parser.state = S.SGML_DECL\r\n            parser.sgmlDecl = \'\'\r\n          } else if (isWhitespace(c)) {\r\n            // wait for it...\r\n          } else if (isMatch(nameStart, c)) {\r\n            parser.state = S.OPEN_TAG\r\n            parser.tagName = c\r\n          } else if (c === \'/\') {\r\n            parser.state = S.CLOSE_TAG\r\n            parser.tagName = \'\'\r\n          } else if (c === \'?\') {\r\n            parser.state = S.PROC_INST\r\n            parser.procInstName = parser.procInstBody = \'\'\r\n          } else {\r\n            strictFail(parser, \'Unencoded <\')\r\n            // if there was some whitespace, then add that in.\r\n            if (parser.startTagPosition + 1 < parser.position) {\r\n              var pad = parser.position - parser.startTagPosition\r\n              c = new Array(pad).join(\' \') + c\r\n            }\r\n            parser.textNode += \'<\' + c\r\n            parser.state = S.TEXT\r\n          }\r\n          continue\r\n\r\n        case S.SGML_DECL:\r\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\r\n            emitNode(parser, \'onopencdata\')\r\n            parser.state = S.CDATA\r\n            parser.sgmlDecl = \'\'\r\n            parser.cdata = \'\'\r\n          } else if (parser.sgmlDecl + c === \'--\') {\r\n            parser.state = S.COMMENT\r\n            parser.comment = \'\'\r\n            parser.sgmlDecl = \'\'\r\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\r\n            parser.state = S.DOCTYPE\r\n            if (parser.doctype || parser.sawRoot) {\r\n              strictFail(parser,\r\n                \'Inappropriately located doctype declaration\')\r\n            }\r\n            parser.doctype = \'\'\r\n            parser.sgmlDecl = \'\'\r\n          } else if (c === \'>\') {\r\n            emitNode(parser, \'onsgmldeclaration\', parser.sgmlDecl)\r\n            parser.sgmlDecl = \'\'\r\n            parser.state = S.TEXT\r\n          } else if (isQuote(c)) {\r\n            parser.state = S.SGML_DECL_QUOTED\r\n            parser.sgmlDecl += c\r\n          } else {\r\n            parser.sgmlDecl += c\r\n          }\r\n          continue\r\n\r\n        case S.SGML_DECL_QUOTED:\r\n          if (c === parser.q) {\r\n            parser.state = S.SGML_DECL\r\n            parser.q = \'\'\r\n          }\r\n          parser.sgmlDecl += c\r\n          continue\r\n\r\n        case S.DOCTYPE:\r\n          if (c === \'>\') {\r\n            parser.state = S.TEXT\r\n            emitNode(parser, \'ondoctype\', parser.doctype)\r\n            parser.doctype = true // just remember that we saw it.\r\n          } else {\r\n            parser.doctype += c\r\n            if (c === \'[\') {\r\n              parser.state = S.DOCTYPE_DTD\r\n            } else if (isQuote(c)) {\r\n              parser.state = S.DOCTYPE_QUOTED\r\n              parser.q = c\r\n            }\r\n          }\r\n          continue\r\n\r\n        case S.DOCTYPE_QUOTED:\r\n          parser.doctype += c\r\n          if (c === parser.q) {\r\n            parser.q = \'\'\r\n            parser.state = S.DOCTYPE\r\n          }\r\n          continue\r\n\r\n        case S.DOCTYPE_DTD:\r\n          parser.doctype += c\r\n          if (c === \']\') {\r\n            parser.state = S.DOCTYPE\r\n          } else if (isQuote(c)) {\r\n            parser.state = S.DOCTYPE_DTD_QUOTED\r\n            parser.q = c\r\n          }\r\n          continue\r\n\r\n        case S.DOCTYPE_DTD_QUOTED:\r\n          parser.doctype += c\r\n          if (c === parser.q) {\r\n            parser.state = S.DOCTYPE_DTD\r\n            parser.q = \'\'\r\n          }\r\n          continue\r\n\r\n        case S.COMMENT:\r\n          if (c === \'-\') {\r\n            parser.state = S.COMMENT_ENDING\r\n          } else {\r\n            parser.comment += c\r\n          }\r\n          continue\r\n\r\n        case S.COMMENT_ENDING:\r\n          if (c === \'-\') {\r\n            parser.state = S.COMMENT_ENDED\r\n            parser.comment = textopts(parser.opt, parser.comment)\r\n            if (parser.comment) {\r\n              emitNode(parser, \'oncomment\', parser.comment)\r\n            }\r\n            parser.comment = \'\'\r\n          } else {\r\n            parser.comment += \'-\' + c\r\n            parser.state = S.COMMENT\r\n          }\r\n          continue\r\n\r\n        case S.COMMENT_ENDED:\r\n          if (c !== \'>\') {\r\n            strictFail(parser, \'Malformed comment\')\r\n            // allow <!-- blah -- bloo --> in non-strict mode,\r\n            // which is a comment of " blah -- bloo "\r\n            parser.comment += \'--\' + c\r\n            parser.state = S.COMMENT\r\n          } else {\r\n            parser.state = S.TEXT\r\n          }\r\n          continue\r\n\r\n        case S.CDATA:\r\n          if (c === \']\') {\r\n            parser.state = S.CDATA_ENDING\r\n          } else {\r\n            parser.cdata += c\r\n          }\r\n          continue\r\n\r\n        case S.CDATA_ENDING:\r\n          if (c === \']\') {\r\n            parser.state = S.CDATA_ENDING_2\r\n          } else {\r\n            parser.cdata += \']\' + c\r\n            parser.state = S.CDATA\r\n          }\r\n          continue\r\n\r\n        case S.CDATA_ENDING_2:\r\n          if (c === \'>\') {\r\n            if (parser.cdata) {\r\n              emitNode(parser, \'oncdata\', parser.cdata)\r\n            }\r\n            emitNode(parser, \'onclosecdata\')\r\n            parser.cdata = \'\'\r\n            parser.state = S.TEXT\r\n          } else if (c === \']\') {\r\n            parser.cdata += \']\'\r\n          } else {\r\n            parser.cdata += \']]\' + c\r\n            parser.state = S.CDATA\r\n          }\r\n          continue\r\n\r\n        case S.PROC_INST:\r\n          if (c === \'?\') {\r\n            parser.state = S.PROC_INST_ENDING\r\n          } else if (isWhitespace(c)) {\r\n            parser.state = S.PROC_INST_BODY\r\n          } else {\r\n            parser.procInstName += c\r\n          }\r\n          continue\r\n\r\n        case S.PROC_INST_BODY:\r\n          if (!parser.procInstBody && isWhitespace(c)) {\r\n            continue\r\n          } else if (c === \'?\') {\r\n            parser.state = S.PROC_INST_ENDING\r\n          } else {\r\n            parser.procInstBody += c\r\n          }\r\n          continue\r\n\r\n        case S.PROC_INST_ENDING:\r\n          if (c === \'>\') {\r\n            emitNode(parser, \'onprocessinginstruction\', {\r\n              name: parser.procInstName,\r\n              body: parser.procInstBody\r\n            })\r\n            parser.procInstName = parser.procInstBody = \'\'\r\n            parser.state = S.TEXT\r\n          } else {\r\n            parser.procInstBody += \'?\' + c\r\n            parser.state = S.PROC_INST_BODY\r\n          }\r\n          continue\r\n\r\n        case S.OPEN_TAG:\r\n          if (isMatch(nameBody, c)) {\r\n            parser.tagName += c\r\n          } else {\r\n            newTag(parser)\r\n            if (c === \'>\') {\r\n              openTag(parser)\r\n            } else if (c === \'/\') {\r\n              parser.state = S.OPEN_TAG_SLASH\r\n            } else {\r\n              if (!isWhitespace(c)) {\r\n                strictFail(parser, \'Invalid character in tag name\')\r\n              }\r\n              parser.state = S.ATTRIB\r\n            }\r\n          }\r\n          continue\r\n\r\n        case S.OPEN_TAG_SLASH:\r\n          if (c === \'>\') {\r\n            openTag(parser, true)\r\n            closeTag(parser)\r\n          } else {\r\n            strictFail(parser, \'Forward-slash in opening tag not followed by >\')\r\n            parser.state = S.ATTRIB\r\n          }\r\n          continue\r\n\r\n        case S.ATTRIB:\r\n          // haven\'t read the attribute name yet.\r\n          if (isWhitespace(c)) {\r\n            continue\r\n          } else if (c === \'>\') {\r\n            openTag(parser)\r\n          } else if (c === \'/\') {\r\n            parser.state = S.OPEN_TAG_SLASH\r\n          } else if (isMatch(nameStart, c)) {\r\n            parser.attribName = c\r\n            parser.attribValue = \'\'\r\n            parser.state = S.ATTRIB_NAME\r\n          } else {\r\n            strictFail(parser, \'Invalid attribute name\')\r\n          }\r\n          continue\r\n\r\n        case S.ATTRIB_NAME:\r\n          if (c === \'=\') {\r\n            parser.state = S.ATTRIB_VALUE\r\n          } else if (c === \'>\') {\r\n            strictFail(parser, \'Attribute without value\')\r\n            parser.attribValue = parser.attribName\r\n            attrib(parser)\r\n            openTag(parser)\r\n          } else if (isWhitespace(c)) {\r\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\r\n          } else if (isMatch(nameBody, c)) {\r\n            parser.attribName += c\r\n          } else {\r\n            strictFail(parser, \'Invalid attribute name\')\r\n          }\r\n          continue\r\n\r\n        case S.ATTRIB_NAME_SAW_WHITE:\r\n          if (c === \'=\') {\r\n            parser.state = S.ATTRIB_VALUE\r\n          } else if (isWhitespace(c)) {\r\n            continue\r\n          } else {\r\n            strictFail(parser, \'Attribute without value\')\r\n            parser.tag.attributes[parser.attribName] = \'\'\r\n            parser.attribValue = \'\'\r\n            emitNode(parser, \'onattribute\', {\r\n              name: parser.attribName,\r\n              value: \'\'\r\n            })\r\n            parser.attribName = \'\'\r\n            if (c === \'>\') {\r\n              openTag(parser)\r\n            } else if (isMatch(nameStart, c)) {\r\n              parser.attribName = c\r\n              parser.state = S.ATTRIB_NAME\r\n            } else {\r\n              strictFail(parser, \'Invalid attribute name\')\r\n              parser.state = S.ATTRIB\r\n            }\r\n          }\r\n          continue\r\n\r\n        case S.ATTRIB_VALUE:\r\n          if (isWhitespace(c)) {\r\n            continue\r\n          } else if (isQuote(c)) {\r\n            parser.q = c\r\n            parser.state = S.ATTRIB_VALUE_QUOTED\r\n          } else {\r\n            strictFail(parser, \'Unquoted attribute value\')\r\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\r\n            parser.attribValue = c\r\n          }\r\n          continue\r\n\r\n        case S.ATTRIB_VALUE_QUOTED:\r\n          if (c !== parser.q) {\r\n            if (c === \'&\') {\r\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\r\n            } else {\r\n              parser.attribValue += c\r\n            }\r\n            continue\r\n          }\r\n          attrib(parser)\r\n          parser.q = \'\'\r\n          parser.state = S.ATTRIB_VALUE_CLOSED\r\n          continue\r\n\r\n        case S.ATTRIB_VALUE_CLOSED:\r\n          if (isWhitespace(c)) {\r\n            parser.state = S.ATTRIB\r\n          } else if (c === \'>\') {\r\n            openTag(parser)\r\n          } else if (c === \'/\') {\r\n            parser.state = S.OPEN_TAG_SLASH\r\n          } else if (isMatch(nameStart, c)) {\r\n            strictFail(parser, \'No whitespace between attributes\')\r\n            parser.attribName = c\r\n            parser.attribValue = \'\'\r\n            parser.state = S.ATTRIB_NAME\r\n          } else {\r\n            strictFail(parser, \'Invalid attribute name\')\r\n          }\r\n          continue\r\n\r\n        case S.ATTRIB_VALUE_UNQUOTED:\r\n          if (!isAttribEnd(c)) {\r\n            if (c === \'&\') {\r\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\r\n            } else {\r\n              parser.attribValue += c\r\n            }\r\n            continue\r\n          }\r\n          attrib(parser)\r\n          if (c === \'>\') {\r\n            openTag(parser)\r\n          } else {\r\n            parser.state = S.ATTRIB\r\n          }\r\n          continue\r\n\r\n        case S.CLOSE_TAG:\r\n          if (!parser.tagName) {\r\n            if (isWhitespace(c)) {\r\n              continue\r\n            } else if (notMatch(nameStart, c)) {\r\n              if (parser.script) {\r\n                parser.script += \'</\' + c\r\n                parser.state = S.SCRIPT\r\n              } else {\r\n                strictFail(parser, \'Invalid tagname in closing tag.\')\r\n              }\r\n            } else {\r\n              parser.tagName = c\r\n            }\r\n          } else if (c === \'>\') {\r\n            closeTag(parser)\r\n          } else if (isMatch(nameBody, c)) {\r\n            parser.tagName += c\r\n          } else if (parser.script) {\r\n            parser.script += \'</\' + parser.tagName\r\n            parser.tagName = \'\'\r\n            parser.state = S.SCRIPT\r\n          } else {\r\n            if (!isWhitespace(c)) {\r\n              strictFail(parser, \'Invalid tagname in closing tag\')\r\n            }\r\n            parser.state = S.CLOSE_TAG_SAW_WHITE\r\n          }\r\n          continue\r\n\r\n        case S.CLOSE_TAG_SAW_WHITE:\r\n          if (isWhitespace(c)) {\r\n            continue\r\n          }\r\n          if (c === \'>\') {\r\n            closeTag(parser)\r\n          } else {\r\n            strictFail(parser, \'Invalid characters in closing tag\')\r\n          }\r\n          continue\r\n\r\n        case S.TEXT_ENTITY:\r\n        case S.ATTRIB_VALUE_ENTITY_Q:\r\n        case S.ATTRIB_VALUE_ENTITY_U:\r\n          var returnState\r\n          var buffer\r\n          switch (parser.state) {\r\n            case S.TEXT_ENTITY:\r\n              returnState = S.TEXT\r\n              buffer = \'textNode\'\r\n              break\r\n\r\n            case S.ATTRIB_VALUE_ENTITY_Q:\r\n              returnState = S.ATTRIB_VALUE_QUOTED\r\n              buffer = \'attribValue\'\r\n              break\r\n\r\n            case S.ATTRIB_VALUE_ENTITY_U:\r\n              returnState = S.ATTRIB_VALUE_UNQUOTED\r\n              buffer = \'attribValue\'\r\n              break\r\n          }\r\n\r\n          if (c === \';\') {\r\n            parser[buffer] += parseEntity(parser)\r\n            parser.entity = \'\'\r\n            parser.state = returnState\r\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\r\n            parser.entity += c\r\n          } else {\r\n            strictFail(parser, \'Invalid character in entity name\')\r\n            parser[buffer] += \'&\' + parser.entity + c\r\n            parser.entity = \'\'\r\n            parser.state = returnState\r\n          }\r\n\r\n          continue\r\n\r\n        default:\r\n          throw new Error(parser, \'Unknown state: \' + parser.state)\r\n      }\r\n    } // while\r\n\r\n    if (parser.position >= parser.bufferCheckPosition) {\r\n      checkBufferLength(parser)\r\n    }\r\n    return parser\r\n  }\r\n\r\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\r\n  /* istanbul ignore next */\r\n  if (!String.fromCodePoint) {\r\n    (function () {\r\n      var stringFromCharCode = String.fromCharCode\r\n      var floor = Math.floor\r\n      var fromCodePoint = function () {\r\n        var MAX_SIZE = 0x4000\r\n        var codeUnits = []\r\n        var highSurrogate\r\n        var lowSurrogate\r\n        var index = -1\r\n        var length = arguments.length\r\n        if (!length) {\r\n          return \'\'\r\n        }\r\n        var result = \'\'\r\n        while (++index < length) {\r\n          var codePoint = Number(arguments[index])\r\n          if (\r\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\r\n            codePoint < 0 || // not a valid Unicode code point\r\n            codePoint > 0x10FFFF || // not a valid Unicode code point\r\n            floor(codePoint) !== codePoint // not an integer\r\n          ) {\r\n            throw RangeError(\'Invalid code point: \' + codePoint)\r\n          }\r\n          if (codePoint <= 0xFFFF) { // BMP code point\r\n            codeUnits.push(codePoint)\r\n          } else { // Astral code point; split in surrogate halves\r\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n            codePoint -= 0x10000\r\n            highSurrogate = (codePoint >> 10) + 0xD800\r\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\r\n            codeUnits.push(highSurrogate, lowSurrogate)\r\n          }\r\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\r\n            result += stringFromCharCode.apply(null, codeUnits)\r\n            codeUnits.length = 0\r\n          }\r\n        }\r\n        return result\r\n      }\r\n      /* istanbul ignore next */\r\n      if (Object.defineProperty) {\r\n        Object.defineProperty(String, \'fromCodePoint\', {\r\n          value: fromCodePoint,\r\n          configurable: true,\r\n          writable: true\r\n        })\r\n      } else {\r\n        String.fromCodePoint = fromCodePoint\r\n      }\r\n    }())\r\n  }\r\n})( false ? this.sax = {} : exports)\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n\r\n\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== \'undefined\' ? Uint8Array : Array\r\n\r\nvar code = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\nrevLookup[\'-\'.charCodeAt(0)] = 62\r\nrevLookup[\'_\'.charCodeAt(0)] = 63\r\n\r\nfunction placeHoldersCount (b64) {\r\n  var len = b64.length\r\n  if (len % 4 > 0) {\r\n    throw new Error(\'Invalid string. Length must be a multiple of 4\')\r\n  }\r\n\r\n  // the number of equal signs (place holders)\r\n  // if there are two placeholders, than the two characters before it\r\n  // represent one byte\r\n  // if there is only one, then the three characters before it represent 2 bytes\r\n  // this is just a cheap hack to not do indexOf twice\r\n  return b64[len - 2] === \'=\' ? 2 : b64[len - 1] === \'=\' ? 1 : 0\r\n}\r\n\r\nfunction byteLength (b64) {\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var i, l, tmp, placeHolders, arr\r\n  var len = b64.length\r\n  placeHolders = placeHoldersCount(b64)\r\n\r\n  arr = new Arr((len * 3 / 4) - placeHolders)\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  l = placeHolders > 0 ? len - 4 : len\r\n\r\n  var L = 0\r\n\r\n  for (i = 0; i < l; i += 4) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\r\n    arr[L++] = (tmp >> 16) & 0xFF\r\n    arr[L++] = (tmp >> 8) & 0xFF\r\n    arr[L++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHolders === 2) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[L++] = tmp & 0xFF\r\n  } else if (placeHolders === 1) {\r\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[L++] = (tmp >> 8) & 0xFF\r\n    arr[L++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join(\'\')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var output = \'\'\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we\'ll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    output += lookup[tmp >> 2]\r\n    output += lookup[(tmp << 4) & 0x3F]\r\n    output += \'==\'\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\r\n    output += lookup[tmp >> 10]\r\n    output += lookup[(tmp >> 4) & 0x3F]\r\n    output += lookup[(tmp << 2) & 0x3F]\r\n    output += \'=\'\r\n  }\r\n\r\n  parts.push(output)\r\n\r\n  return parts.join(\'\')\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports) {\r\n\r\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n  var e, m\r\n  var eLen = nBytes * 8 - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var nBits = -7\r\n  var i = isLE ? (nBytes - 1) : 0\r\n  var d = isLE ? -1 : 1\r\n  var s = buffer[offset + i]\r\n\r\n  i += d\r\n\r\n  e = s & ((1 << (-nBits)) - 1)\r\n  s >>= (-nBits)\r\n  nBits += eLen\r\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  m = e & ((1 << (-nBits)) - 1)\r\n  e >>= (-nBits)\r\n  nBits += mLen\r\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n  if (e === 0) {\r\n    e = 1 - eBias\r\n  } else if (e === eMax) {\r\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n  } else {\r\n    m = m + Math.pow(2, mLen)\r\n    e = e - eBias\r\n  }\r\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n}\r\n\r\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n  var e, m, c\r\n  var eLen = nBytes * 8 - mLen - 1\r\n  var eMax = (1 << eLen) - 1\r\n  var eBias = eMax >> 1\r\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n  var i = isLE ? 0 : (nBytes - 1)\r\n  var d = isLE ? 1 : -1\r\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n  value = Math.abs(value)\r\n\r\n  if (isNaN(value) || value === Infinity) {\r\n    m = isNaN(value) ? 1 : 0\r\n    e = eMax\r\n  } else {\r\n    e = Math.floor(Math.log(value) / Math.LN2)\r\n    if (value * (c = Math.pow(2, -e)) < 1) {\r\n      e--\r\n      c *= 2\r\n    }\r\n    if (e + eBias >= 1) {\r\n      value += rt / c\r\n    } else {\r\n      value += rt * Math.pow(2, 1 - eBias)\r\n    }\r\n    if (value * c >= 2) {\r\n      e++\r\n      c /= 2\r\n    }\r\n\r\n    if (e + eBias >= eMax) {\r\n      m = 0\r\n      e = eMax\r\n    } else if (e + eBias >= 1) {\r\n      m = (value * c - 1) * Math.pow(2, mLen)\r\n      e = e + eBias\r\n    } else {\r\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n      e = 0\r\n    }\r\n  }\r\n\r\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n  e = (e << mLen) | m\r\n  eLen += mLen\r\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n  buffer[offset + i - d] |= s * 128\r\n}\r\n\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nmodule.exports = Stream;\r\n\r\nvar EE = __webpack_require__(8).EventEmitter;\r\nvar inherits = __webpack_require__(1);\r\n\r\ninherits(Stream, EE);\r\nStream.Readable = __webpack_require__(9);\r\nStream.Writable = __webpack_require__(32);\r\nStream.Duplex = __webpack_require__(33);\r\nStream.Transform = __webpack_require__(34);\r\nStream.PassThrough = __webpack_require__(35);\r\n\r\n// Backwards-compat with node 0.4.x\r\nStream.Stream = Stream;\r\n\r\n\r\n\r\n// old-style streams.  Note that the pipe method (the only relevant\r\n// part of this class) is overridden in the Readable class.\r\n\r\nfunction Stream() {\r\n  EE.call(this);\r\n}\r\n\r\nStream.prototype.pipe = function(dest, options) {\r\n  var source = this;\r\n\r\n  function ondata(chunk) {\r\n    if (dest.writable) {\r\n      if (false === dest.write(chunk) && source.pause) {\r\n        source.pause();\r\n      }\r\n    }\r\n  }\r\n\r\n  source.on(\'data\', ondata);\r\n\r\n  function ondrain() {\r\n    if (source.readable && source.resume) {\r\n      source.resume();\r\n    }\r\n  }\r\n\r\n  dest.on(\'drain\', ondrain);\r\n\r\n  // If the \'end\' option is not supplied, dest.end() will be called when\r\n  // source gets the \'end\' or \'close\' events.  Only dest.end() once.\r\n  if (!dest._isStdio && (!options || options.end !== false)) {\r\n    source.on(\'end\', onend);\r\n    source.on(\'close\', onclose);\r\n  }\r\n\r\n  var didOnEnd = false;\r\n  function onend() {\r\n    if (didOnEnd) return;\r\n    didOnEnd = true;\r\n\r\n    dest.end();\r\n  }\r\n\r\n\r\n  function onclose() {\r\n    if (didOnEnd) return;\r\n    didOnEnd = true;\r\n\r\n    if (typeof dest.destroy === \'function\') dest.destroy();\r\n  }\r\n\r\n  // don\'t leave dangling pipes when there are errors.\r\n  function onerror(er) {\r\n    cleanup();\r\n    if (EE.listenerCount(this, \'error\') === 0) {\r\n      throw er; // Unhandled stream error in pipe.\r\n    }\r\n  }\r\n\r\n  source.on(\'error\', onerror);\r\n  dest.on(\'error\', onerror);\r\n\r\n  // remove all the event listeners that were added.\r\n  function cleanup() {\r\n    source.removeListener(\'data\', ondata);\r\n    dest.removeListener(\'drain\', ondrain);\r\n\r\n    source.removeListener(\'end\', onend);\r\n    source.removeListener(\'close\', onclose);\r\n\r\n    source.removeListener(\'error\', onerror);\r\n    dest.removeListener(\'error\', onerror);\r\n\r\n    source.removeListener(\'end\', cleanup);\r\n    source.removeListener(\'close\', cleanup);\r\n\r\n    dest.removeListener(\'close\', cleanup);\r\n  }\r\n\r\n  source.on(\'end\', cleanup);\r\n  source.on(\'close\', cleanup);\r\n\r\n  dest.on(\'close\', cleanup);\r\n\r\n  dest.emit(\'pipe\', source);\r\n\r\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\r\n  return dest;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports) {\r\n\r\n/* (ignored) */\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n\r\n\r\n/*<replacement>*/\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\r\n\r\nvar Buffer = __webpack_require__(7).Buffer;\r\n/*</replacement>*/\r\n\r\nfunction copyBuffer(src, target, offset) {\r\n  src.copy(target, offset);\r\n}\r\n\r\nmodule.exports = function () {\r\n  function BufferList() {\r\n    _classCallCheck(this, BufferList);\r\n\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n\r\n  BufferList.prototype.push = function push(v) {\r\n    var entry = { data: v, next: null };\r\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\r\n    this.tail = entry;\r\n    ++this.length;\r\n  };\r\n\r\n  BufferList.prototype.unshift = function unshift(v) {\r\n    var entry = { data: v, next: this.head };\r\n    if (this.length === 0) this.tail = entry;\r\n    this.head = entry;\r\n    ++this.length;\r\n  };\r\n\r\n  BufferList.prototype.shift = function shift() {\r\n    if (this.length === 0) return;\r\n    var ret = this.head.data;\r\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\r\n    --this.length;\r\n    return ret;\r\n  };\r\n\r\n  BufferList.prototype.clear = function clear() {\r\n    this.head = this.tail = null;\r\n    this.length = 0;\r\n  };\r\n\r\n  BufferList.prototype.join = function join(s) {\r\n    if (this.length === 0) return \'\';\r\n    var p = this.head;\r\n    var ret = \'\' + p.data;\r\n    while (p = p.next) {\r\n      ret += s + p.data;\r\n    }return ret;\r\n  };\r\n\r\n  BufferList.prototype.concat = function concat(n) {\r\n    if (this.length === 0) return Buffer.alloc(0);\r\n    if (this.length === 1) return this.head.data;\r\n    var ret = Buffer.allocUnsafe(n >>> 0);\r\n    var p = this.head;\r\n    var i = 0;\r\n    while (p) {\r\n      copyBuffer(p.data, ret, i);\r\n      i += p.data.length;\r\n      p = p.next;\r\n    }\r\n    return ret;\r\n  };\r\n\r\n  return BufferList;\r\n}();\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nvar apply = Function.prototype.apply;\r\n\r\n// DOM APIs, for completeness\r\n\r\nexports.setTimeout = function() {\r\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\r\n};\r\nexports.setInterval = function() {\r\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\r\n};\r\nexports.clearTimeout =\r\nexports.clearInterval = function(timeout) {\r\n  if (timeout) {\r\n    timeout.close();\r\n  }\r\n};\r\n\r\nfunction Timeout(id, clearFn) {\r\n  this._id = id;\r\n  this._clearFn = clearFn;\r\n}\r\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\r\nTimeout.prototype.close = function() {\r\n  this._clearFn.call(window, this._id);\r\n};\r\n\r\n// Does not start the time, just sets up the members needed.\r\nexports.enroll = function(item, msecs) {\r\n  clearTimeout(item._idleTimeoutId);\r\n  item._idleTimeout = msecs;\r\n};\r\n\r\nexports.unenroll = function(item) {\r\n  clearTimeout(item._idleTimeoutId);\r\n  item._idleTimeout = -1;\r\n};\r\n\r\nexports._unrefActive = exports.active = function(item) {\r\n  clearTimeout(item._idleTimeoutId);\r\n\r\n  var msecs = item._idleTimeout;\r\n  if (msecs >= 0) {\r\n    item._idleTimeoutId = setTimeout(function onTimeout() {\r\n      if (item._onTimeout)\r\n        item._onTimeout();\r\n    }, msecs);\r\n  }\r\n};\r\n\r\n// setimmediate attaches itself to the global object\r\n__webpack_require__(29);\r\nexports.setImmediate = setImmediate;\r\nexports.clearImmediate = clearImmediate;\r\n\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\r\n    "use strict";\r\n\r\n    if (global.setImmediate) {\r\n        return;\r\n    }\r\n\r\n    var nextHandle = 1; // Spec says greater than zero\r\n    var tasksByHandle = {};\r\n    var currentlyRunningATask = false;\r\n    var doc = global.document;\r\n    var registerImmediate;\r\n\r\n    function setImmediate(callback) {\r\n      // Callback can either be a function or a string\r\n      if (typeof callback !== "function") {\r\n        callback = new Function("" + callback);\r\n      }\r\n      // Copy function arguments\r\n      var args = new Array(arguments.length - 1);\r\n      for (var i = 0; i < args.length; i++) {\r\n          args[i] = arguments[i + 1];\r\n      }\r\n      // Store and register the task\r\n      var task = { callback: callback, args: args };\r\n      tasksByHandle[nextHandle] = task;\r\n      registerImmediate(nextHandle);\r\n      return nextHandle++;\r\n    }\r\n\r\n    function clearImmediate(handle) {\r\n        delete tasksByHandle[handle];\r\n    }\r\n\r\n    function run(task) {\r\n        var callback = task.callback;\r\n        var args = task.args;\r\n        switch (args.length) {\r\n        case 0:\r\n            callback();\r\n            break;\r\n        case 1:\r\n            callback(args[0]);\r\n            break;\r\n        case 2:\r\n            callback(args[0], args[1]);\r\n            break;\r\n        case 3:\r\n            callback(args[0], args[1], args[2]);\r\n            break;\r\n        default:\r\n            callback.apply(undefined, args);\r\n            break;\r\n        }\r\n    }\r\n\r\n    function runIfPresent(handle) {\r\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\r\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\r\n        if (currentlyRunningATask) {\r\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\r\n            // "too much recursion" error.\r\n            setTimeout(runIfPresent, 0, handle);\r\n        } else {\r\n            var task = tasksByHandle[handle];\r\n            if (task) {\r\n                currentlyRunningATask = true;\r\n                try {\r\n                    run(task);\r\n                } finally {\r\n                    clearImmediate(handle);\r\n                    currentlyRunningATask = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function installNextTickImplementation() {\r\n        registerImmediate = function(handle) {\r\n            process.nextTick(function () { runIfPresent(handle); });\r\n        };\r\n    }\r\n\r\n    function canUsePostMessage() {\r\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\r\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\r\n        if (global.postMessage && !global.importScripts) {\r\n            var postMessageIsAsynchronous = true;\r\n            var oldOnMessage = global.onmessage;\r\n            global.onmessage = function() {\r\n                postMessageIsAsynchronous = false;\r\n            };\r\n            global.postMessage("", "*");\r\n            global.onmessage = oldOnMessage;\r\n            return postMessageIsAsynchronous;\r\n        }\r\n    }\r\n\r\n    function installPostMessageImplementation() {\r\n        // Installs an event handler on `global` for the `message` event: see\r\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\r\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\r\n\r\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\r\n        var onGlobalMessage = function(event) {\r\n            if (event.source === global &&\r\n                typeof event.data === "string" &&\r\n                event.data.indexOf(messagePrefix) === 0) {\r\n                runIfPresent(+event.data.slice(messagePrefix.length));\r\n            }\r\n        };\r\n\r\n        if (global.addEventListener) {\r\n            global.addEventListener("message", onGlobalMessage, false);\r\n        } else {\r\n            global.attachEvent("onmessage", onGlobalMessage);\r\n        }\r\n\r\n        registerImmediate = function(handle) {\r\n            global.postMessage(messagePrefix + handle, "*");\r\n        };\r\n    }\r\n\r\n    function installMessageChannelImplementation() {\r\n        var channel = new MessageChannel();\r\n        channel.port1.onmessage = function(event) {\r\n            var handle = event.data;\r\n            runIfPresent(handle);\r\n        };\r\n\r\n        registerImmediate = function(handle) {\r\n            channel.port2.postMessage(handle);\r\n        };\r\n    }\r\n\r\n    function installReadyStateChangeImplementation() {\r\n        var html = doc.documentElement;\r\n        registerImmediate = function(handle) {\r\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\r\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\r\n            var script = doc.createElement("script");\r\n            script.onreadystatechange = function () {\r\n                runIfPresent(handle);\r\n                script.onreadystatechange = null;\r\n                html.removeChild(script);\r\n                script = null;\r\n            };\r\n            html.appendChild(script);\r\n        };\r\n    }\r\n\r\n    function installSetTimeoutImplementation() {\r\n        registerImmediate = function(handle) {\r\n            setTimeout(runIfPresent, 0, handle);\r\n        };\r\n    }\r\n\r\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\r\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\r\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\r\n\r\n    // Don\'t get fooled by e.g. browserify environments.\r\n    if ({}.toString.call(global.process) === "[object process]") {\r\n        // For Node.js before 0.9\r\n        installNextTickImplementation();\r\n\r\n    } else if (canUsePostMessage()) {\r\n        // For non-IE10 modern browsers\r\n        installPostMessageImplementation();\r\n\r\n    } else if (global.MessageChannel) {\r\n        // For web workers, where supported\r\n        installMessageChannelImplementation();\r\n\r\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\r\n        // For IE 6\u20138\r\n        installReadyStateChangeImplementation();\r\n\r\n    } else {\r\n        // For older browsers\r\n        installSetTimeoutImplementation();\r\n    }\r\n\r\n    attachTo.setImmediate = setImmediate;\r\n    attachTo.clearImmediate = clearImmediate;\r\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(5)))\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(global) {\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = deprecate;\r\n\r\n/**\r\n * Mark that a method should not be used.\r\n * Returns a modified function which warns once by default.\r\n *\r\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\r\n *\r\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\r\n * will throw an Error when invoked.\r\n *\r\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\r\n * will invoke `console.trace()` instead of `console.error()`.\r\n *\r\n * @param {Function} fn - the function to deprecate\r\n * @param {String} msg - the string to print to the console when `fn` is invoked\r\n * @returns {Function} a new "deprecated" version of `fn`\r\n * @api public\r\n */\r\n\r\nfunction deprecate (fn, msg) {\r\n  if (config(\'noDeprecation\')) {\r\n    return fn;\r\n  }\r\n\r\n  var warned = false;\r\n  function deprecated() {\r\n    if (!warned) {\r\n      if (config(\'throwDeprecation\')) {\r\n        throw new Error(msg);\r\n      } else if (config(\'traceDeprecation\')) {\r\n        console.trace(msg);\r\n      } else {\r\n        console.warn(msg);\r\n      }\r\n      warned = true;\r\n    }\r\n    return fn.apply(this, arguments);\r\n  }\r\n\r\n  return deprecated;\r\n}\r\n\r\n/**\r\n * Checks `localStorage` for boolean values for the given `name`.\r\n *\r\n * @param {String} name\r\n * @returns {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction config (name) {\r\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\r\n  try {\r\n    if (!global.localStorage) return false;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n  var val = global.localStorage[name];\r\n  if (null == val) return false;\r\n  return String(val).toLowerCase() === \'true\';\r\n}\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n"use strict";\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// "Software"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// a passthrough stream.\r\n// basically just the most minimal sort of Transform stream.\r\n// Every written chunk gets output as-is.\r\n\r\n\r\n\r\nmodule.exports = PassThrough;\r\n\r\nvar Transform = __webpack_require__(19);\r\n\r\n/*<replacement>*/\r\nvar util = __webpack_require__(3);\r\nutil.inherits = __webpack_require__(1);\r\n/*</replacement>*/\r\n\r\nutil.inherits(PassThrough, Transform);\r\n\r\nfunction PassThrough(options) {\r\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\r\n\r\n  Transform.call(this, options);\r\n}\r\n\r\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\r\n  cb(null, chunk);\r\n};\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nmodule.exports = __webpack_require__(10);\r\n\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nmodule.exports = __webpack_require__(0);\r\n\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nmodule.exports = __webpack_require__(9).Transform\r\n\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nmodule.exports = __webpack_require__(9).PassThrough\r\n\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\nvar helper = __webpack_require__(12);\r\nvar xml2js = __webpack_require__(14);\r\n\r\nfunction validateOptions (userOptions) {\r\n  var options = helper.copyOptions(userOptions);\r\n  helper.ensureSpacesExists(options);\r\n  return options;\r\n}\r\n\r\nmodule.exports = function(xml, userOptions) {\r\n  var options, js, json, parentKey;\r\n  options = validateOptions(userOptions);\r\n  js = xml2js(xml, options);\r\n  parentKey = \'compact\' in options && options.compact ? \'_parent\' : \'parent\';\r\n  // parentKey = ptions.compact ? \'_parent\' : \'parent\'; // consider this\r\n  if (\'addParent\' in options && options.addParent) {\r\n    json = JSON.stringify(js, function (k, v) { return k === parentKey? \'_\' : v; }, options.spaces);\r\n  } else {\r\n    json = JSON.stringify(js, null, options.spaces);\r\n  }\r\n  return json.replace(/\\u2028/g, \'\\\\u2028\').replace(/\\u2029/g, \'\\\\u2029\');\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(Buffer) {var js2xml = __webpack_require__(20);\r\n\r\nmodule.exports = function (json, options) {\r\n  if (json instanceof Buffer) {\r\n    json = json.toString();\r\n  }\r\n  var js = null;\r\n  if (typeof (json) === \'string\') {\r\n    try {\r\n      js = JSON.parse(json);\r\n    } catch (e) {\r\n      throw new Error(\'The JSON structure is invalid\');\r\n    }\r\n  } else {\r\n    js = json;\r\n  }\r\n  return js2xml(js, options);\r\n};\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4).Buffer))\r\n\r\n/***/ })\r\n/******/ ])));';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*moment@2.27.0#moment*/
;
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define('moment@2.27.0#moment', factory) : global.moment = factory();
}(this, function () {
    'use strict';
    var hookCallback;
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }
    function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }
    function isUndefined(input) {
        return input === void 0;
    }
    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
            return false;
        };
    }
    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to, from) {
        var i, prop, val;
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [], arg, i, key;
                for (i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2);
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
        return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }
    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    var keys;
    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
    };
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
            if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
                return tok.slice(1);
            }
            return tok;
        }).join('');
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = 'Invalid date';
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = '%d', defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }
    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({
                    unit: u,
                    priority: priorities[u]
                });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }
    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n, x) {
        return (n % x + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken('M', [
        'MM',
        2
    ], 'Mo', function () {
        return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias('month', 'M');
    addUnitPriority('month', 8);
    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    addParseToken([
        'M',
        'MM'
    ], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken([
        'MMM',
        'MMMM'
    ], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'), defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([
                    2000,
                    i
                ]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = createUTC([
                2000,
                i
            ]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
            return mom;
        }
        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
            mom = createUTC([
                2000,
                i
            ]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }
    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });
    addFormatToken(0, [
        'YY',
        2
    ], 0, function () {
        return this.year() % 100;
    });
    addFormatToken(0, [
        'YYYY',
        4
    ], 0, 'year');
    addFormatToken(0, [
        'YYYYY',
        5
    ], 0, 'year');
    addFormatToken(0, [
        'YYYYYY',
        6,
        true
    ], 0, 'year');
    addUnitAlias('year', 'y');
    addUnitPriority('year', 1);
    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken([
        'YYYYY',
        'YYYYYY'
    ], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet('FullYear', true);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
    }
    function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }
        return {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken('w', [
        'ww',
        2
    ], 'wo', 'week');
    addFormatToken('W', [
        'WW',
        2
    ], 'Wo', 'isoWeek');
    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');
    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);
    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken([
        'w',
        'ww',
        'W',
        'WW'
    ], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }
    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');
    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);
    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken([
        'dd',
        'ddd',
        'dddd'
    ], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken([
        'd',
        'e',
        'E'
    ], function (input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }
        return null;
    }
    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'), defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'), defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
                mom = createUTC([
                    2000,
                    1
                ]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            mom = createUTC([
                2000,
                1
            ]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            mom = createUTC([
                2000,
                1
            ]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    addFormatToken('H', [
        'HH',
        2
    ], 0, 'hour');
    addFormatToken('h', [
        'hh',
        2
    ], 0, hFormat);
    addFormatToken('k', [
        'kk',
        2
    ], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem('a', true);
    meridiem('A', false);
    addUnitAlias('hour', 'h');
    addUnitPriority('hour', 13);
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken([
        'H',
        'HH'
    ], HOUR);
    addParseToken([
        'k',
        'kk'
    ], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken([
        'a',
        'A'
    ], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([
        'h',
        'hh'
    ], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
        return (input + '').toLowerCase().charAt(0) === 'p';
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet('Hours', true);
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }
    function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                locales[name] = null;
            }
        }
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                }
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }
            getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }
            getSetGlobalLocale(name);
        } else {
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys(locales);
    }
    function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
            [
                'YYYYYY-MM-DD',
                /[+-]\d{6}-\d\d-\d\d/
            ],
            [
                'YYYY-MM-DD',
                /\d{4}-\d\d-\d\d/
            ],
            [
                'GGGG-[W]WW-E',
                /\d{4}-W\d\d-\d/
            ],
            [
                'GGGG-[W]WW',
                /\d{4}-W\d\d/,
                false
            ],
            [
                'YYYY-DDD',
                /\d{4}-\d{3}/
            ],
            [
                'YYYY-MM',
                /\d{4}-\d\d/,
                false
            ],
            [
                'YYYYYYMMDD',
                /[+-]\d{10}/
            ],
            [
                'YYYYMMDD',
                /\d{8}/
            ],
            [
                'GGGG[W]WWE',
                /\d{4}W\d{3}/
            ],
            [
                'GGGG[W]WW',
                /\d{4}W\d{2}/,
                false
            ],
            [
                'YYYYDDD',
                /\d{7}/
            ],
            [
                'YYYYMM',
                /\d{6}/,
                false
            ],
            [
                'YYYY',
                /\d{4}/,
                false
            ]
        ], isoTimes = [
            [
                'HH:mm:ss.SSSS',
                /\d\d:\d\d:\d\d\.\d+/
            ],
            [
                'HH:mm:ss,SSSS',
                /\d\d:\d\d:\d\d,\d+/
            ],
            [
                'HH:mm:ss',
                /\d\d:\d\d:\d\d/
            ],
            [
                'HH:mm',
                /\d\d:\d\d/
            ],
            [
                'HHmmss.SSSS',
                /\d\d\d\d\d\d\.\d+/
            ],
            [
                'HHmmss,SSSS',
                /\d\d\d\d\d\d,\d+/
            ],
            [
                'HHmmss',
                /\d\d\d\d\d\d/
            ],
            [
                'HHmm',
                /\d\d\d\d/
            ],
            [
                'HH',
                /\d\d/
            ]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60
        };
    function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];
        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }
        return result;
    }
    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }
    function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            return 0;
        } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }
        if (config._strict) {
            config._isValid = false;
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate()
            ];
        }
        return [
            nowValue.getFullYear(),
            nowValue.getMonth(),
            nowValue.getDate()
        ];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    hooks.ISO_8601 = function () {
    };
    hooks.RFC_2822 = function () {
    };
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
                validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
                if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map([
            i.year,
            i.month,
            dayOrDate,
            i.hour,
            i.minute,
            i.second,
            i.millisecond
        ], function (obj) {
            return obj && parseInt(obj, 10);
        });
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, 'd');
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format === undefined && input === '') {
            return createInvalid({ nullInput: true });
        }
        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }
        if (!isValid(config)) {
            config._d = null;
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }
        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }), prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
    }
    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };
    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond'
    ];
    function isDurationValid(m) {
        var key, unitHasDecimal = false, i;
        for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }
        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false;
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }
        return true;
    }
    function isValid$1() {
        return this._isValid;
    }
    function createInvalid$1() {
        return createDuration(NaN);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds + seconds * 1000 + minutes * 60000 + hours * 1000 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(), sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset('Z', ':');
    offset('ZZ', '');
    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken([
        'Z',
        'ZZ'
    ], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher), chunk, parts, minutes;
        if (matches === null) {
            return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || [
            '-',
            0,
            0
        ];
        minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function () {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0, localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign
            };
        } else if (match = isoRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }
        return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, 'M');
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {
                milliseconds: 0,
                months: 0
            };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val;
                val = period;
                period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        if (!mom.isValid()) {
            return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }
    var add = createAdder(1, 'add'), subtract = createAdder(-1, 'subtract');
    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }
    function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
    }
    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms'
            ], i, property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest = input.filter(function (item) {
                return !isNumber(item) && isString(input);
            }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse'
            ], i, property;
        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }
    function calendar$1(time, formats) {
        if (arguments.length === 1) {
            if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf('day'), format = hooks.calendarFormat(this, sod) || 'sameElse', output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
            return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
            return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 60000;
        units = normalizeUnits(units);
        switch (units) {
        case 'year':
            output = monthDiff(this, that) / 12;
            break;
        case 'month':
            output = monthDiff(this, that);
            break;
        case 'quarter':
            output = monthDiff(this, that) / 3;
            break;
        case 'second':
            output = (this - that) / 1000;
            break;
        case 'minute':
            output = (this - that) / 60000;
            break;
        case 'hour':
            output = (this - that) / 3600000;
            break;
        case 'day':
            output = (this - that - zoneDelta) / 86400000;
            break;
        case 'week':
            output = (this - that - zoneDelta) / 604800000;
            break;
        default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }
    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment', zone = '', prefix, year, datetime, suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
                from: this,
                to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    var MS_PER_SECOND = 1000, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }
    function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }
    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
        case 'year':
            time = startOfDate(this.year(), 0, 1);
            break;
        case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
        case 'month':
            time = startOfDate(this.year(), this.month(), 1);
            break;
        case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
        case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
        case 'day':
        case 'date':
            time = startOfDate(this.year(), this.month(), this.date());
            break;
        case 'hour':
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
        case 'minute':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
        case 'second':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
        case 'year':
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
        case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
        case 'month':
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
        case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
        case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
        case 'day':
        case 'date':
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
        case 'hour':
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
        case 'minute':
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
        case 'second':
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }
    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }
    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
        ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');
    addFormatToken('y', [
        'y',
        1
    ], 'yo', 'eraYear');
    addFormatToken('y', [
        'yy',
        2
    ], 0, 'eraYear');
    addFormatToken('y', [
        'yyy',
        3
    ], 0, 'eraYear');
    addFormatToken('y', [
        'yyyy',
        4
    ], 0, 'eraYear');
    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);
    addParseToken([
        'N',
        'NN',
        'NNN',
        'NNNN',
        'NNNNN'
    ], function (input, array, config, token) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });
    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);
    addParseToken([
        'y',
        'yy',
        'yyy',
        'yyyy'
    ], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });
    function localeEras(m, format) {
        var i, l, date, eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
            case 'string':
                date = hooks(eras[i].since).startOf('day');
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
            case 'undefined':
                eras[i].until = +Infinity;
                break;
            case 'string':
                date = hooks(eras[i].until).startOf('day').valueOf();
                eras[i].until = date.valueOf();
                break;
            }
        }
        return eras;
    }
    function localeErasParse(eraName, format, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
                switch (format) {
                case 'N':
                case 'NN':
                case 'NNN':
                    if (abbr === eraName) {
                        return eras[i];
                    }
                    break;
                case 'NNNN':
                    if (name === eraName) {
                        return eras[i];
                    }
                    break;
                case 'NNNNN':
                    if (narrow === eraName) {
                        return eras[i];
                    }
                    break;
                }
            } else if ([
                    name,
                    abbr,
                    narrow
                ].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }
    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }
    function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }
        return '';
    }
    function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }
        return '';
    }
    function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            val = this.startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }
        return '';
    }
    function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;
            val = this.startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
                return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
        }
        return this.year();
    }
    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
    }
    addFormatToken(0, [
        'gg',
        2
    ], 0, function () {
        return this.weekYear() % 100;
    });
    addFormatToken(0, [
        'GG',
        2
    ], 0, function () {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [
            token,
            token.length
        ], 0, getter);
    }
    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');
    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);
    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken([
        'gggg',
        'ggggg',
        'GGGG',
        'GGGGG'
    ], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken([
        'gg',
        'GG'
    ], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    addFormatToken('Q', 0, 'Qo', 'quarter');
    addUnitAlias('quarter', 'Q');
    addUnitPriority('quarter', 7);
    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken('D', [
        'DD',
        2
    ], 'Do', 'date');
    addUnitAlias('date', 'D');
    addUnitPriority('date', 9);
    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken([
        'D',
        'DD'
    ], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet('Date', true);
    addFormatToken('DDD', [
        'DDDD',
        3
    ], 'DDDo', 'dayOfYear');
    addUnitAlias('dayOfYear', 'DDD');
    addUnitPriority('dayOfYear', 4);
    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken([
        'DDD',
        'DDDD'
    ], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 86400000) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }
    addFormatToken('m', [
        'mm',
        2
    ], 0, 'minute');
    addUnitAlias('minute', 'm');
    addUnitPriority('minute', 14);
    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken([
        'm',
        'mm'
    ], MINUTE);
    var getSetMinute = makeGetSet('Minutes', false);
    addFormatToken('s', [
        'ss',
        2
    ], 0, 'second');
    addUnitAlias('second', 's');
    addUnitPriority('second', 15);
    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken([
        's',
        'ss'
    ], SECOND);
    var getSetSecond = makeGetSet('Seconds', false);
    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, [
        'SS',
        2
    ], 0, function () {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, [
        'SSS',
        3
    ], 0, 'millisecond');
    addFormatToken(0, [
        'SSSS',
        4
    ], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, [
        'SSSSS',
        5
    ], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, [
        'SSSSSS',
        6
    ], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, [
        'SSSSSSS',
        7
    ], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, [
        'SSSSSSSS',
        8
    ], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, [
        'SSSSSSSSS',
        9
    ], 0, function () {
        return this.millisecond() * 1000000;
    });
    addUnitAlias('millisecond', 'ms');
    addUnitPriority('millisecond', 16);
    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }
    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet('Milliseconds', false);
    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');
    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }
    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
    function createUnix(input) {
        return createLocal(input * 1000);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format, index, field, setter) {
        var locale = getLocale(), utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }
        format = format || '';
        if (index != null) {
            return get$1(format, index, field, 'month');
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }
            format = format || '';
        }
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, i, out = [];
        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }
    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD'
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC'
            }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        }
    });
    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;
    function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 86400000;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return days * 4800 / 146097;
    }
    function monthsToDays(months) {
        return months * 146097 / 4800;
    }
    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days, months, milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 86400000;
            months = this._months + daysToMonths(days);
            switch (units) {
            case 'month':
                return months;
            case 'quarter':
                return months / 3;
            case 'year':
                return months / 12;
            }
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
            case 'week':
                return days / 7 + milliseconds / 604800000;
            case 'day':
                return days + milliseconds / 86400000;
            case 'hour':
                return days * 24 + milliseconds / 3600000;
            case 'minute':
                return days * 1440 + milliseconds / 60000;
            case 'second':
                return days * 86400 + milliseconds / 1000;
            case 'millisecond':
                return Math.floor(days * 86400000) + milliseconds;
            default:
                throw new Error('Unknown unit ' + units);
            }
        }
    }
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return this._milliseconds + this._days * 86400000 + this._months % 12 * 2592000000 + toInt(this._months / 12) * 31536000000;
    }
    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs('ms'), asSeconds = makeAs('s'), asMinutes = makeAs('m'), asHours = makeAs('h'), asDays = makeAs('d'), asWeeks = makeAs('w'), asMonths = makeAs('M'), asQuarters = makeAs('Q'), asYears = makeAs('y');
    function clone$1() {
        return createDuration(this);
    }
    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }
    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    var milliseconds = makeGetter('milliseconds'), seconds = makeGetter('seconds'), minutes = makeGetter('minutes'), hours = makeGetter('hours'), days = makeGetter('days'), months = makeGetter('months'), years = makeGetter('years');
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
            ss: 44,
            s: 45,
            m: 45,
            h: 22,
            d: 26,
            w: null,
            M: 11
        };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as('s')), minutes = round(duration.as('m')), hours = round(duration.as('h')), days = round(duration.as('d')), months = round(duration.as('M')), weeks = round(duration.as('w')), years = round(duration.as('y')), a = seconds <= thresholds.ss && [
                's',
                seconds
            ] || seconds < thresholds.s && [
                'ss',
                seconds
            ] || minutes <= 1 && ['m'] || minutes < thresholds.m && [
                'mm',
                minutes
            ] || hours <= 1 && ['h'] || hours < thresholds.h && [
                'hh',
                hours
            ] || days <= 1 && ['d'] || days < thresholds.d && [
                'dd',
                days
            ];
        if (thresholds.w != null) {
            a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && [
                'ww',
                weeks
            ];
        }
        a = a || months <= 1 && ['M'] || months < thresholds.M && [
            'MM',
            months
        ] || years <= 1 && ['y'] || [
            'yy',
            years
        ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }
    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale, output;
        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }
        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1000, days = abs$1(this._days), months = abs$1(this._months), minutes, hours, years, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
            return 'P0D';
        }
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
        return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;
    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');
    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });
    hooks.version = '2.27.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        DATE: 'YYYY-MM-DD',
        TIME: 'HH:mm',
        TIME_SECONDS: 'HH:mm:ss',
        TIME_MS: 'HH:mm:ss.SSS',
        WEEK: 'GGGG-[W]WW',
        MONTH: 'YYYY-MM'
    };
    return hooks;
}));
/*bitovians-pto@1.0.0#package.json*/
define('bitovians-pto@1.0.0#package.json', [], function () {
    return {
        'name': 'bitovians-pto',
        'version': '1.0.0',
        'description': 'Freshbooks-integrated PTO tracking for Bitovi employees',
        'main': 'app.js',
        'scripts': {
            'build': 'steal-tools --no-minify',
            'bundle': 'steal-tools bundle --dev --no-minify',
            'develop': 'other-index development.html 8080',
            'lint': 'standard --fix \'components/**/*.js\' \'models/**/*.js\'',
            'postinstall': 'npm run bundle',
            'start': 'other-index index.html 8080'
        },
        'author': 'Mark Stahl <mjstahl@gmail.com>',
        'license': 'MIT',
        'devDependencies': {
            '@mjstahl/other-index': '^0.2.2',
            'node': '^10.21.0',
            'standard': '^12.0.1',
            'steal-tools': '^2.2.6'
        },
        'dependencies': {
            'can': '^5.33.3',
            'lodash': '^4.17.20',
            'moment': '^2.27.0',
            'steal': '^2.2.4',
            'steal-less': '^1.3.4',
            'xml-js': '^1.6.11'
        },
        'steal': {
            'map': { 'xml-js': 'xml-js/dist/xml-js' },
            'meta': { 'xml-js/dist/xml-js': { 'format': 'global' } },
            'plugins': [
                'can',
                'steal-less'
            ]
        },
        'proxy': 'https://bitovi-cors.herokuapp.com/'
    };
});
/*bitovians-pto@1.0.0#models/time-entries*/
define('bitovians-pto@1.0.0#models/time-entries', [
    'exports',
    'xml-js@1.6.11#dist/xml-js',
    'moment@2.27.0#moment',
    'bitovians-pto@1.0.0#package.json',
    'bitovians-pto@1.0.0#models/api-info',
    'can-define@2.8.0#map/map',
    'can@5.33.3#enable-can-debug',
    'can-component@4.6.2#can-component'
], function (exports, _xmlJs, _moment, _bitoviansPto100Package, _apiInfo, _map) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _xmlJs2 = _interopRequireDefault(_xmlJs);
    var _moment2 = _interopRequireDefault(_moment);
    var _bitoviansPto100Package2 = _interopRequireDefault(_bitoviansPto100Package);
    var _apiInfo2 = _interopRequireDefault(_apiInfo);
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var TimeEntries = _map2.default.extend('TimeEntries', {
        init: function init() {
            this.setFirstAndLastDays();
        },
        allTimeOff: {
            get: function get(lastSet, resolve) {
                var _this = this;
                if (lastSet)
                    return lastSet;
                var promised = [];
                this.requestEntries(1, true).then(function (entries) {
                    promised.push(Promise.resolve(entries));
                    var current = 2;
                    var howMany = _this.howManyPages(entries);
                    while (current <= howMany) {
                        promised.push(_this.requestEntries(current, true));
                        current += 1;
                    }
                    Promise.all(promised).then(function (results) {
                        var collected = results.map(function (r) {
                            return _this.collectTimeEntries([], r.response.time_entries.time_entry);
                        });
                        resolve([].concat.apply([], collected));
                    });
                });
            }
        },
        apiInfo: { Type: _apiInfo2.default },
        firstDay: 'string',
        lastDay: 'string',
        collectTimeEntries: function collectTimeEntries(collection, data) {
            if (!data)
                return collection;
            var today = (0, _moment2.default)();
            var entries = [].concat(data);
            entries.forEach(function (e) {
                var date = (0, _moment2.default)(e.date._text, 'YYYY-MM-DD');
                if (date.isBefore(today) || date.isSame(today)) {
                    collection.push({
                        date: e.date._text,
                        hours: e.hours._text
                    });
                }
            });
            return collection;
        },
        howManyPages: function howManyPages(entries) {
            return entries.response.time_entries ? parseInt(entries.response.time_entries._attributes.pages) : 0;
        },
        requestBodyFor: function requestBodyFor() {
            var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var filterByTask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            return '\n      <?xml version="1.0" encoding="utf-8"?>\n      <request method="time_entry.list">\n        ' + (filterByTask ? '<task_id>48</task_id>' : '') + '\n        <page>' + page + '</page>\n        <per_page>100</per_page>\n      </request>\n    ';
        },
        requestEntries: function requestEntries() {
            var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var headers = new window.Headers();
            headers.append('Authorization', 'Basic ' + window.btoa(this.apiInfo.token + ':' + 'X'));
            headers.append('Content-Type', 'application/xml');
            var body = this.requestBodyFor(page, filter);
            var url = '' + _bitoviansPto100Package2.default.proxy + this.apiInfo.url;
            return window.fetch(url, {
                method: 'POST',
                headers: headers,
                body: body
            }).then(function (response) {
                return response.text().then(function (result) {
                    var xmlText = _xmlJs2.default.xml2json(result, { compact: true });
                    return JSON.parse(xmlText);
                });
            });
        },
        selectEntryAt: function selectEntryAt(entries, where) {
            return entries.response.time_entries.time_entry[where];
        },
        setFirstAndLastDays: function setFirstAndLastDays() {
            var _this2 = this;
            return this.requestEntries().then(function (entries) {
                var pages = _this2.howManyPages(entries);
                if (pages < 1)
                    return;
                return _this2.requestEntries(pages).then(function (earliest) {
                    _this2.lastDay = _this2.selectEntryAt(entries, 0).date._text;
                    var selected = earliest.response.time_entries.time_entry.length - 1;
                    _this2.firstDay = _this2.selectEntryAt(earliest, selected).date._text;
                });
            });
        }
    });
    exports.default = TimeEntries;
});
/*can-view-import@4.2.2#can-view-import*/
define('can-view-import@4.2.2#can-view-import', [
    'require',
    'exports',
    'module',
    'can-assign',
    'can-dom-data',
    'can-symbol',
    'can-globals/document/document',
    'can-child-nodes',
    'can-import-module',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-view-nodelist',
    'can-view-callbacks',
    'can-log/',
    'can-log/dev/dev'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var assign = require('can-assign');
        var canData = require('can-dom-data');
        var canSymbol = require('can-symbol');
        var DOCUMENT = require('can-globals/document/document');
        var getChildNodes = require('can-child-nodes');
        var importer = require('can-import-module');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var nodeLists = require('can-view-nodelist');
        var viewCallbacks = require('can-view-callbacks');
        var tag = viewCallbacks.tag;
        var canLog = require('can-log/');
        var dev = require('can-log/dev/dev');
        function setViewModel(element, viewModel) {
            element[canSymbol.for('can.viewModel')] = viewModel;
        }
        function processImport(el, tagData) {
            var moduleName = el.getAttribute('from');
            var templateModule = tagData.scope.get('scope.helpers.module');
            var parentName = templateModule ? templateModule.id : undefined;
            if (!moduleName) {
                return Promise.reject('No module name provided');
            }
            var importPromise = importer(moduleName, parentName);
            importPromise.catch(function (err) {
                canLog.error(err);
            });
            setViewModel(el, importPromise);
            canData.set(el, 'scope', importPromise);
            var scope = tagData.scope.add(importPromise, { notContext: true });
            var handOffTag = el.getAttribute('can-tag');
            if (handOffTag) {
                var callback = tag(handOffTag);
                if (!callback || callback === viewCallbacks.defaultCallback) {
                } else {
                    canData.set(el, 'preventDataBindings', true);
                    callback(el, assign(tagData, { scope: scope }));
                    canData.set(el, 'preventDataBindings', false);
                    setViewModel(el, importPromise);
                    canData.set(el, 'scope', importPromise);
                }
            } else {
                var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);
                nodeList.expression = '<' + this.tagName + '>';
                var frag = tagData.subtemplate ? tagData.subtemplate(scope, tagData.options, nodeList) : DOCUMENT().createDocumentFragment();
                var removalDisposal = domMutate.onNodeRemoval(el, function () {
                    var doc = el.ownerDocument;
                    var ownerNode = doc.contains ? doc : doc.documentElement;
                    if (!ownerNode || ownerNode.contains(el) === false) {
                        removalDisposal();
                        nodeLists.unregister(nodeList);
                    }
                });
                domMutateNode.appendChild.call(el, frag);
                nodeLists.update(nodeList, getChildNodes(el));
            }
        }
        [
            'can-import',
            'can-dynamic-import'
        ].forEach(function (tagName) {
            tag(tagName, processImport.bind({ tagName: tagName }));
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-stache@4.1.5#add-bundles*/
define('steal-stache@4.1.5#add-bundles', [], function(){ return {}; });
/*steal-config-utils@1.0.0#import-specifiers*/
define('steal-config-utils@1.0.0#import-specifiers', [], function(){ return {}; });
/*steal-stache@4.1.5#steal-stache*/
define('steal-stache@4.1.5#steal-stache', [], function(){ return {}; });
/*bitovians-pto@1.0.0#components/loading/loading.stache!steal-stache@4.1.5#steal-stache*/
define('bitovians-pto@1.0.0#components/loading/loading.stache!steal-stache@4.1.5#steal-stache', [
    'module',
    'can-assign',
    'can-stache',
    'can-stache/src/mustache_core',
    'can-view-import@4.2.2#can-view-import',
    'can-stache-bindings@4.10.9#can-stache-bindings'
], function (module, assign, stache, mustacheCore) {
    var renderer = stache('components/loading/loading.stache', [
        {
            'tokenType': 'start',
            'args': [
                'div',
                false,
                1
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'class',
                1
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                'loading',
                1
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'class',
                1
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'div',
                false,
                1
            ]
        },
        {
            'tokenType': 'close',
            'args': [
                'div',
                1
            ]
        },
        {
            'tokenType': 'done',
            'args': [1]
        }
    ]);
    return function (scope, options, nodeList) {
        var moduleOptions = assign({}, options);
        if (moduleOptions.helpers) {
            moduleOptions.helpers = assign({ module: module }, moduleOptions.helpers);
        } else {
            moduleOptions.module = module;
        }
        return renderer(scope, moduleOptions, nodeList);
    };
});
/*bitovians-pto@1.0.0#components/loading/loading*/
define('bitovians-pto@1.0.0#components/loading/loading', [
    'bitovians-pto@1.0.0#components/loading/loading.stache!steal-stache@4.1.5#steal-stache',
    'can-component@4.6.2#can-component',
    'can@5.33.3#enable-can-debug',
    'can-define@2.8.0#map/map'
], function (_loadingStacheStealStache, _canComponent) {
    'use strict';
    var _loadingStacheStealStache2 = _interopRequireDefault(_loadingStacheStealStache);
    var _canComponent2 = _interopRequireDefault(_canComponent);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _canComponent2.default.extend({
        tag: 'pto-loading',
        view: _loadingStacheStealStache2.default,
        ViewModel: {}
    });
});
/*bitovians-pto@1.0.0#app.stache!steal-stache@4.1.5#steal-stache*/
define('bitovians-pto@1.0.0#app.stache!steal-stache@4.1.5#steal-stache', [
    'module',
    'can-assign',
    'can-stache',
    'can-stache/src/mustache_core',
    'can-view-import@4.2.2#can-view-import',
    'can-stache-bindings@4.10.9#can-stache-bindings',
    '~/components/loading/'
], function (module, assign, stache, mustacheCore) {
    var renderer = stache('app.stache', [
        {
            'tokenType': 'start',
            'args': [
                'can-import',
                true,
                1
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'from',
                1
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                '~/components/loading/',
                1
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'from',
                1
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'can-import',
                true,
                1
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                ' ',
                1
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                '#if(isAuthenticated)',
                1
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n  ',
                1
            ]
        },
        {
            'tokenType': 'start',
            'args': [
                'can-import',
                false,
                2
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'from',
                2
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                '~/components/dashboard/',
                2
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'from',
                2
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'can-import',
                false,
                2
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n    ',
                2
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                '#if(isPending)',
                3
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n      ',
                3
            ]
        },
        {
            'tokenType': 'start',
            'args': [
                'pto-loading',
                true,
                4
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'pto-loading',
                true,
                4
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n    ',
                4
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                'else',
                5
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n      ',
                5
            ]
        },
        {
            'tokenType': 'start',
            'args': [
                'pto-dashboard',
                true,
                6
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'clear:u:a:u:p:u:i:u:token:from',
                6
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                'clearAPIToken',
                6
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'clear:u:a:u:p:u:i:u:token:from',
                6
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'time:u:entries:from',
                6
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                'timeEntries',
                6
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'time:u:entries:from',
                6
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'pto-dashboard',
                true,
                9
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n    ',
                9
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                '/if',
                10
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n  ',
                10
            ]
        },
        {
            'tokenType': 'close',
            'args': [
                'can-import',
                11
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n',
                11
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                'else',
                12
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n  ',
                12
            ]
        },
        {
            'tokenType': 'start',
            'args': [
                'can-import',
                false,
                13
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'from',
                13
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                '~/components/authenticate/',
                13
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'from',
                13
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'can-import',
                false,
                13
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n    ',
                13
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                '#if(isPending)',
                14
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n      ',
                14
            ]
        },
        {
            'tokenType': 'start',
            'args': [
                'pto-loading',
                true,
                15
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'pto-loading',
                true,
                15
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n    ',
                15
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                'else',
                16
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n      ',
                16
            ]
        },
        {
            'tokenType': 'start',
            'args': [
                'pto-authenticate',
                true,
                17
            ]
        },
        {
            'tokenType': 'attrStart',
            'args': [
                'api:u:info:from',
                17
            ]
        },
        {
            'tokenType': 'attrValue',
            'args': [
                'apiInfo',
                17
            ]
        },
        {
            'tokenType': 'attrEnd',
            'args': [
                'api:u:info:from',
                17
            ]
        },
        {
            'tokenType': 'end',
            'args': [
                'pto-authenticate',
                true,
                17
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n    ',
                17
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                '/if',
                18
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n  ',
                18
            ]
        },
        {
            'tokenType': 'close',
            'args': [
                'can-import',
                19
            ]
        },
        {
            'tokenType': 'chars',
            'args': [
                '\n',
                19
            ]
        },
        {
            'tokenType': 'special',
            'args': [
                '/if',
                20
            ]
        },
        {
            'tokenType': 'done',
            'args': [20]
        }
    ]);
    return function (scope, options, nodeList) {
        var moduleOptions = assign({}, options);
        if (moduleOptions.helpers) {
            moduleOptions.helpers = assign({ module: module }, moduleOptions.helpers);
        } else {
            moduleOptions.module = module;
        }
        return renderer(scope, moduleOptions, nodeList);
    };
});
/*steal-css@1.3.2#css*/
define('steal-css@1.3.2#css', [
    'require',
    'exports',
    'module',
    '@loader',
    '@steal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
        exports.pluginBuilder = 'steal-css/slim';
    }(function () {
        return this;
    }(), require, exports, module));
});
/*@node-require/steal-less@1.3.4#less-engine-node*/
define('@node-require/steal-less@1.3.4#less-engine-node', [], function(){ return {}; });
/*steal-less@1.3.4#less-engine-node*/
define('steal-less@1.3.4#less-engine-node', [], function(){ return {}; });
/*steal-less@1.3.4#less*/
define('steal-less@1.3.4#less', [], function(){ return {}; });
/*bitovians-pto@1.0.0#app*/
define('bitovians-pto@1.0.0#app', [
    'bitovians-pto@1.0.0#models/api-info',
    'bitovians-pto@1.0.0#models/time-entries',
    'bitovians-pto@1.0.0#app.stache!steal-stache@4.1.5#steal-stache',
    'can-component@4.6.2#can-component',
    'styles.less!steal-less@1.3.4#less',
    'can@5.33.3#enable-can-debug',
    'can-debug@2.0.7#can-debug',
    'can-namespace@1.0.0#can-namespace',
    'can-globals@1.2.2#can-globals',
    'can-globals@1.2.2#can-globals-instance',
    'can-globals@1.2.2#can-globals-proto',
    'can-reflect@1.18.0#can-reflect',
    'can-reflect@1.18.0#reflections/call/call',
    'can-symbol@1.6.5#can-symbol',
    'can-reflect@1.18.0#reflections/type/type',
    'can-reflect@1.18.0#reflections/helpers',
    'can-reflect@1.18.0#reflections/get-set/get-set',
    'can-reflect@1.18.0#reflections/observe/observe',
    'can-reflect@1.18.0#reflections/shape/shape',
    'can-reflect@1.18.0#reflections/shape/schema/schema',
    'can-reflect@1.18.0#reflections/get-name/get-name',
    'can-reflect@1.18.0#types/map',
    'can-reflect@1.18.0#types/set',
    'can-globals@1.2.2#global/global',
    'can-globals@1.2.2#document/document',
    'can-globals@1.2.2#location/location',
    'can-globals@1.2.2#mutation-observer/mutation-observer',
    'can-globals@1.2.2#is-browser-window/is-browser-window',
    'can-globals@1.2.2#is-node/is-node',
    'can-globals@1.2.2#custom-elements/custom-elements',
    'can-debug@2.0.7#src/proxy-namespace',
    'can-debug@2.0.7#src/temporarily-bind',
    'can-debug@2.0.7#src/get-graph/get-graph',
    'can-debug@2.0.7#src/graph/graph',
    'can-assign@1.3.3#can-assign',
    'can-debug@2.0.7#src/get-graph/make-node',
    'can-reflect-dependencies@1.1.2#can-reflect-dependencies',
    'can-reflect-dependencies@1.1.2#src/add-mutated-by',
    'can-reflect-dependencies@1.1.2#src/delete-mutated-by',
    'can-reflect-dependencies@1.1.2#src/get-dependency-data-of',
    'can-reflect-dependencies@1.1.2#src/is-function',
    'can-debug@2.0.7#src/format-graph/format-graph',
    'can-debug@2.0.7#src/what-i-change/what-i-change',
    'can-debug@2.0.7#src/log-data/log-data',
    'can-debug@2.0.7#src/get-data/get-data',
    'can-debug@2.0.7#src/label-cycles/label-cycles',
    'can-debug@2.0.7#src/what-changes-me/what-changes-me',
    'can-debug@2.0.7#src/get-what-i-change/get-what-i-change',
    'can-debug@2.0.7#src/get-what-changes-me/get-what-changes-me',
    'can-observation@4.2.0#can-observation',
    'can-queues@1.3.1#can-queues',
    'can-log@1.0.2#dev/dev',
    'can-log@1.0.2#can-log',
    'can-queues@1.3.1#queue',
    'can-queues@1.3.1#queue-state',
    'can-queues@1.3.1#priority-queue',
    'can-queues@1.3.1#completion-queue',
    'can-queues@1.3.1#dom-order-queue',
    'can-queues@1.3.1#sorted-index-by',
    'can-queues@1.3.1#element-sort',
    'can-observation-recorder@1.3.1#can-observation-recorder',
    'can-event-queue@1.1.7#value/value',
    'can-key-tree@1.2.2#can-key-tree',
    'can-define-lazy-value@1.1.1#define-lazy-value',
    'can-event-queue@1.1.7#dependency-record/merge',
    'can-observation@4.2.0#recorder-dependency-helpers',
    'can-observation@4.2.0#temporarily-bind',
    'can-diff@1.5.0#merge-deep/merge-deep',
    'can-diff@1.5.0#list/list',
    'can-define@2.8.0#map/map',
    'can-construct@3.5.6#can-construct',
    'can-string@1.1.0#can-string',
    'can-define@2.8.0#can-define',
    'can-simple-observable@2.5.0#async/async',
    'can-simple-observable@2.5.0#can-simple-observable',
    'can-simple-observable@2.5.0#log',
    'can-simple-observable@2.5.0#settable/settable',
    'can-simple-observable@2.5.0#resolver/resolver',
    'can-event-queue@1.1.7#map/map',
    'can-dom-events@1.3.11#can-dom-events',
    'can-dom-events@1.3.11#helpers/util',
    'can-dom-events@1.3.11#helpers/make-event-registry',
    'can-dom-events@1.3.11#helpers/-make-delegate-event-tree',
    'can-event-queue@1.1.7#type/type',
    'can-string-to-any@1.2.1#can-string-to-any',
    'can-data-types@1.2.1#maybe-boolean/maybe-boolean',
    'can-data-types@1.2.1#maybe-date/maybe-date',
    'can-data-types@1.2.1#maybe-number/maybe-number',
    'can-data-types@1.2.1#maybe-string/maybe-string',
    'can-define@2.8.0#define-helpers/define-helpers',
    'can-define@2.8.0#ensure-meta',
    'can-bind@1.5.1#can-bind',
    'can-stache@4.17.21#can-stache',
    'can-view-parser@4.1.3#can-view-parser',
    'can-attribute-encoder@1.1.4#can-attribute-encoder',
    'can-view-callbacks@4.4.1#can-view-callbacks',
    'can-dom-mutate@1.3.11#can-dom-mutate',
    'can-dom-mutate@1.3.11#-util',
    'can-dom-mutate@1.3.11#node',
    'can-dom-mutate@1.3.11#node/node',
    'can-view-nodelist@4.3.4#can-view-nodelist',
    'can-fragment@1.3.1#can-fragment',
    'can-child-nodes@1.2.1#can-child-nodes',
    'can-stache@4.17.21#src/html_section',
    'can-view-target@4.1.6#can-view-target',
    'can-stache@4.17.21#src/utils',
    'can-view-scope@4.13.6#can-view-scope',
    'can-stache-key@1.4.3#can-stache-key',
    'can-reflect-promise@2.2.1#can-reflect-promise',
    'can-view-scope@4.13.6#template-context',
    'can-simple-map@4.3.2#can-simple-map',
    'can-view-scope@4.13.6#compute_data',
    'can-view-scope@4.13.6#scope-key-data',
    'can-view-scope@4.13.6#make-compute-like',
    'can-single-reference@1.3.0#can-single-reference',
    'can-cid@1.3.1#can-cid',
    'can-stache-helpers@1.2.0#can-stache-helpers',
    'can-view-scope@4.13.6#let-context',
    'can-stache@4.17.21#src/key-observable',
    'can-stache@4.17.21#src/text_section',
    'can-view-live@4.2.8#can-view-live',
    'can-view-live@4.2.8#lib/core',
    'can-view-live@4.2.8#lib/attr',
    'can-attribute-observable@1.2.7#behaviors',
    'can-dom-data@1.0.3#can-dom-data',
    'can-view-live@4.2.8#lib/attrs',
    'can-view-live@4.2.8#lib/html',
    'can-view-live@4.2.8#lib/list',
    'can-view-live@4.2.8#lib/set-observable',
    'can-diff@1.5.0#patcher/patcher',
    'can-view-live@4.2.8#lib/text',
    'can-stache@4.17.21#src/mustache_core',
    'can-stache@4.17.21#src/expression',
    'can-stache@4.17.21#expressions/arg',
    'can-stache@4.17.21#expressions/literal',
    'can-stache@4.17.21#expressions/hashes',
    'can-stache@4.17.21#src/expression-helpers',
    'can-simple-observable@2.5.0#setter/setter',
    'can-stache@4.17.21#expressions/bracket',
    'can-stache@4.17.21#expressions/call',
    'can-stache@4.17.21#src/set-identifier',
    'can-stache@4.17.21#expressions/helper',
    'can-stache@4.17.21#expressions/lookup',
    'can-stache@4.17.21#helpers/core',
    'can-globals@1.2.2#base-url/base-url',
    'can-join-uris@1.2.0#can-join-uris',
    'can-parse-uri@1.2.2#can-parse-uri',
    'can-stache@4.17.21#helpers/-debugger',
    'can-stache@4.17.21#src/truthy-observable',
    'can-stache@4.17.21#helpers/converter',
    'can-stache@4.17.21#helpers/-for-of',
    'can-stache@4.17.21#helpers/-let',
    'can-stache@4.17.21#helpers/-portal',
    'can-stache-ast@1.1.0#can-stache-ast',
    'can-stache-ast@1.1.0#controls',
    'can-import-module@1.2.0#can-import-module',
    'can-stache-bindings@4.10.9#can-stache-bindings',
    'can-view-model@4.0.3#can-view-model',
    'can-attribute-observable@1.2.7#can-attribute-observable',
    'can-attribute-observable@1.2.7#event',
    'can-attribute-observable@1.2.7#get-event-name',
    'can-event-dom-radiochange@2.2.1#can-event-dom-radiochange',
    'can-component@4.6.2#control/control',
    'can-control@4.4.3#can-control',
    'can-key@1.2.1#get/get',
    'can-key@1.2.1#utils',
    'can-define@2.8.0#list/list',
    'xml-js@1.6.11#dist/xml-js',
    'moment@2.27.0#moment',
    'bitovians-pto@1.0.0#package.json',
    'can-view-import@4.2.2#can-view-import',
    'bitovians-pto@1.0.0#components/loading/loading',
    'bitovians-pto@1.0.0#components/loading/loading.stache!steal-stache@4.1.5#steal-stache'
], function (_apiInfo, _timeEntries, _bitoviansPto100AppStacheStealStache, _canComponent) {
    'use strict';
    var _apiInfo2 = _interopRequireDefault(_apiInfo);
    var _timeEntries2 = _interopRequireDefault(_timeEntries);
    var _bitoviansPto100AppStacheStealStache2 = _interopRequireDefault(_bitoviansPto100AppStacheStealStache);
    var _canComponent2 = _interopRequireDefault(_canComponent);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _canComponent2.default.extend({
        tag: 'bitovians-pto',
        view: _bitoviansPto100AppStacheStealStache2.default,
        ViewModel: {
            get isAuthenticated() {
                return this.apiInfo.isValid;
            },
            apiInfo: {
                default: function _default() {
                    return new _apiInfo2.default({});
                }
            },
            clearAPIToken: function clearAPIToken(ev) {
                ev.preventDefault();
                this.apiInfo.token = undefined;
            },
            timeEntries: {
                get: function get(lastSet) {
                    if (lastSet)
                        return lastSet;
                    return new _timeEntries2.default({ apiInfo: this.apiInfo });
                }
            }
        }
    });
});